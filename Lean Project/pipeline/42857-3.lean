import Mathlib.RingTheory.FiniteType
import Mathlib.RingTheory.Ideal.BigOperators
import Mathlib.RingTheory.FiniteType

/-!

# Rees algebra

The Rees algebra of an ideal `I` is the subalgebra `R[It]` of `R[t]` defined as `R[It] = ⨁ₙ Iⁿ tⁿ`.
This is used to prove the Artin-Rees lemma, and will potentially enable us to calculate some
blowup in the future.

## Main definition

- `reesAlgebra` : The Rees algebra of an ideal `I`, defined as a subalgebra of `R[X]`.
- `adjoin_monomial_eq_reesAlgebra` : The Rees algebra is generated by the degree one elements.
- `reesAlgebra.fg` : The Rees algebra of a f.g. ideal is of finite type. In particular, this
implies that the rees algebra over a noetherian ring is still noetherian.

-/


universe u v

variable {R M : Type u} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)

open Polynomial

/-- The Rees algebra of an ideal `I`, defined as the subalgebra of `R[X]` whose `i`-th coefficient
falls in `I ^ i`. -/
def reesAlgebra : Subalgebra R R[X] where
  carrier := { f | ∀ i, f.coeff i ∈ I ^ i }
  mul_mem' := by
    rintro f g ⟨hf, hg⟩ i
    rw [coeff_mul]
    apply Finset.sum_mem
    rintro ⟨j, k⟩ hjk
    rw [mul_comm]
    apply Ideal.mul_mem_mul
    · exact hf j
    · exact hg k
  add_mem' := by
    rintro f g ⟨hf, hg⟩ i
    apply add_mem
    · exact hf i
    · exact hg i
  algebraMap_mem' := by
    rintro r i
    by_cases hi : i = 0
    · subst hi
      exact algebraMap_mem _ _
    · rw [coeff_C, if_neg hi]
      simp

namespace reesAlgebra

variable {I}

@[simp]
example (f : R[X]) : f ∈ reesAlgebra I ↔ ∀ i, f.coeff i ∈ I ^ i :=
Iff.rfl
example :
  (adjoin R ((fun x : I => Polynomial.C (↑x)) '' I)).map (C.ringHom R R[X]) = reesAlgebra I :=
begin
  ext f,
  simp only [mem_map, mem_adjoin_iff, Set.mem_image, exists_prop, exists_and_left,
    Polynomial.mem_supported_iff, Polynomial.C_eq_monomial],
  split,
  { rintro ⟨s, hs, rfl⟩,
    exact λ i, by { rw [monomial_apply, if_pos rfl], exact hs i } },
  { intro hf,
    choose s hs using λ i, hf i,
    refine ⟨s, λ i, hs i, funext (λ x, _)⟩,
    by_cases hx : x ∈ s.support,
    { rw [if_pos hx],
      exact hs _ hx },
    { rw [if_neg hx],
      simp } }
end

theorem rees_algebra_fg_of_fg (hI : I.FG) : (reesAlgebra I).FG :=
begin
  obtain ⟨s, hs⟩ := hI,
  let s' := (fun x : I => Polynomial.C (↑x)) '' s,
  use s',
  rintro f ⟨t, ht, rfl⟩,
  rw [finset.sum_apply'],
  exact finset.sum_mem (finset.mem_image_of_mem (fun x => Polynomial.C (↑x)) ht),
  rintro j hj,
  rw [monomial_apply_eq_zero_of_ne],
  { simp only [finset.mem_filter, mem_support_iff, ne.def, not_false_iff, Polynomial.C_apply,
      Polynomial.monomial_apply, Polynomial.X_apply_one, one_mul],
    exact ⟨j, hj⟩ },
  { intro h,
    apply h,
    rw [finset.mem_filter, mem_support_iff],
    exact ⟨i, hi⟩ }
end

theorem reesAlgebra.fg (hI : I.FG) : (reesAlgebra I).FG :=
begin
  obtain ⟨s, hs⟩ := hI,
  let s' := (fun x : I => Polynomial.C (↑x)) '' s,
  use s',
  rintro f ⟨t, ht, rfl⟩,
  rw [finset.sum_apply'],
  exact finset.sum_mem (finset.mem_image_of_mem (fun x => Polynomial.C (↑x)) ht),
  rintro j hj,
  rw [monomial_apply_eq_zero_of_ne],
  { simp only [finset.mem_filter, mem_support_iff, ne.def, not_false_iff, Polynomial.C_apply,
      Polynomial.monomial_apply, Polynomial.X_apply_one, one_mul],
    exact ⟨j, hj⟩ },
  { intro h,
    apply h,
    rw [finset.mem_filter, mem_support_iff],
    exact ⟨i, hi⟩ }
end

/- ACTUAL PROOF OF reesAlgebra.fg -/

example (hI : I.FG) : (reesAlgebra I).FG := by
  classical
    obtain ⟨s, hs⟩ := hI
    rw [← adjoin_monomial_eq_reesAlgebra, ← hs]
    use s.image (monomial 1)
    rw [Finset.coe_image]
    change
      _ =
        Algebra.adjoin R
          (Submodule.map (monomial 1 : R →ₗ[R] R[X]) (Submodule.span R ↑s) : Set R[X])
    rw [Submodule.map_span, Algebra.adjoin_span]