import Mathlib.Analysis.Calculus.FDeriv.Linear
import Mathlib.Analysis.Calculus.FDeriv.Comp
import Mathlib.Analysis.Calculus.FDeriv.Add

open HasStrictFDerivAt
open Filter Asymptotics ContinuousLinearMap Set Metric
open scoped Classical
open Topology NNReal Filter Asymptotics ENNReal
variable {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {G' : Type*} [NormedAddCommGroup G'] [NormedSpace ğ•œ G']
variable {f fâ‚€ fâ‚ g : E â†’ F}
variable {f' fâ‚€' fâ‚' g' : E â†’L[ğ•œ] F}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {G' : Type*} [NormedAddCommGroup G'] [NormedSpace ğ•œ G']
variable {f fâ‚€ fâ‚ g : E â†’ F}
variable {f' fâ‚€' fâ‚' g' : E â†’L[ğ•œ] F}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {G' : Type*} [NormedAddCommGroup G'] [NormedSpace ğ•œ G']
variable {f fâ‚€ fâ‚ g : E â†’ F}
variable {f' fâ‚€' fâ‚' g' : E â†’L[ğ•œ] F}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {G' : Type*} [NormedAddCommGroup G'] [NormedSpace ğ•œ G']
variable {f fâ‚€ fâ‚ g : E â†’ F}
variable {f' fâ‚€' fâ‚' g' : E â†’L[ğ•œ] F}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {G' : Type*} [NormedAddCommGroup G'] [NormedSpace ğ•œ G']
variable {f fâ‚€ fâ‚ g : E â†’ F}
variable {f' fâ‚€' fâ‚' g' : E â†’L[ğ•œ] F}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {f fâ‚€ fâ‚ g : E â†’ F}
variable {f' fâ‚€' fâ‚' g' : E â†’L[ğ•œ] F}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {f' fâ‚€' fâ‚' g' : E â†’L[ğ•œ] F}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable (e : E â†’L[ğ•œ] F)
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {x : E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {s t : Set E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {L Lâ‚ Lâ‚‚ : Filter E}
variable {R : Type*} [Semiring R] [Module R F] [SMulCommClass ğ•œ R F] [ContinuousConstSMul R F]
variable {Î¹ : Type*} {u : Finset Î¹} {A : Î¹ â†’ E â†’ F} {A' : Î¹ â†’ E â†’L[ğ•œ] F}


example (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x) :
    HasStrictFDerivAt (fun x => f x - g x) (f' - g') x := by
  simpa only [sub_eq_add_neg] using hf.add hg.neg