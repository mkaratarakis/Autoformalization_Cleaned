
1. **Informal Theorem**  
Path in Set Implies Both Endpoints are in the Set : For any topological space \( X \) and any subset \( F \subseteq X \), if there is a path \( \gamma \) joining points \( x \) and \( y \) such that the image of \( \gamma \) is contained in \( F \), then both \( x \) and \( y \) are elements of \( F \).

2. **Informal Proof**  
Given a topological space \( X \) and a subset \( F \subseteq X \), suppose there is a path \( \gamma \) joining points \( x \) and \( y \) such that the image of \( \gamma \) is contained in \( F \). This means there exists a continuous function \( \gamma : [0, 1] \to X \) such that \( \gamma(0) = x \), \( \gamma(1) = y \), and \( \gamma(t) \in F \) for all \( t \in [0, 1] \).

To prove that \( x \in F \) and \( y \in F \), we note that since \( \gamma(t) \in F \) for all \( t \in [0, 1] \), it follows that \( \gamma(0) \in F \) and \( \gamma(1) \in F \). By the definition of the path \( \gamma \), we have \( \gamma(0) = x \) and \( \gamma(1) = y \). Therefore, \( x \in F \) and \( y \in F \).

This completes the proof. \(\blacksquare\)

3. **Formal Theorem**  
example (h : JoinedIn F x y) : x ‚àà F ‚àß y ‚àà F := by sorry

4. **Prefix**
import Mathlib.Topology.Order.ProjIcc
import Mathlib.Topology.CompactOpen
import Mathlib.Topology.UnitInterval
import Mathlib.Topology.Connected.PathConnected

open JoinedIn
open Topology Filter unitInterval Set Function
variable {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {Œπ : Type*}
variable (Œ≥ : Path x y)
open ContinuousMap
variable {a‚ÇÅ a‚ÇÇ a‚ÇÉ : X} {b‚ÇÅ b‚ÇÇ b‚ÇÉ : Y}
variable {œá : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (œá i)] {as bs cs : ‚àÄ i, œá i}
variable (X)
variable {X}
variable {F : Set X}

example (h : JoinedIn F x y) : x ‚àà F ‚àß y ‚àà F := by

5. **Header Information**  
-- BEGIN Mathlib.Topology.Order.ProjIcc --
/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov, Patrick Massot
-/
import Mathlib.Order.Interval.Set.ProjIcc
import Mathlib.Topology.Order.Basic

/-!
# Projection onto a closed interval

In this file we prove that the projection `Set.projIcc f a b h` is a quotient map, and use it
to show that `Set.IccExtend h f` is continuous if and only if `f` is continuous.
-/


open Set Filter Topology

variable {Œ± Œ≤ Œ≥ : Type*} [LinearOrder Œ±] {a b c : Œ±} {h : a ‚â§ b}

protected theorem Filter.Tendsto.IccExtend (f : Œ≥ ‚Üí Icc a b ‚Üí Œ≤) {la : Filter Œ±} {lb : Filter Œ≤}
    {lc : Filter Œ≥} (hf : Tendsto (‚Üøf) (lc √óÀ¢ la.map (projIcc a b h)) lb) :
    Tendsto (‚Üø(IccExtend h ‚àò f)) (lc √óÀ¢ la) lb :=
  hf.comp <| tendsto_id.prodMap tendsto_map

variable [TopologicalSpace Œ±] [OrderTopology Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥]

@[continuity]
theorem continuous_projIcc : Continuous (projIcc a b h) :=
  (continuous_const.max <| continuous_const.min continuous_id).subtype_mk _

theorem isQuotientMap_projIcc : IsQuotientMap (projIcc a b h) :=
  isQuotientMap_iff.2 ‚ü®projIcc_surjective h, fun s =>
    ‚ü®fun hs => hs.preimage continuous_projIcc, fun hs => ‚ü®_, hs, by ext; simp‚ü©‚ü©‚ü©

@[deprecated (since := "2024-10-22")]
alias quotientMap_projIcc := isQuotientMap_projIcc

@[simp]
theorem continuous_IccExtend_iff {f : Icc a b ‚Üí Œ≤} : Continuous (IccExtend h f) ‚Üî Continuous f :=
  isQuotientMap_projIcc.continuous_iff.symm

/-- See Note [continuity lemma statement]. -/
protected theorem Continuous.IccExtend {f : Œ≥ ‚Üí Icc a b ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (hf : Continuous ‚Üøf)
    (hg : Continuous g) : Continuous fun a => IccExtend h (f a) (g a) :=
  show Continuous (‚Üøf ‚àò fun x => (x, projIcc a b h (g x)))
  from hf.comp <| continuous_id.prodMk <| continuous_projIcc.comp hg

/-- A useful special case of `Continuous.IccExtend`. -/
@[continuity]
protected theorem Continuous.Icc_extend' {f : Icc a b ‚Üí Œ≤} (hf : Continuous f) :
    Continuous (IccExtend h f) :=
  hf.comp continuous_projIcc

theorem ContinuousAt.IccExtend {x : Œ≥} (f : Œ≥ ‚Üí Icc a b ‚Üí Œ≤) {g : Œ≥ ‚Üí Œ±}
    (hf : ContinuousAt (‚Üøf) (x, projIcc a b h (g x))) (hg : ContinuousAt g x) :
    ContinuousAt (fun a => IccExtend h (f a) (g a)) x :=
  show ContinuousAt (‚Üøf ‚àò fun x => (x, projIcc a b h (g x))) x from
    ContinuousAt.comp hf <| continuousAt_id.prodMk <| continuous_projIcc.continuousAt.comp hg

-- END Mathlib.Topology.Order.ProjIcc --

-- BEGIN Mathlib.Topology.CompactOpen --
/-
Copyright (c) 2018 Reid Barton. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reid Barton
-/
import Mathlib.Topology.Hom.ContinuousEval
import Mathlib.Topology.ContinuousMap.Basic
import Mathlib.Topology.Separation.Regular

/-!
# The compact-open topology

In this file, we define the compact-open topology on the set of continuous maps between two
topological spaces.

## Main definitions

* `ContinuousMap.compactOpen` is the compact-open topology on `C(X, Y)`.
  It is declared as an instance.
* `ContinuousMap.coev` is the coevaluation map `Y ‚Üí C(X, Y √ó X)`. It is always continuous.
* `ContinuousMap.curry` is the currying map `C(X √ó Y, Z) ‚Üí C(X, C(Y, Z))`. This map always exists
  and it is continuous as long as `X √ó Y` is locally compact.
* `ContinuousMap.uncurry` is the uncurrying map `C(X, C(Y, Z)) ‚Üí C(X √ó Y, Z)`. For this map to
  exist, we need `Y` to be locally compact. If `X` is also locally compact, then this map is
  continuous.
* `Homeomorph.curry` combines the currying and uncurrying operations into a homeomorphism
  `C(X √ó Y, Z) ‚âÉ‚Çú C(X, C(Y, Z))`. This homeomorphism exists if `X` and `Y` are locally compact.


## Tags

compact-open, curry, function space
-/


open Set Filter TopologicalSpace Topology

namespace ContinuousMap

section CompactOpen

variable {Œ± X Y Z T : Type*}
variable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]
variable {K : Set X} {U : Set Y}

/-- The compact-open topology on the space of continuous maps `C(X, Y)`. -/
instance compactOpen : TopologicalSpace C(X, Y) :=
  .generateFrom <| image2 (fun K U ‚Ü¶ {f | MapsTo f K U}) {K | IsCompact K} {U | IsOpen U}

/-- Definition of `ContinuousMap.compactOpen`. -/
theorem compactOpen_eq : @compactOpen X Y _ _ =
    .generateFrom (image2 (fun K U ‚Ü¶ {f | MapsTo f K U}) {K | IsCompact K} {t | IsOpen t}) :=
   rfl

theorem isOpen_setOf_mapsTo (hK : IsCompact K) (hU : IsOpen U) :
    IsOpen {f : C(X, Y) | MapsTo f K U} :=
  isOpen_generateFrom_of_mem <| mem_image2_of_mem hK hU

lemma eventually_mapsTo {f : C(X, Y)} (hK : IsCompact K) (hU : IsOpen U) (h : MapsTo f K U) :
    ‚àÄ·∂† g : C(X, Y) in ùìù f, MapsTo g K U :=
  (isOpen_setOf_mapsTo hK hU).mem_nhds h

lemma nhds_compactOpen (f : C(X, Y)) :
    ùìù f = ‚®Ö (K : Set X) (_ : IsCompact K) (U : Set Y) (_ : IsOpen U) (_ : MapsTo f K U),
      ùìü {g : C(X, Y) | MapsTo g K U} := by
  simp_rw [compactOpen_eq, nhds_generateFrom, mem_setOf_eq, @and_comm (f ‚àà _), iInf_and,
    ‚Üê image_prod, iInf_image, biInf_prod, mem_setOf_eq]

lemma tendsto_nhds_compactOpen {l : Filter Œ±} {f : Œ± ‚Üí C(Y, Z)} {g : C(Y, Z)} :
    Tendsto f l (ùìù g) ‚Üî
      ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí MapsTo g K U ‚Üí ‚àÄ·∂† a in l, MapsTo (f a) K U := by
  simp [nhds_compactOpen]

lemma continuous_compactOpen {f : X ‚Üí C(Y, Z)} :
    Continuous f ‚Üî ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí IsOpen {x | MapsTo (f x) K U} :=
  continuous_generateFrom_iff.trans forall_mem_image2

section Functorial

/-- `C(X, ¬∑)` is a functor. -/
theorem continuous_postcomp (g : C(Y, Z)) : Continuous (ContinuousMap.comp g : C(X, Y) ‚Üí C(X, Z)) :=
  continuous_compactOpen.2 fun _K hK _U hU ‚Ü¶ isOpen_setOf_mapsTo hK (hU.preimage g.2)

@[deprecated (since := "2024-10-19")] alias continuous_comp := continuous_postcomp

/-- If `g : C(Y, Z)` is a topology inducing map,
then the composition `ContinuousMap.comp g : C(X, Y) ‚Üí C(X, Z)` is a topology inducing map too. -/
theorem isInducing_postcomp (g : C(Y, Z)) (hg : IsInducing g) :
    IsInducing (g.comp : C(X, Y) ‚Üí C(X, Z)) where
  eq_induced := by
    simp only [compactOpen_eq, induced_generateFrom_eq, image_image2, hg.setOf_isOpen,
      image2_image_right, MapsTo, mem_preimage, preimage_setOf_eq, comp_apply]

@[deprecated (since := "2024-10-28")] alias inducing_postcomp := isInducing_postcomp

@[deprecated (since := "2024-10-19")] alias inducing_comp := isInducing_postcomp

/-- If `g : C(Y, Z)` is a topological embedding,
then the composition `ContinuousMap.comp g : C(X, Y) ‚Üí C(X, Z)` is an embedding too. -/
theorem isEmbedding_postcomp (g : C(Y, Z)) (hg : IsEmbedding g) :
    IsEmbedding (g.comp : C(X, Y) ‚Üí C(X, Z)) :=
  ‚ü®isInducing_postcomp g hg.1, fun _ _ ‚Ü¶ (cancel_left hg.2).1‚ü©

@[deprecated (since := "2024-10-26")]
alias embedding_postcomp := isEmbedding_postcomp

@[deprecated (since := "2024-10-19")] alias embedding_comp := isEmbedding_postcomp

/-- `C(¬∑, Z)` is a functor. -/
@[continuity, fun_prop]
theorem continuous_precomp (f : C(X, Y)) : Continuous (fun g => g.comp f : C(Y, Z) ‚Üí C(X, Z)) :=
  continuous_compactOpen.2 fun K hK U hU ‚Ü¶ by
    simpa only [mapsTo_image_iff] using isOpen_setOf_mapsTo (hK.image f.2) hU

@[deprecated (since := "2024-10-19")] alias continuous_comp_left := continuous_precomp

variable (Z) in
/-- Precomposition by a continuous map is itself a continuous map between spaces of continuous maps.
-/
@[simps apply]
def compRightContinuousMap (f : C(X, Y)) :
    C(C(Y, Z), C(X, Z)) where
  toFun g := g.comp f

/-- Any pair of homeomorphisms `X ‚âÉ‚Çú Z` and `Y ‚âÉ‚Çú T` gives rise to a homeomorphism
`C(X, Y) ‚âÉ‚Çú C(Z, T)`. -/
protected def _root_.Homeomorph.arrowCongr (œÜ : X ‚âÉ‚Çú Z) (œà : Y ‚âÉ‚Çú T) :
    C(X, Y) ‚âÉ‚Çú C(Z, T) where
  toFun f := .comp œà <| f.comp œÜ.symm
  invFun f := .comp œà.symm <| f.comp œÜ
  left_inv f := ext fun _ ‚Ü¶ œà.left_inv (f _) |>.trans <| congrArg f <| œÜ.left_inv _
  right_inv f := ext fun _ ‚Ü¶ œà.right_inv (f _) |>.trans <| congrArg f <| œÜ.right_inv _
  continuous_toFun := continuous_postcomp _ |>.comp <| continuous_precomp _
  continuous_invFun := continuous_postcomp _ |>.comp <| continuous_precomp _

variable (Z) in
/-- Precomposition by a homeomorphism is itself a homeomorphism between spaces of continuous maps.
-/
@[deprecated Homeomorph.arrowCongr (since := "2024-10-19")]
def compRightHomeomorph (f : X ‚âÉ‚Çú Y) :
    C(Y, Z) ‚âÉ‚Çú C(X, Z) :=
  .arrowCongr f.symm (.refl _)

variable [LocallyCompactPair Y Z]

/-- Composition is a continuous map from `C(X, Y) √ó C(Y, Z)` to `C(X, Z)`,
provided that `Y` is locally compact.
This is Prop. 9 of Chap. X, ¬ß3, ‚Ññ. 4 of Bourbaki's *Topologie G√©n√©rale*. -/
theorem continuous_comp' : Continuous fun x : C(X, Y) √ó C(Y, Z) => x.2.comp x.1 := by
  simp_rw [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_compactOpen]
  intro ‚ü®f, g‚ü© K hK U hU (hKU : MapsTo (g ‚àò f) K U)
  obtain ‚ü®L, hKL, hLc, hLU‚ü© : ‚àÉ L ‚àà ùìùÀ¢ (f '' K), IsCompact L ‚àß MapsTo g L U :=
    exists_mem_nhdsSet_isCompact_mapsTo g.continuous (hK.image f.continuous) hU
      (mapsTo_image_iff.2 hKU)
  rw [‚Üê subset_interior_iff_mem_nhdsSet, ‚Üê mapsTo'] at hKL
  exact ((eventually_mapsTo hK isOpen_interior hKL).prod_nhds
    (eventually_mapsTo hLc hU hLU)).mono fun ‚ü®f', g'‚ü© ‚ü®hf', hg'‚ü© ‚Ü¶
      hg'.comp <| hf'.mono_right interior_subset

lemma _root_.Filter.Tendsto.compCM {Œ± : Type*} {l : Filter Œ±} {g : Œ± ‚Üí C(Y, Z)} {g‚ÇÄ : C(Y, Z)}
    {f : Œ± ‚Üí C(X, Y)} {f‚ÇÄ : C(X, Y)} (hg : Tendsto g l (ùìù g‚ÇÄ)) (hf : Tendsto f l (ùìù f‚ÇÄ)) :
    Tendsto (fun a ‚Ü¶ (g a).comp (f a)) l (ùìù (g‚ÇÄ.comp f‚ÇÄ)) :=
  (continuous_comp'.tendsto (f‚ÇÄ, g‚ÇÄ)).comp (hf.prodMk_nhds hg)

variable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' ‚Üí C(Y, Z)} {f : X' ‚Üí C(X, Y)}
  {s : Set X'}

nonrec lemma _root_.ContinuousAt.compCM (hg : ContinuousAt g a) (hf : ContinuousAt f a) :
    ContinuousAt (fun x ‚Ü¶ (g x).comp (f x)) a :=
  hg.compCM hf

nonrec lemma _root_.ContinuousWithinAt.compCM (hg : ContinuousWithinAt g s a)
    (hf : ContinuousWithinAt f s a) : ContinuousWithinAt (fun x ‚Ü¶ (g x).comp (f x)) s a :=
  hg.compCM hf

lemma _root_.ContinuousOn.compCM (hg : ContinuousOn g s) (hf : ContinuousOn f s) :
    ContinuousOn (fun x ‚Ü¶ (g x).comp (f x)) s := fun a ha ‚Ü¶
  (hg a ha).compCM (hf a ha)

lemma _root_.Continuous.compCM (hg : Continuous g) (hf : Continuous f) :
    Continuous fun x => (g x).comp (f x) :=
  continuous_comp'.comp (hf.prodMk hg)

end Functorial

section Ev

/-- The evaluation map `C(X, Y) √ó X ‚Üí Y` is continuous
if `X, Y` is a locally compact pair of spaces. -/
instance [LocallyCompactPair X Y] : ContinuousEval C(X, Y) X Y where
  continuous_eval := by
    simp_rw [continuous_iff_continuousAt, ContinuousAt, (nhds_basis_opens _).tendsto_right_iff]
    rintro ‚ü®f, x‚ü© U ‚ü®hx : f x ‚àà U, hU : IsOpen U‚ü©
    rcases exists_mem_nhds_isCompact_mapsTo f.continuous (hU.mem_nhds hx) with ‚ü®K, hxK, hK, hKU‚ü©
    filter_upwards [prod_mem_nhds (eventually_mapsTo hK hU hKU) hxK] using fun _ h ‚Ü¶ h.1 h.2

instance : ContinuousEvalConst C(X, Y) X Y where
  continuous_eval_const x :=
    continuous_def.2 fun U hU ‚Ü¶ by simpa using isOpen_setOf_mapsTo isCompact_singleton hU

lemma isClosed_setOf_mapsTo {t : Set Y} (ht : IsClosed t) (s : Set X) :
    IsClosed {f : C(X, Y) | MapsTo f s t} :=
  ht.setOf_mapsTo fun _ _ ‚Ü¶ continuous_eval_const _

lemma isClopen_setOf_mapsTo (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} :=
  ‚ü®isClosed_setOf_mapsTo hU.isClosed K, isOpen_setOf_mapsTo hK hU.isOpen‚ü©

@[norm_cast]
lemma specializes_coe {f g : C(X, Y)} : ‚áëf ‚§≥ ‚áëg ‚Üî f ‚§≥ g := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ h.map continuous_coeFun‚ü©
  suffices ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí MapsTo g K U ‚Üí MapsTo f K U by
    simpa [specializes_iff_pure, nhds_compactOpen]
  exact fun K _ U hU hg x hx ‚Ü¶ (h.map (continuous_apply x)).mem_open hU (hg hx)

@[norm_cast]
lemma inseparable_coe {f g : C(X, Y)} : Inseparable (f : X ‚Üí Y) g ‚Üî Inseparable f g := by
  simp only [inseparable_iff_specializes_and, specializes_coe]

instance [T0Space Y] : T0Space C(X, Y) :=
  t0Space_of_injective_of_continuous DFunLike.coe_injective continuous_coeFun

instance [R0Space Y] : R0Space C(X, Y) where
  specializes_symmetric f g h := by
    rw [‚Üê specializes_coe] at h ‚ä¢
    exact h.symm

instance [T1Space Y] : T1Space C(X, Y) :=
  t1Space_of_injective_of_continuous DFunLike.coe_injective continuous_coeFun

instance [R1Space Y] : R1Space C(X, Y) :=
  .of_continuous_specializes_imp continuous_coeFun fun _ _ ‚Ü¶ specializes_coe.1

instance [T2Space Y] : T2Space C(X, Y) := inferInstance

instance [RegularSpace Y] : RegularSpace C(X, Y) :=
  .of_lift'_closure_le fun f ‚Ü¶ by
    rw [‚Üê tendsto_id', tendsto_nhds_compactOpen]
    intro K hK U hU hf
    rcases (hK.image f.continuous).exists_isOpen_closure_subset (hU.mem_nhdsSet.2 hf.image_subset)
      with ‚ü®V, hVo, hKV, hVU‚ü©
    filter_upwards [mem_lift' (eventually_mapsTo hK hVo (mapsTo'.2 hKV))] with g hg
    refine ((isClosed_setOf_mapsTo isClosed_closure K).closure_subset ?_).mono_right hVU
    exact closure_mono (fun _ h ‚Ü¶ h.mono_right subset_closure) hg

instance [T3Space Y] : T3Space C(X, Y) := inferInstance

end Ev

section InfInduced

/-- For any subset `s` of `X`, the restriction of continuous functions to `s` is continuous
as a function from `C(X, Y)` to `C(s, Y)` with their respective compact-open topologies. -/
theorem continuous_restrict (s : Set X) : Continuous fun F : C(X, Y) => F.restrict s :=
  continuous_precomp <| restrict s <| .id X

theorem compactOpen_le_induced (s : Set X) :
    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) ‚â§
      .induced (restrict s) ContinuousMap.compactOpen :=
  (continuous_restrict s).le_induced

/-- The compact-open topology on `C(X, Y)`
is equal to the infimum of the compact-open topologies on `C(s, Y)` for `s` a compact subset of `X`.
The key point of the proof is that for every compact set `K`,
the universal set `Set.univ : Set K` is a compact set as well. -/
theorem compactOpen_eq_iInf_induced :
    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =
      ‚®Ö (K : Set X) (_ : IsCompact K), .induced (.restrict K) ContinuousMap.compactOpen := by
  refine le_antisymm (le_iInf‚ÇÇ fun s _ ‚Ü¶ compactOpen_le_induced s) ?_
  refine le_generateFrom <| forall_mem_image2.2 fun K (hK : IsCompact K) U hU ‚Ü¶ ?_
  refine TopologicalSpace.le_def.1 (iInf‚ÇÇ_le K hK) _ ?_
  convert isOpen_induced (isOpen_setOf_mapsTo (isCompact_iff_isCompact_univ.1 hK) hU)
  simp [mapsTo_univ_iff, Subtype.forall, MapsTo]

theorem nhds_compactOpen_eq_iInf_nhds_induced (f : C(X, Y)) :
    ùìù f = ‚®Ö (s) (_ : IsCompact s), (ùìù (f.restrict s)).comap (ContinuousMap.restrict s) := by
  rw [compactOpen_eq_iInf_induced]
  simp only [nhds_iInf, nhds_induced]

theorem tendsto_compactOpen_restrict {Œπ : Type*} {l : Filter Œπ} {F : Œπ ‚Üí C(X, Y)} {f : C(X, Y)}
    (hFf : Filter.Tendsto F l (ùìù f)) (s : Set X) :
    Tendsto (fun i => (F i).restrict s) l (ùìù (f.restrict s)) :=
  (continuous_restrict s).continuousAt.tendsto.comp hFf

theorem tendsto_compactOpen_iff_forall {Œπ : Type*} {l : Filter Œπ} (F : Œπ ‚Üí C(X, Y)) (f : C(X, Y)) :
    Tendsto F l (ùìù f) ‚Üî
      ‚àÄ K, IsCompact K ‚Üí Tendsto (fun i => (F i).restrict K) l (ùìù (f.restrict K)) := by
  rw [compactOpen_eq_iInf_induced]
  simp [nhds_iInf, nhds_induced, Filter.tendsto_comap_iff, Function.comp_def]

/-- A family `F` of functions in `C(X, Y)` converges in the compact-open topology, if and only if
it converges in the compact-open topology on each compact subset of `X`. -/
theorem exists_tendsto_compactOpen_iff_forall [WeaklyLocallyCompactSpace X] [T2Space Y]
    {Œπ : Type*} {l : Filter Œπ} [Filter.NeBot l] (F : Œπ ‚Üí C(X, Y)) :
    (‚àÉ f, Filter.Tendsto F l (ùìù f)) ‚Üî
      ‚àÄ s : Set X, IsCompact s ‚Üí ‚àÉ f, Filter.Tendsto (fun i => (F i).restrict s) l (ùìù f) := by
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü© s _
    exact ‚ü®f.restrict s, tendsto_compactOpen_restrict hf s‚ü©
  ¬∑ intro h
    choose f hf using h
    -- By uniqueness of limits in a `T2Space`, since `fun i ‚Ü¶ F i x` tends to both `f s‚ÇÅ hs‚ÇÅ x` and
    -- `f s‚ÇÇ hs‚ÇÇ x`, we have `f s‚ÇÅ hs‚ÇÅ x = f s‚ÇÇ hs‚ÇÇ x`
    have h :
      ‚àÄ (s‚ÇÅ) (hs‚ÇÅ : IsCompact s‚ÇÅ) (s‚ÇÇ) (hs‚ÇÇ : IsCompact s‚ÇÇ) (x : X) (hxs‚ÇÅ : x ‚àà s‚ÇÅ) (hxs‚ÇÇ : x ‚àà s‚ÇÇ),
        f s‚ÇÅ hs‚ÇÅ ‚ü®x, hxs‚ÇÅ‚ü© = f s‚ÇÇ hs‚ÇÇ ‚ü®x, hxs‚ÇÇ‚ü© := by
      rintro s‚ÇÅ hs‚ÇÅ s‚ÇÇ hs‚ÇÇ x hxs‚ÇÅ hxs‚ÇÇ
      haveI := isCompact_iff_compactSpace.mp hs‚ÇÅ
      haveI := isCompact_iff_compactSpace.mp hs‚ÇÇ
      have h‚ÇÅ := (continuous_eval_const (‚ü®x, hxs‚ÇÅ‚ü© : s‚ÇÅ)).continuousAt.tendsto.comp (hf s‚ÇÅ hs‚ÇÅ)
      have h‚ÇÇ := (continuous_eval_const (‚ü®x, hxs‚ÇÇ‚ü© : s‚ÇÇ)).continuousAt.tendsto.comp (hf s‚ÇÇ hs‚ÇÇ)
      exact tendsto_nhds_unique h‚ÇÅ h‚ÇÇ
    -- So glue the `f s hs` together and prove that this glued function `f‚ÇÄ` is a limit on each
    -- compact set `s`
    refine ‚ü®liftCover' _ _ h exists_compact_mem_nhds, ?_‚ü©
    rw [tendsto_compactOpen_iff_forall]
    intro s hs
    rw [liftCover_restrict']
    exact hf s hs

end InfInduced

section Coev

variable (X Y)

/-- The coevaluation map `Y ‚Üí C(X, Y √ó X)` sending a point `x : Y` to the continuous function
on `X` sending `y` to `(x, y)`. -/
@[simps -fullyApplied]
def coev (b : Y) : C(X, Y √ó X) :=
  { toFun := Prod.mk b }

variable {X Y}

theorem image_coev {y : Y} (s : Set X) : coev X Y y '' s = {y} √óÀ¢ s := by simp [singleton_prod]

/-- The coevaluation map `Y ‚Üí C(X, Y √ó X)` is continuous (always). -/
theorem continuous_coev : Continuous (coev X Y) := by
  have : ‚àÄ {a K U}, MapsTo (coev X Y a) K U ‚Üî {a} √óÀ¢ K ‚äÜ U := by simp [singleton_prod, mapsTo']
  simp only [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_compactOpen, this]
  intro x K hK U hU hKU
  rcases generalized_tube_lemma isCompact_singleton hK hU hKU with ‚ü®V, W, hV, -, hxV, hKW, hVWU‚ü©
  filter_upwards [hV.mem_nhds (hxV rfl)] with a ha
  exact (prod_mono (singleton_subset_iff.mpr ha) hKW).trans hVWU

end Coev

section Curry

/-- The curried form of a continuous map `Œ± √ó Œ≤ ‚Üí Œ≥` as a continuous map `Œ± ‚Üí C(Œ≤, Œ≥)`.
    If `a √ó Œ≤` is locally compact, this is continuous. If `Œ±` and `Œ≤` are both locally
    compact, then this is a homeomorphism, see `Homeomorph.curry`. -/
def curry (f : C(X √ó Y, Z)) : C(X, C(Y, Z)) where
  toFun a := ‚ü®Function.curry f a, f.continuous.comp <| by fun_prop‚ü©
  continuous_toFun := (continuous_postcomp f).comp continuous_coev

@[simp]
theorem curry_apply (f : C(X √ó Y, Z)) (a : X) (b : Y) : f.curry a b = f (a, b) :=
  rfl

/-- To show continuity of a map `Œ± ‚Üí C(Œ≤, Œ≥)`, it suffices to show that its uncurried form
    `Œ± √ó Œ≤ ‚Üí Œ≥` is continuous. -/
theorem continuous_of_continuous_uncurry (f : X ‚Üí C(Y, Z))
    (h : Continuous (Function.uncurry fun x y => f x y)) : Continuous f :=
  (curry ‚ü®_, h‚ü©).2

/-- The currying process is a continuous map between function spaces. -/
theorem continuous_curry [LocallyCompactSpace (X √ó Y)] :
    Continuous (curry : C(X √ó Y, Z) ‚Üí C(X, C(Y, Z))) := by
  apply continuous_of_continuous_uncurry
  apply continuous_of_continuous_uncurry
  rw [‚Üê (Homeomorph.prodAssoc _ _ _).symm.comp_continuous_iff']
  exact continuous_eval

/-- The uncurried form of a continuous map `X ‚Üí C(Y, Z)` is a continuous map `X √ó Y ‚Üí Z`. -/
theorem continuous_uncurry_of_continuous [LocallyCompactSpace Y] (f : C(X, C(Y, Z))) :
    Continuous (Function.uncurry fun x y => f x y) :=
  continuous_eval.comp <| f.continuous.prodMap continuous_id

/-- The uncurried form of a continuous map `X ‚Üí C(Y, Z)` as a continuous map `X √ó Y ‚Üí Z` (if `Y` is
    locally compact). If `X` is also locally compact, then this is a homeomorphism between the two
    function spaces, see `Homeomorph.curry`. -/
@[simps]
def uncurry [LocallyCompactSpace Y] (f : C(X, C(Y, Z))) : C(X √ó Y, Z) :=
  ‚ü®_, continuous_uncurry_of_continuous f‚ü©

/-- The uncurrying process is a continuous map between function spaces. -/
theorem continuous_uncurry [LocallyCompactSpace X] [LocallyCompactSpace Y] :
    Continuous (uncurry : C(X, C(Y, Z)) ‚Üí C(X √ó Y, Z)) := by
  apply continuous_of_continuous_uncurry
  rw [‚Üê (Homeomorph.prodAssoc _ _ _).comp_continuous_iff']
  dsimp [Function.comp_def]
  exact (continuous_fst.fst.eval continuous_fst.snd).eval continuous_snd

/-- The family of constant maps: `Y ‚Üí C(X, Y)` as a continuous map. -/
def const' : C(Y, C(X, Y)) :=
  curry ContinuousMap.fst

@[simp]
theorem coe_const' : (const' : Y ‚Üí C(X, Y)) = const X :=
  rfl

theorem continuous_const' : Continuous (const X : Y ‚Üí C(X, Y)) :=
  const'.continuous

end Curry

end CompactOpen

end ContinuousMap

open ContinuousMap

namespace Homeomorph

variable {X : Type*} {Y : Type*} {Z : Type*}
variable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]

/-- Currying as a homeomorphism between the function spaces `C(X √ó Y, Z)` and `C(X, C(Y, Z))`. -/
def curry [LocallyCompactSpace X] [LocallyCompactSpace Y] : C(X √ó Y, Z) ‚âÉ‚Çú C(X, C(Y, Z)) :=
  ‚ü®‚ü®ContinuousMap.curry, uncurry, by intro; ext; rfl, by intro; ext; rfl‚ü©,
    continuous_curry, continuous_uncurry‚ü©

/-- If `X` has a single element, then `Y` is homeomorphic to `C(X, Y)`. -/
def continuousMapOfUnique [Unique X] : Y ‚âÉ‚Çú C(X, Y) where
  toFun := const X
  invFun f := f default
  left_inv _ := rfl
  right_inv f := by
    ext x
    rw [Unique.eq_default x]
    rfl
  continuous_toFun := continuous_const'
  continuous_invFun := continuous_eval_const _

@[simp]
theorem continuousMapOfUnique_apply [Unique X] (y : Y) (x : X) : continuousMapOfUnique y x = y :=
  rfl

@[simp]
theorem continuousMapOfUnique_symm_apply [Unique X] (f : C(X, Y)) :
    continuousMapOfUnique.symm f = f default :=
  rfl

end Homeomorph

section IsQuotientMap

variable {X‚ÇÄ X Y Z : Type*} [TopologicalSpace X‚ÇÄ] [TopologicalSpace X] [TopologicalSpace Y]
  [TopologicalSpace Z] [LocallyCompactSpace Y] {f : X‚ÇÄ ‚Üí X}

theorem Topology.IsQuotientMap.continuous_lift_prod_left (hf : IsQuotientMap f) {g : X √ó Y ‚Üí Z}
    (hg : Continuous fun p : X‚ÇÄ √ó Y => g (f p.1, p.2)) : Continuous g := by
  let Gf : C(X‚ÇÄ, C(Y, Z)) := ContinuousMap.curry ‚ü®_, hg‚ü©
  have h : ‚àÄ x : X, Continuous fun y => g (x, y) := by
    intro x
    obtain ‚ü®x‚ÇÄ, rfl‚ü© := hf.surjective x
    exact (Gf x‚ÇÄ).continuous
  let G : X ‚Üí C(Y, Z) := fun x => ‚ü®_, h x‚ü©
  have : Continuous G := by
    rw [hf.continuous_iff]
    exact Gf.continuous
  exact ContinuousMap.continuous_uncurry_of_continuous ‚ü®G, this‚ü©

@[deprecated (since := "2024-10-22")]
alias QuotientMap.continuous_lift_prod_left := IsQuotientMap.continuous_lift_prod_left

theorem Topology.IsQuotientMap.continuous_lift_prod_right (hf : IsQuotientMap f) {g : Y √ó X ‚Üí Z}
    (hg : Continuous fun p : Y √ó X‚ÇÄ => g (p.1, f p.2)) : Continuous g := by
  have : Continuous fun p : X‚ÇÄ √ó Y => g ((Prod.swap p).1, f (Prod.swap p).2) :=
    hg.comp continuous_swap
  have : Continuous fun p : X‚ÇÄ √ó Y => (g ‚àò Prod.swap) (f p.1, p.2) := this
  exact (hf.continuous_lift_prod_left this).comp continuous_swap

@[deprecated (since := "2024-10-22")]
alias QuotientMap.continuous_lift_prod_right := IsQuotientMap.continuous_lift_prod_right

end IsQuotientMap

-- END Mathlib.Topology.CompactOpen --

-- BEGIN Mathlib.Topology.UnitInterval --
/-
Copyright (c) 2020 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Kim Morrison
-/
import Mathlib.Algebra.Order.Interval.Set.Instances
import Mathlib.Order.Interval.Set.ProjIcc
import Mathlib.Topology.Algebra.Ring.Real

/-!
# The unit interval, as a topological space

Use `open unitInterval` to turn on the notation `I := Set.Icc (0 : ‚Ñù) (1 : ‚Ñù)`.

We provide basic instances, as well as a custom tactic for discharging
`0 ‚â§ ‚Üëx`, `0 ‚â§ 1 - ‚Üëx`, `‚Üëx ‚â§ 1`, and `1 - ‚Üëx ‚â§ 1` when `x : I`.

-/

noncomputable section

open Topology Filter Set Int Set.Icc

/-! ### The unit interval -/


/-- The unit interval `[0,1]` in ‚Ñù. -/
abbrev unitInterval : Set ‚Ñù :=
  Set.Icc 0 1

@[inherit_doc]
scoped[unitInterval] notation "I" => unitInterval

namespace unitInterval

theorem zero_mem : (0 : ‚Ñù) ‚àà I :=
  ‚ü®le_rfl, zero_le_one‚ü©

theorem one_mem : (1 : ‚Ñù) ‚àà I :=
  ‚ü®zero_le_one, le_rfl‚ü©

theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=
  ‚ü®mul_nonneg hx.1 hy.1, mul_le_one‚ÇÄ hx.2 hy.1 hy.2‚ü©

theorem div_mem {x y : ‚Ñù} (hx : 0 ‚â§ x) (hy : 0 ‚â§ y) (hxy : x ‚â§ y) : x / y ‚àà I :=
  ‚ü®div_nonneg hx hy, div_le_one_of_le‚ÇÄ hxy hy‚ü©

theorem fract_mem (x : ‚Ñù) : fract x ‚àà I :=
  ‚ü®fract_nonneg _, (fract_lt_one _).le‚ü©

theorem mem_iff_one_sub_mem {t : ‚Ñù} : t ‚àà I ‚Üî 1 - t ‚àà I := by
  rw [mem_Icc, mem_Icc]
  constructor <;> intro <;> constructor <;> linarith

instance hasZero : Zero I :=
  ‚ü®‚ü®0, zero_mem‚ü©‚ü©

instance hasOne : One I :=
  ‚ü®‚ü®1, by constructor <;> norm_num‚ü©‚ü©

instance : ZeroLEOneClass I := ‚ü®zero_le_one (Œ± := ‚Ñù)‚ü©

instance : CompleteLattice I := have : Fact ((0 : ‚Ñù) ‚â§ 1) := ‚ü®zero_le_one‚ü©; inferInstance

lemma univ_eq_Icc : (univ : Set I) = Icc (0 : I) (1 : I) := Icc_bot_top.symm

@[norm_cast] theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 := coe_eq_zero.not
@[norm_cast] theorem coe_ne_one {x : I} : (x : ‚Ñù) ‚â† 1 ‚Üî x ‚â† 1 := coe_eq_one.not
@[simp, norm_cast] theorem coe_pos {x : I} : (0 : ‚Ñù) < x ‚Üî 0 < x := Iff.rfl
@[simp, norm_cast] theorem coe_lt_one {x : I} : (x : ‚Ñù) < 1 ‚Üî x < 1 := Iff.rfl

instance : Nonempty I :=
  ‚ü®0‚ü©

instance : Mul I :=
  ‚ü®fun x y => ‚ü®x * y, mul_mem x.2 y.2‚ü©‚ü©

theorem mul_le_left {x y : I} : x * y ‚â§ x :=
  Subtype.coe_le_coe.mp <| mul_le_of_le_one_right x.2.1 y.2.2

theorem mul_le_right {x y : I} : x * y ‚â§ y :=
  Subtype.coe_le_coe.mp <| mul_le_of_le_one_left y.2.1 x.2.2

/-- Unit interval central symmetry. -/
def symm : I ‚Üí I := fun t => ‚ü®1 - t, mem_iff_one_sub_mem.mp t.prop‚ü©

@[inherit_doc]
scoped notation "œÉ" => unitInterval.symm

@[simp]
theorem symm_zero : œÉ 0 = 1 :=
  Subtype.ext <| by simp [symm]

@[simp]
theorem symm_one : œÉ 1 = 0 :=
  Subtype.ext <| by simp [symm]

@[simp]
theorem symm_symm (x : I) : œÉ (œÉ x) = x :=
  Subtype.ext <| by simp [symm]

theorem symm_involutive : Function.Involutive (symm : I ‚Üí I) := symm_symm

theorem symm_bijective : Function.Bijective (symm : I ‚Üí I) := symm_involutive.bijective

@[simp]
theorem coe_symm_eq (x : I) : (œÉ x : ‚Ñù) = 1 - x :=
  rfl

@[continuity, fun_prop]
theorem continuous_symm : Continuous œÉ :=
  Continuous.subtype_mk (by fun_prop) _

/-- `unitInterval.symm` as a `Homeomorph`. -/
@[simps]
def symmHomeomorph : I ‚âÉ‚Çú I where
  toFun := symm
  invFun := symm
  left_inv := symm_symm
  right_inv := symm_symm

theorem strictAnti_symm : StrictAnti œÉ := fun _ _ h ‚Ü¶ sub_lt_sub_left (Œ± := ‚Ñù) h _


@[simp]
theorem symm_inj {i j : I} : œÉ i = œÉ j ‚Üî i = j := symm_bijective.injective.eq_iff

theorem half_le_symm_iff (t : I) : 1 / 2 ‚â§ (œÉ t : ‚Ñù) ‚Üî (t : ‚Ñù) ‚â§ 1 / 2 := by
  rw [coe_symm_eq, le_sub_iff_add_le, add_comm, ‚Üê le_sub_iff_add_le, sub_half]

@[simp]
lemma symm_eq_one {i : I} : œÉ i = 1 ‚Üî i = 0 := by
  rw [‚Üê symm_zero, symm_inj]

@[simp]
lemma symm_eq_zero {i : I} : œÉ i = 0 ‚Üî i = 1 := by
  rw [‚Üê symm_one, symm_inj]

@[simp]
theorem symm_le_symm {i j : I} : œÉ i ‚â§ œÉ j ‚Üî j ‚â§ i := by
  simp only [symm, Subtype.mk_le_mk, sub_le_sub_iff, add_le_add_iff_left, Subtype.coe_le_coe]

theorem le_symm_comm {i j : I} : i ‚â§ œÉ j ‚Üî j ‚â§ œÉ i := by
  rw [‚Üê symm_le_symm, symm_symm]

theorem symm_le_comm {i j : I} : œÉ i ‚â§ j ‚Üî œÉ j ‚â§ i := by
  rw [‚Üê symm_le_symm, symm_symm]

@[simp]
theorem symm_lt_symm {i j : I} : œÉ i < œÉ j ‚Üî j < i := by
  simp only [symm, Subtype.mk_lt_mk, sub_lt_sub_iff_left, Subtype.coe_lt_coe]

theorem lt_symm_comm {i j : I} : i < œÉ j ‚Üî j < œÉ i := by
  rw [‚Üê symm_lt_symm, symm_symm]

theorem symm_lt_comm {i j : I} : œÉ i < j ‚Üî œÉ j < i := by
  rw [‚Üê symm_lt_symm, symm_symm]

instance : ConnectedSpace I :=
  Subtype.connectedSpace ‚ü®nonempty_Icc.mpr zero_le_one, isPreconnected_Icc‚ü©

/-- Verify there is an instance for `CompactSpace I`. -/
example : CompactSpace I := by infer_instance

theorem nonneg (x : I) : 0 ‚â§ (x : ‚Ñù) :=
  x.2.1

theorem one_minus_nonneg (x : I) : 0 ‚â§ 1 - (x : ‚Ñù) := by simpa using x.2.2

theorem le_one (x : I) : (x : ‚Ñù) ‚â§ 1 :=
  x.2.2

theorem one_minus_le_one (x : I) : 1 - (x : ‚Ñù) ‚â§ 1 := by simpa using x.2.1

theorem add_pos {t : I} {x : ‚Ñù} (hx : 0 < x) : 0 < (x + t : ‚Ñù) :=
  add_pos_of_pos_of_nonneg hx <| nonneg _

/-- like `unitInterval.nonneg`, but with the inequality in `I`. -/
theorem nonneg' {t : I} : 0 ‚â§ t :=
  t.2.1

/-- like `unitInterval.le_one`, but with the inequality in `I`. -/
theorem le_one' {t : I} : t ‚â§ 1 :=
  t.2.2

protected lemma pos_iff_ne_zero {x : I} : 0 < x ‚Üî x ‚â† 0 := bot_lt_iff_ne_bot

protected lemma lt_one_iff_ne_one {x : I} : x < 1 ‚Üî x ‚â† 1 := lt_top_iff_ne_top

lemma eq_one_or_eq_zero_of_le_mul {i j : I} (h : i ‚â§ j * i) : i = 0 ‚à® j = 1 := by
  contrapose! h
  rw [‚Üê unitInterval.lt_one_iff_ne_one, ‚Üê coe_lt_one, ‚Üê unitInterval.pos_iff_ne_zero,
    ‚Üê coe_pos] at h
  rw [‚Üê Subtype.coe_lt_coe, coe_mul]
  simpa using mul_lt_mul_of_pos_right h.right h.left

instance : Nontrivial I := ‚ü®‚ü®1, 0, (one_ne_zero <| congrArg Subtype.val ¬∑)‚ü©‚ü©

theorem mul_pos_mem_iff {a t : ‚Ñù} (ha : 0 < a) : a * t ‚àà I ‚Üî t ‚àà Set.Icc (0 : ‚Ñù) (1 / a) := by
  constructor <;> rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© <;> constructor
  ¬∑ exact nonneg_of_mul_nonneg_right h‚ÇÅ ha
  ¬∑ rwa [le_div_iff‚ÇÄ ha, mul_comm]
  ¬∑ exact mul_nonneg ha.le h‚ÇÅ
  ¬∑ rwa [le_div_iff‚ÇÄ ha, mul_comm] at h‚ÇÇ

theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 := by
  constructor <;> rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© <;> constructor <;> linarith

/-- The unit interval as a submonoid of ‚Ñù. -/
def submonoid : Submonoid ‚Ñù where
  carrier := unitInterval
  one_mem' := unitInterval.one_mem
  mul_mem' := unitInterval.mul_mem

@[simp] theorem coe_unitIntervalSubmonoid : submonoid = unitInterval := rfl
@[simp] theorem mem_unitIntervalSubmonoid {x} : x ‚àà submonoid ‚Üî x ‚àà unitInterval :=
  Iff.rfl

protected theorem prod_mem {Œπ : Type*} {t : Finset Œπ} {f : Œπ ‚Üí ‚Ñù}
    (h : ‚àÄ c ‚àà t, f c ‚àà unitInterval) :
    ‚àè c ‚àà t, f c ‚àà unitInterval := _root_.prod_mem (S := unitInterval.submonoid) h

instance : LinearOrderedCommMonoidWithZero I where
  zero_mul i := zero_mul i
  mul_zero i := mul_zero i
  zero_le_one := nonneg'
  mul_le_mul_left i j h_ij k := by
    simp only [‚Üê Subtype.coe_le_coe, coe_mul]
    apply mul_le_mul le_rfl ?_ (nonneg i) (nonneg k)
    simp [h_ij]

end unitInterval

section partition

namespace Set.Icc

variable {Œ±} [AddCommGroup Œ±] [LinearOrder Œ±] [IsOrderedAddMonoid Œ±]
  {a b c d : Œ±} (h : a ‚â§ b) {Œ¥ : Œ±}

-- TODO: Set.projIci, Set.projIic
/-- `Set.projIcc` is a contraction. -/
lemma _root_.Set.abs_projIcc_sub_projIcc : (|projIcc a b h c - projIcc a b h d| : Œ±) ‚â§ |c - d| := by
  wlog hdc : d ‚â§ c generalizing c d
  ¬∑ rw [abs_sub_comm, abs_sub_comm c]; exact this (le_of_not_le hdc)
  rw [abs_eq_self.2 (sub_nonneg.2 hdc),
    abs_eq_self.2 (sub_nonneg.2 <| mod_cast monotone_projIcc h hdc)]
  rw [‚Üê sub_nonneg] at hdc
  refine (max_sub_max_le_max _ _ _ _).trans (max_le (by rwa [sub_self]) ?_)
  refine ((le_abs_self _).trans <| abs_min_sub_min_le_max _ _ _ _).trans (max_le ?_ ?_)
  ¬∑ rwa [sub_self, abs_zero]
  ¬∑ exact (abs_eq_self.mpr hdc).le

/-- When `h : a ‚â§ b` and `Œ¥ > 0`, `addNSMul h Œ¥` is a sequence of points in the closed interval
`[a,b]`, which is initially equally spaced but eventually stays at the right endpoint `b`. -/
def addNSMul (Œ¥ : Œ±) (n : ‚Ñï) : Icc a b := projIcc a b h (a + n ‚Ä¢ Œ¥)

omit [IsOrderedAddMonoid Œ±] in
lemma addNSMul_zero : addNSMul h Œ¥ 0 = a := by
  rw [addNSMul, zero_smul, add_zero, projIcc_left]

lemma addNSMul_eq_right [Archimedean Œ±] (hŒ¥ : 0 < Œ¥) :
    ‚àÉ m, ‚àÄ n ‚â• m, addNSMul h Œ¥ n = b := by
  obtain ‚ü®m, hm‚ü© := Archimedean.arch (b - a) hŒ¥
  refine ‚ü®m, fun n hn ‚Ü¶ ?_‚ü©
  rw [addNSMul, coe_projIcc, add_comm, min_eq_left_iff.mpr, max_eq_right h]
  exact sub_le_iff_le_add.mp (hm.trans <| nsmul_le_nsmul_left hŒ¥.le hn)

lemma monotone_addNSMul (hŒ¥ : 0 ‚â§ Œ¥) : Monotone (addNSMul h Œ¥) :=
  fun _ _ hnm ‚Ü¶ monotone_projIcc h <| (add_le_add_iff_left _).mpr (nsmul_le_nsmul_left hŒ¥ hnm)

lemma abs_sub_addNSMul_le (hŒ¥ : 0 ‚â§ Œ¥) {t : Icc a b} (n : ‚Ñï)
    (ht : t ‚àà Icc (addNSMul h Œ¥ n) (addNSMul h Œ¥ (n+1))) :
    (|t - addNSMul h Œ¥ n| : Œ±) ‚â§ Œ¥ :=
  calc
    (|t - addNSMul h Œ¥ n| : Œ±) = t - addNSMul h Œ¥ n            := abs_eq_self.2 <| sub_nonneg.2 ht.1
    _ ‚â§ projIcc a b h (a + (n+1) ‚Ä¢ Œ¥) - addNSMul h Œ¥ n := by apply sub_le_sub_right; exact ht.2
    _ ‚â§ (|projIcc a b h (a + (n+1) ‚Ä¢ Œ¥) - addNSMul h Œ¥ n| : Œ±) := le_abs_self _
    _ ‚â§ |a + (n+1) ‚Ä¢ Œ¥ - (a + n ‚Ä¢ Œ¥)|                          := abs_projIcc_sub_projIcc h
    _ ‚â§ Œ¥ := by
          rw [add_sub_add_comm, sub_self, zero_add, succ_nsmul', add_sub_cancel_right]
          exact (abs_eq_self.mpr hŒ¥).le

end Set.Icc

open scoped unitInterval

/-- Any open cover `c` of a closed interval `[a, b]` in ‚Ñù
can be refined to a finite partition into subintervals. -/
lemma exists_monotone_Icc_subset_open_cover_Icc {Œπ} {a b : ‚Ñù} (h : a ‚â§ b) {c : Œπ ‚Üí Set (Icc a b)}
    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i)) (hc‚ÇÇ : univ ‚äÜ ‚ãÉ i, c i) : ‚àÉ t : ‚Ñï ‚Üí Icc a b, t 0 = a ‚àß
      Monotone t ‚àß (‚àÉ m, ‚àÄ n ‚â• m, t n = b) ‚àß ‚àÄ n, ‚àÉ i, Icc (t n) (t (n + 1)) ‚äÜ c i := by
  obtain ‚ü®Œ¥, Œ¥_pos, ball_subset‚ü© := lebesgue_number_lemma_of_metric isCompact_univ hc‚ÇÅ hc‚ÇÇ
  have hŒ¥ := half_pos Œ¥_pos
  refine ‚ü®addNSMul h (Œ¥/2), addNSMul_zero h,
    monotone_addNSMul h hŒ¥.le, addNSMul_eq_right h hŒ¥, fun n ‚Ü¶ ?_‚ü©
  obtain ‚ü®i, hsub‚ü© := ball_subset (addNSMul h (Œ¥/2) n) trivial
  exact ‚ü®i, fun t ht ‚Ü¶ hsub ((abs_sub_addNSMul_le h hŒ¥.le n ht).trans_lt <| half_lt_self Œ¥_pos)‚ü©

/-- Any open cover of the unit interval can be refined to a finite partition into subintervals. -/
lemma exists_monotone_Icc_subset_open_cover_unitInterval {Œπ} {c : Œπ ‚Üí Set I}
    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i)) (hc‚ÇÇ : univ ‚äÜ ‚ãÉ i, c i) : ‚àÉ t : ‚Ñï ‚Üí I, t 0 = 0 ‚àß
      Monotone t ‚àß (‚àÉ n, ‚àÄ m ‚â• n, t m = 1) ‚àß ‚àÄ n, ‚àÉ i, Icc (t n) (t (n + 1)) ‚äÜ c i := by
  simp_rw [‚Üê Subtype.coe_inj]
  exact exists_monotone_Icc_subset_open_cover_Icc zero_le_one hc‚ÇÅ hc‚ÇÇ

lemma exists_monotone_Icc_subset_open_cover_unitInterval_prod_self {Œπ} {c : Œπ ‚Üí Set (I √ó I)}
    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i)) (hc‚ÇÇ : univ ‚äÜ ‚ãÉ i, c i) :
    ‚àÉ t : ‚Ñï ‚Üí I, t 0 = 0 ‚àß Monotone t ‚àß (‚àÉ n, ‚àÄ m ‚â• n, t m = 1) ‚àß
      ‚àÄ n m, ‚àÉ i, Icc (t n) (t (n + 1)) √óÀ¢ Icc (t m) (t (m + 1)) ‚äÜ c i := by
  obtain ‚ü®Œ¥, Œ¥_pos, ball_subset‚ü© := lebesgue_number_lemma_of_metric isCompact_univ hc‚ÇÅ hc‚ÇÇ
  have hŒ¥ := half_pos Œ¥_pos
  simp_rw [Subtype.ext_iff]
  have h : (0 : ‚Ñù) ‚â§ 1 := zero_le_one
  refine ‚ü®addNSMul h (Œ¥/2), addNSMul_zero h,
    monotone_addNSMul h hŒ¥.le, addNSMul_eq_right h hŒ¥, fun n m ‚Ü¶ ?_‚ü©
  obtain ‚ü®i, hsub‚ü© := ball_subset (addNSMul h (Œ¥/2) n, addNSMul h (Œ¥/2) m) trivial
  exact ‚ü®i, fun t ht ‚Ü¶ hsub (Metric.mem_ball.mpr <| (max_le (abs_sub_addNSMul_le h hŒ¥.le n ht.1) <|
    abs_sub_addNSMul_le h hŒ¥.le m ht.2).trans_lt <| half_lt_self Œ¥_pos)‚ü©

end partition

@[simp]
theorem projIcc_eq_zero {x : ‚Ñù} : projIcc (0 : ‚Ñù) 1 zero_le_one x = 0 ‚Üî x ‚â§ 0 :=
  projIcc_eq_left zero_lt_one

@[simp]
theorem projIcc_eq_one {x : ‚Ñù} : projIcc (0 : ‚Ñù) 1 zero_le_one x = 1 ‚Üî 1 ‚â§ x :=
  projIcc_eq_right zero_lt_one

namespace Tactic.Interactive

/-- A tactic that solves `0 ‚â§ ‚Üëx`, `0 ‚â§ 1 - ‚Üëx`, `‚Üëx ‚â§ 1`, and `1 - ‚Üëx ‚â§ 1` for `x : I`. -/
macro "unit_interval" : tactic =>
  `(tactic| (first
  | apply unitInterval.nonneg
  | apply unitInterval.one_minus_nonneg
  | apply unitInterval.le_one
  | apply unitInterval.one_minus_le_one))

example (x : unitInterval) : 0 ‚â§ (x : ‚Ñù) := by unit_interval

end Tactic.Interactive

section

variable {ùïú : Type*} [Field ùïú] [LinearOrder ùïú] [IsStrictOrderedRing ùïú]
  [TopologicalSpace ùïú] [IsTopologicalRing ùïú]

-- We only need the ordering on `ùïú` here to avoid talking about flipping the interval over.
-- At the end of the day I only care about `‚Ñù`, so I'm hesitant to put work into generalizing.
/-- The image of `[0,1]` under the homeomorphism `fun x ‚Ü¶ a * x + b` is `[b, a+b]`.
-/
theorem affineHomeomorph_image_I (a b : ùïú) (h : 0 < a) :
    affineHomeomorph a b h.ne.symm '' Set.Icc 0 1 = Set.Icc b (a + b) := by simp [h]

/-- The affine homeomorphism from a nontrivial interval `[a,b]` to `[0,1]`.
-/
def iccHomeoI (a b : ùïú) (h : a < b) : Set.Icc a b ‚âÉ‚Çú Set.Icc (0 : ùïú) (1 : ùïú) := by
  let e := Homeomorph.image (affineHomeomorph (b - a) a (sub_pos.mpr h).ne.symm) (Set.Icc 0 1)
  refine (e.trans ?_).symm
  apply Homeomorph.setCongr
  rw [affineHomeomorph_image_I _ _ (sub_pos.2 h)]
  simp

@[simp]
theorem iccHomeoI_apply_coe (a b : ùïú) (h : a < b) (x : Set.Icc a b) :
    ((iccHomeoI a b h) x : ùïú) = (x - a) / (b - a) :=
  rfl

@[simp]
theorem iccHomeoI_symm_apply_coe (a b : ùïú) (h : a < b) (x : Set.Icc (0 : ùïú) (1 : ùïú)) :
    ((iccHomeoI a b h).symm x : ùïú) = (b - a) * x + a :=
  rfl

end

section NNReal

open unitInterval NNReal

/-- The coercion from `I` to `‚Ñù‚â•0`. -/
def unitInterval.toNNReal : I ‚Üí ‚Ñù‚â•0 := fun i ‚Ü¶ ‚ü®i.1, i.2.1‚ü©

@[fun_prop]
lemma unitInterval.toNNReal_continuous : Continuous toNNReal := by
  delta toNNReal
  fun_prop

@[simp]
lemma unitInterval.coe_toNNReal (x : I) : ((toNNReal x) : ‚Ñù) = x := rfl

end NNReal

-- END Mathlib.Topology.UnitInterval --

import Mathlib.Topology.Path

/-!
# Path connectedness

Continuing from `Mathlib.Topology.Path`, this file defines path components and path-connected
spaces.

## Main definitions

In the file the unit interval `[0, 1]` in `‚Ñù` is denoted by `I`, and `X` is a topological space.

* `Joined (x y : X)` means there is a path between `x` and `y`.
* `Joined.somePath (h : Joined x y)` selects some path between two points `x` and `y`.
* `pathComponent (x : X)` is the set of points joined to `x`.
* `PathConnectedSpace X` is a predicate class asserting that `X` is non-empty and every two
  points of `X` are joined.

Then there are corresponding relative notions for `F : Set X`.

* `JoinedIn F (x y : X)` means there is a path `Œ≥` joining `x` to `y` with values in `F`.
* `JoinedIn.somePath (h : JoinedIn F x y)` selects a path from `x` to `y` inside `F`.
* `pathComponentIn F (x : X)` is the set of points joined to `x` in `F`.
* `IsPathConnected F` asserts that `F` is non-empty and every two
  points of `F` are joined in `F`.

## Main theorems

* `Joined` is an equivalence relation, while `JoinedIn F` is at least symmetric and transitive.

One can link the absolute and relative version in two directions, using `(univ : Set X)` or the
subtype `‚Ü•F`.

* `pathConnectedSpace_iff_univ : PathConnectedSpace X ‚Üî IsPathConnected (univ : Set X)`
* `isPathConnected_iff_pathConnectedSpace : IsPathConnected F ‚Üî PathConnectedSpace ‚Ü•F`

Furthermore, it is shown that continuous images and quotients of path-connected sets/spaces are
path-connected, and that every path-connected set/space is also connected.
-/

noncomputable section

open Topology Filter unitInterval Set Function

variable {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {Œπ : Type*}

/-! ### Being joined by a path -/


/-- The relation "being joined by a path". This is an equivalence relation. -/
def Joined (x y : X) : Prop :=
  Nonempty (Path x y)

@[refl]
theorem Joined.refl (x : X) : Joined x x :=
  ‚ü®Path.refl x‚ü©

/-- When two points are joined, choose some path from `x` to `y`. -/
def Joined.somePath (h : Joined x y) : Path x y :=
  Nonempty.some h

@[symm]
theorem Joined.symm {x y : X} (h : Joined x y) : Joined y x :=
  ‚ü®h.somePath.symm‚ü©

@[trans]
theorem Joined.trans {x y z : X} (hxy : Joined x y) (hyz : Joined y z) : Joined x z :=
  ‚ü®hxy.somePath.trans hyz.somePath‚ü©

variable (X)

/-- The setoid corresponding the equivalence relation of being joined by a continuous path. -/
def pathSetoid : Setoid X where
  r := Joined
  iseqv := Equivalence.mk Joined.refl Joined.symm Joined.trans

/-- The quotient type of points of a topological space modulo being joined by a continuous path. -/
def ZerothHomotopy :=
  Quotient (pathSetoid X)

instance ZerothHomotopy.inhabited : Inhabited (ZerothHomotopy ‚Ñù) :=
  ‚ü®@Quotient.mk' ‚Ñù (pathSetoid ‚Ñù) 0‚ü©

variable {X}

/-! ### Being joined by a path inside a set -/


/-- The relation "being joined by a path in `F`". Not quite an equivalence relation since it's not
reflexive for points that do not belong to `F`. -/
def JoinedIn (F : Set X) (x y : X) : Prop :=
  ‚àÉ Œ≥ : Path x y, ‚àÄ t, Œ≥ t ‚àà F

variable {F : Set X}

theorem JoinedIn.mem (h : JoinedIn F x y) : x ‚àà F ‚àß y ‚àà F := by

