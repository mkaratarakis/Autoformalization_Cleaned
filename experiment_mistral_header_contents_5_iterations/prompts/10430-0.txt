
1. **Informal Theorem**  
Logarithmic Derivative of Integer Power: \(\logDeriv (x^n) = \frac{n}{x}\) : For any element \( x \) in a nontrivially normed field \( \mathbb{ğ•œ} \) and any integer \( n \), the logarithmic derivative of the function \( f(x) = x^n \) at \( x \) is given by \( \frac{n}{x} \). Formally, this can be written as:
\[
\logDeriv (x^n) = \frac{n}{x}.
\]

2. **Informal Proof**  
To prove the theorem, we start by using the theorem that the logarithmic derivative of \( f(x)^n \) is \( n \cdot \logDeriv f(x) \). Specifically, for the function \( f(x) = x \), we have:
\[
\logDeriv (x^n) = n \cdot \logDeriv (x).
\]
Next, we use the theorem that the logarithmic derivative of the identity function \( f(x) = x \) is \( \frac{1}{x} \), so:
\[
\logDeriv (x) = \frac{1}{x}.
\]
Substituting this into our previous equation, we get:
\[
\logDeriv (x^n) = n \cdot \frac{1}{x} = \frac{n}{x}.
\]
Thus, the logarithmic derivative of \( x^n \) at \( x \) is indeed \( \frac{n}{x} \). This completes the proof. \(\blacksquare\)

3. **Formal Theorem**  
example (x : ğ•œ) (n : â„¤) : logDeriv (Â· ^ n) x = n / x := by sorry

4. **Prefix**
import Mathlib.Analysis.Calculus.Deriv.ZPow
import Mathlib.Analysis.Calculus.LogDeriv


open Filter Function
open scoped Topology BigOperators Classical
variable {ğ•œ ğ•œ': Type*} [NontriviallyNormedField ğ•œ] [NontriviallyNormedField ğ•œ']
  [NormedAlgebra ğ•œ ğ•œ']

example (x : ğ•œ) (n : â„¤) : logDeriv (Â· ^ n) x = n / x := by

5. **Header Information**  
-- BEGIN Mathlib.Analysis.Calculus.Deriv.ZPow --
/-
Copyright (c) 2020 SÃ©bastien GouÃ«zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SÃ©bastien GouÃ«zel, Yury Kudryashov
-/
import Mathlib.Analysis.Calculus.Deriv.Pow
import Mathlib.Analysis.Calculus.Deriv.Inv

/-!
# Derivatives of `x ^ m`, `m : â„¤`

In this file we prove theorems about (iterated) derivatives of `x ^ m`, `m : â„¤`.

For a more detailed overview of one-dimensional derivatives in mathlib, see the module docstring of
`analysis/calculus/deriv/basic`.

## Keywords

derivative, power
-/

universe u v w

open Topology Filter Asymptotics Set

variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {E : Type v} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {x : ğ•œ}
variable {s : Set ğ•œ}
variable {m : â„¤}

/-! ### Derivative of `x â†¦ x^m` for `m : â„¤` -/

theorem hasStrictDerivAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :
    HasStrictDerivAt (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) x := by
  have : âˆ€ m : â„¤, 0 < m â†’ HasStrictDerivAt (Â· ^ m) ((m : ğ•œ) * x ^ (m - 1)) x := fun m hm â†¦ by
    lift m to â„• using hm.le
    simp only [zpow_natCast, Int.cast_natCast]
    convert hasStrictDerivAt_pow m x using 2
    rw [â† Int.ofNat_one, â† Int.ofNat_sub, zpow_natCast]
    norm_cast at hm
  rcases lt_trichotomy m 0 with (hm | hm | hm)
  Â· have hx : x â‰  0 := h.resolve_right hm.not_le
    have := (hasStrictDerivAt_inv ?_).scomp _ (this (-m) (neg_pos.2 hm)) <;>
      [skip; exact zpow_ne_zero _ hx]
    simp only [Function.comp_def, zpow_neg, one_div, inv_inv, smul_eq_mul] at this
    convert this using 1
    rw [sq, mul_inv, inv_inv, Int.cast_neg, neg_mul, neg_mul_neg, â† zpow_addâ‚€ hx, mul_assoc, â†
      zpow_addâ‚€ hx]
    congr
    abel
  Â· simp only [hm, zpow_zero, Int.cast_zero, zero_mul, hasStrictDerivAt_const]
  Â· exact this m hm

theorem hasDerivAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :
    HasDerivAt (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) x :=
  (hasStrictDerivAt_zpow m x h).hasDerivAt

theorem hasDerivWithinAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) (s : Set ğ•œ) :
    HasDerivWithinAt (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) s x :=
  (hasDerivAt_zpow m x h).hasDerivWithinAt

theorem differentiableAt_zpow : DifferentiableAt ğ•œ (fun x => x ^ m) x â†” x â‰  0 âˆ¨ 0 â‰¤ m :=
  âŸ¨fun H => NormedField.continuousAt_zpow.1 H.continuousAt, fun H =>
    (hasDerivAt_zpow m x H).differentiableAtâŸ©

theorem differentiableWithinAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :
    DifferentiableWithinAt ğ•œ (fun x => x ^ m) s x :=
  (differentiableAt_zpow.mpr h).differentiableWithinAt

theorem differentiableOn_zpow (m : â„¤) (s : Set ğ•œ) (h : (0 : ğ•œ) âˆ‰ s âˆ¨ 0 â‰¤ m) :
    DifferentiableOn ğ•œ (fun x => x ^ m) s := fun x hxs =>
  differentiableWithinAt_zpow m x <| h.imp_left <| ne_of_mem_of_not_mem hxs

theorem deriv_zpow (m : â„¤) (x : ğ•œ) : deriv (fun x => x ^ m) x = m * x ^ (m - 1) := by
  by_cases H : x â‰  0 âˆ¨ 0 â‰¤ m
  Â· exact (hasDerivAt_zpow m x H).deriv
  Â· rw [deriv_zero_of_not_differentiableAt (mt differentiableAt_zpow.1 H)]
    push_neg at H
    rcases H with âŸ¨rfl, hmâŸ©
    rw [zero_zpow _ ((sub_one_lt _).trans hm).ne, mul_zero]

@[simp]
theorem deriv_zpow' (m : â„¤) : (deriv fun x : ğ•œ => x ^ m) = fun x => (m : ğ•œ) * x ^ (m - 1) :=
  funext <| deriv_zpow m

theorem derivWithin_zpow (hxs : UniqueDiffWithinAt ğ•œ s x) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :
    derivWithin (fun x => x ^ m) s x = (m : ğ•œ) * x ^ (m - 1) :=
  (hasDerivWithinAt_zpow m x h s).derivWithin hxs

@[simp]
theorem iter_deriv_zpow' (m : â„¤) (k : â„•) :
    (deriv^[k] fun x : ğ•œ => x ^ m) =
      fun x => (âˆ i âˆˆ Finset.range k, ((m : ğ•œ) - i)) * x ^ (m - k) := by
  induction' k with k ihk
  Â· simp only [one_mul, Int.ofNat_zero, id, sub_zero, Finset.prod_range_zero,
      Function.iterate_zero]
  Â· simp only [Function.iterate_succ_apply', ihk, deriv_const_mul_field', deriv_zpow',
      Finset.prod_range_succ, Int.ofNat_succ, â† sub_sub, Int.cast_sub, Int.cast_natCast, mul_assoc]

theorem iter_deriv_zpow (m : â„¤) (x : ğ•œ) (k : â„•) :
    deriv^[k] (fun y => y ^ m) x = (âˆ i âˆˆ Finset.range k, ((m : ğ•œ) - i)) * x ^ (m - k) :=
  congr_fun (iter_deriv_zpow' m k) x

theorem iter_deriv_pow (n : â„•) (x : ğ•œ) (k : â„•) :
    deriv^[k] (fun x : ğ•œ => x ^ n) x = (âˆ i âˆˆ Finset.range k, ((n : ğ•œ) - i)) * x ^ (n - k) := by
  simp only [â† zpow_natCast, iter_deriv_zpow, Int.cast_natCast]
  rcases le_or_lt k n with hkn | hnk
  Â· rw [Int.ofNat_sub hkn]
  Â· have : (âˆ i âˆˆ Finset.range k, (n - i : ğ•œ)) = 0 :=
      Finset.prod_eq_zero (Finset.mem_range.2 hnk) (sub_self _)
    simp only [this, zero_mul]

@[simp]
theorem iter_deriv_pow' (n k : â„•) :
    (deriv^[k] fun x : ğ•œ => x ^ n) =
      fun x => (âˆ i âˆˆ Finset.range k, ((n : ğ•œ) - i)) * x ^ (n - k) :=
  funext fun x => iter_deriv_pow n x k

theorem iter_deriv_inv (k : â„•) (x : ğ•œ) :
    deriv^[k] Inv.inv x = (âˆ i âˆˆ Finset.range k, (-1 - i : ğ•œ)) * x ^ (-1 - k : â„¤) := by
  simpa only [zpow_neg_one, Int.cast_neg, Int.cast_one] using iter_deriv_zpow (-1) x k

@[simp]
theorem iter_deriv_inv' (k : â„•) :
    deriv^[k] Inv.inv = fun x : ğ•œ => (âˆ i âˆˆ Finset.range k, (-1 - i : ğ•œ)) * x ^ (-1 - k : â„¤) :=
  funext (iter_deriv_inv k)

variable {f : E â†’ ğ•œ} {t : Set E} {a : E}

theorem DifferentiableWithinAt.zpow (hf : DifferentiableWithinAt ğ•œ f t a) (h : f a â‰  0 âˆ¨ 0 â‰¤ m) :
    DifferentiableWithinAt ğ•œ (fun x => f x ^ m) t a :=
  (differentiableAt_zpow.2 h).comp_differentiableWithinAt a hf

theorem DifferentiableAt.zpow (hf : DifferentiableAt ğ•œ f a) (h : f a â‰  0 âˆ¨ 0 â‰¤ m) :
    DifferentiableAt ğ•œ (fun x => f x ^ m) a :=
  (differentiableAt_zpow.2 h).comp a hf

theorem DifferentiableOn.zpow (hf : DifferentiableOn ğ•œ f t) (h : (âˆ€ x âˆˆ t, f x â‰  0) âˆ¨ 0 â‰¤ m) :
    DifferentiableOn ğ•œ (fun x => f x ^ m) t := fun x hx =>
  (hf x hx).zpow <| h.imp_left fun h => h x hx

theorem Differentiable.zpow (hf : Differentiable ğ•œ f) (h : (âˆ€ x, f x â‰  0) âˆ¨ 0 â‰¤ m) :
    Differentiable ğ•œ fun x => f x ^ m := fun x => (hf x).zpow <| h.imp_left fun h => h x

-- END Mathlib.Analysis.Calculus.Deriv.ZPow --

import Mathlib.Analysis.Calculus.Deriv.ZPow

/-!
# Logarithmic Derivatives

We define the logarithmic derivative of a function f as `deriv f / f`. We then prove some basic
facts about this, including how it changes under multiplication and composition.

-/

noncomputable section

open Filter Function

open scoped Topology

variable {ğ•œ ğ•œ' : Type*} [NontriviallyNormedField ğ•œ] [NontriviallyNormedField ğ•œ']
  [NormedAlgebra ğ•œ ğ•œ']

/-- The logarithmic derivative of a function defined as `deriv f /f`. Note that it will be zero
at `x` if `f` is not DifferentiableAt `x`. -/
def logDeriv (f : ğ•œ â†’ ğ•œ') :=
  deriv f / f

theorem logDeriv_apply (f : ğ•œ â†’ ğ•œ') (x : ğ•œ) : logDeriv f x = deriv f x / f x := rfl

lemma logDeriv_eq_zero_of_not_differentiableAt (f : ğ•œ â†’ ğ•œ') (x : ğ•œ) (h : Â¬DifferentiableAt ğ•œ f x) :
    logDeriv f x = 0 := by
  simp only [logDeriv_apply, deriv_zero_of_not_differentiableAt h, zero_div]

@[simp]
theorem logDeriv_id (x : ğ•œ) : logDeriv id x = 1 / x := by
  simp [logDeriv_apply]

@[simp] theorem logDeriv_id' (x : ğ•œ) : logDeriv (Â·) x = 1 / x := logDeriv_id x

@[simp]
theorem logDeriv_const (a : ğ•œ') : logDeriv (fun _ : ğ•œ â†¦ a) = 0 := by
  ext
  simp [logDeriv_apply]

theorem logDeriv_mul {f g : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (hf : f x â‰  0) (hg : g x â‰  0)
    (hdf : DifferentiableAt ğ•œ f x) (hdg : DifferentiableAt ğ•œ g x) :
      logDeriv (fun z => f z * g z) x = logDeriv f x + logDeriv g x := by
  simp only [logDeriv_apply, deriv_mul hdf hdg]
  field_simp [mul_comm]

theorem logDeriv_div {f g : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (hf : f x â‰  0) (hg : g x â‰  0)
    (hdf : DifferentiableAt ğ•œ f x) (hdg : DifferentiableAt ğ•œ g x) :
    logDeriv (fun z => f z / g z) x = logDeriv f x - logDeriv g x := by
  simp only [logDeriv_apply, deriv_div hdf hdg]
  field_simp [mul_comm]
  ring

theorem logDeriv_mul_const {f : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (a : ğ•œ') (ha : a â‰  0):
    logDeriv (fun z => f z * a) x = logDeriv f x := by
  simp only [logDeriv_apply, deriv_mul_const_field, mul_div_mul_right _ _ ha]

theorem logDeriv_const_mul {f : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (a : ğ•œ') (ha : a â‰  0):
    logDeriv (fun z => a * f z) x = logDeriv f x := by
  simp only [logDeriv_apply, deriv_const_mul_field, mul_div_mul_left _ _ ha]

/-- The logarithmic derivative of a finite product is the sum of the logarithmic derivatives. -/
theorem logDeriv_prod {Î¹ : Type*} (s : Finset Î¹) (f : Î¹ â†’ ğ•œ â†’ ğ•œ') (x : ğ•œ) (hf : âˆ€ i âˆˆ s, f i x â‰  0)
    (hd : âˆ€ i âˆˆ s, DifferentiableAt ğ•œ (f i) x) :
    logDeriv (âˆ i âˆˆ s, f i Â·) x = âˆ‘ i âˆˆ s, logDeriv (f i) x := by
  induction s using Finset.cons_induction with
  | empty => simp
  | cons a s ha ih =>
    rw [Finset.forall_mem_cons] at hf hd
    simp_rw [Finset.prod_cons, Finset.sum_cons]
    rw [logDeriv_mul, ih hf.2 hd.2]
    Â· exact hf.1
    Â· simpa [Finset.prod_eq_zero_iff] using hf.2
    Â· exact hd.1
    Â· exact .finset_prod hd.2

lemma logDeriv_fun_zpow {f : ğ•œ â†’ ğ•œ'} {x : ğ•œ} (hdf : DifferentiableAt ğ•œ f x) (n : â„¤) :
    logDeriv (f Â· ^ n) x = n * logDeriv f x := by
  rcases eq_or_ne n 0 with rfl | hn; Â· simp
  rcases eq_or_ne (f x) 0 with hf | hf
  Â· simp [logDeriv_apply, zero_zpow, *]
  Â· rw [logDeriv_apply, â† comp_def (Â·^n), deriv_comp _ (differentiableAt_zpow.2 <| .inl hf) hdf,
      deriv_zpow, logDeriv_apply]
    field_simp [zpow_ne_zero, zpow_sub_oneâ‚€ hf]
    ring

lemma logDeriv_fun_pow {f : ğ•œ â†’ ğ•œ'} {x : ğ•œ} (hdf : DifferentiableAt ğ•œ f x) (n : â„•) :
    logDeriv (f Â· ^ n) x = n * logDeriv f x :=
  mod_cast logDeriv_fun_zpow hdf n

@[simp]
lemma logDeriv_zpow (x : ğ•œ) (n : â„¤) : logDeriv (Â· ^ n) x = n / x := by

