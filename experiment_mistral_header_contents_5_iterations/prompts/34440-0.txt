
1. **Informal Theorem**  
Induced Map on Sections of Free Sheaves of Modules Preserves Tautological Sections : For any types \( I \) and \( J \), and a function \( f : I \to J \), the induced map on sections of the free sheaves of modules \( \text{SheafOfModules.sectionsMap}(\text{SheafOfModules.freeMap } f) \) maps the tautological section of \( \text{free } I \) corresponding to an element \( i \in I \) to the tautological section of \( \text{free } J \) corresponding to the element \( f(i) \in J \). Formally, this is expressed as:
\[
\text{SheafOfModules.sectionsMap}(\text{SheafOfModules.freeMap } f)(\text{SheafOfModules.freeSection } i) = \text{SheafOfModules.freeSection } (f(i))
\]

2. **Informal Proof**  
To prove the theorem, we use the equivalence that the composition of the free homomorphism and the application of the free section is the same as the free section of the image. Specifically, we have:
\[
\text{SheafOfModules.sectionsMap}(\text{SheafOfModules.freeMap } f)(\text{SheafOfModules.freeSection } i) = \text{SheafOfModules.freeSection } (f(i))
\]
This equivalence allows us to simplify the proposition we want to show to the desired equality. Therefore, the induced map on sections of the free sheaves of modules \( \text{SheafOfModules.sectionsMap}(\text{SheafOfModules.freeMap } f) \) maps the tautological section of \( \text{free } I \) corresponding to an element \( i \in I \) to the tautological section of \( \text{free } J \) corresponding to the element \( f(i) \in J \). This completes the proof.

3. **Formal Theorem**  
example (i : I) :
    sectionsMap (freeMap (R := R) f) (freeSection i) = freeSection (f i) := by sorry

4. **Prefix**
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Colimits
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Free

open SheafOfModules
open CategoryTheory Limits
variable {C : Type u'} [Category.{v'} C] {J : GrothendieckTopology C} {R : Sheaf J RingCat.{u}}
  [HasWeakSheafify J AddCommGrp.{u}] [J.WEqualsLocallyBijective AddCommGrp.{u}]
  [J.HasSheafCompose (forget‚ÇÇ RingCat.{u} AddCommGrp.{u})]
variable {I J : Type u} (f : I ‚Üí J)

example (i : I) :
    sectionsMap (freeMap (R := R) f) (freeSection i) = freeSection (f i) := by

5. **Header Information**  
-- BEGIN Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits --
/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.Algebra.Category.ModuleCat.Presheaf
import Mathlib.Algebra.Category.ModuleCat.Colimits

/-! # Colimits in categories of presheaves of modules

In this file, it is shown that under suitable assumptions,
colimits exist in the category `PresheafOfModules R`.

-/

universe v v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ u u'

open CategoryTheory Category Limits

namespace PresheafOfModules

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {R : C·µí·µñ ‚•§ RingCat.{u}}
  {J : Type u‚ÇÇ} [Category.{v‚ÇÇ} J]
  (F : J ‚•§ PresheafOfModules.{v} R)

section Colimits

variable [‚àÄ {X Y : C·µí·µñ} (f : X ‚ü∂ Y), PreservesColimit (F ‚ãô evaluation R Y)
  (ModuleCat.restrictScalars (R.map f).hom)]

/-- A cocone in the category `PresheafOfModules R` is colimit if it is so after the application
of the functors `evaluation R X` for all `X`. -/
def evaluationJointlyReflectsColimits (c : Cocone F)
    (hc : ‚àÄ (X : C·µí·µñ), IsColimit ((evaluation R X).mapCocone c)) : IsColimit c where
  desc s :=
    { app := fun X => (hc X).desc ((evaluation R X).mapCocone s)
      naturality := fun {X Y} f ‚Ü¶ (hc X).hom_ext (fun j ‚Ü¶ by
        rw [(hc X).fac_assoc ((evaluation R X).mapCocone s) j]
        have h‚ÇÅ := (c.Œπ.app j).naturality f
        have h‚ÇÇ := (hc Y).fac ((evaluation R Y).mapCocone s)
        dsimp at h‚ÇÅ h‚ÇÇ ‚ä¢
        simp only [‚Üê reassoc_of% h‚ÇÅ, ‚Üê Functor.map_comp, h‚ÇÇ, Hom.naturality]) }
  fac s j := by
    ext1 X
    exact (hc X).fac ((evaluation R X).mapCocone s) j
  uniq s m hm := by
    ext1 X
    apply (hc X).uniq ((evaluation R X).mapCocone s)
    intro j
    dsimp
    rw [‚Üê hm]
    rfl

variable [‚àÄ X, HasColimit (F ‚ãô evaluation R X)]

instance {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :
    HasColimit (F ‚ãô evaluation R Y ‚ãô (ModuleCat.restrictScalars (R.map f).hom)) :=
  ‚ü®_, isColimitOfPreserves (ModuleCat.restrictScalars (R.map f).hom)
    (colimit.isColimit (F ‚ãô evaluation R Y))‚ü©

/-- Given `F : J ‚•§ PresheafOfModules.{v} R`, this is the presheaf of modules obtained by
taking a colimit in the category of modules over `R.obj X` for all `X`. -/
@[simps]
noncomputable def colimitPresheafOfModules : PresheafOfModules R where
  obj X := colimit (F ‚ãô evaluation R X)
  map {_ Y} f := colimMap (whiskerLeft F (restriction R f)) ‚â´
    (preservesColimitIso (ModuleCat.restrictScalars (R.map f).hom) (F ‚ãô evaluation R Y)).inv
  map_id X := colimit.hom_ext (fun j => by
    dsimp
    rw [Œπ_colimMap_assoc, whiskerLeft_app, restriction_app]
    -- Here we should rewrite using `Functor.assoc` but that gives a "motive is type-incorrect"
    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map (ùüô X)).hom)]
    rw [ModuleCat.restrictScalarsId'App_inv_naturality, map_id]
    dsimp)
  map_comp {X Y Z} f g := colimit.hom_ext (fun j => by
    dsimp
    rw [Œπ_colimMap_assoc, whiskerLeft_app, restriction_app, assoc, Œπ_colimMap_assoc]
    -- Here we should rewrite using `Functor.assoc` but that gives a "motive is type-incorrect"
    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map (f ‚â´ g)).hom),
      Œπ_preservesColimitIso_inv_assoc (G := ModuleCat.restrictScalars (R.map f).hom)]
    rw [‚Üê Functor.map_comp_assoc, Œπ_colimMap_assoc]
    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map g).hom)]
    rw [map_comp, ModuleCat.restrictScalarsComp'_inv_app, assoc, assoc,
      whiskerLeft_app, whiskerLeft_app, restriction_app, restriction_app]
    simp only [Functor.map_comp, assoc]
    rfl)

/-- The (colimit) cocone for `F : J ‚•§ PresheafOfModules.{v} R` that is constructed from
the colimit of `F ‚ãô evaluation R X` for all `X`. -/
@[simps]
noncomputable def colimitCocone : Cocone F where
  pt := colimitPresheafOfModules F
  Œπ :=
    { app := fun j ‚Ü¶
        { app := fun X ‚Ü¶ colimit.Œπ (F ‚ãô evaluation R X) j
          naturality := fun {X Y} f ‚Ü¶ by
            dsimp
            erw [colimit.Œπ_desc_assoc, assoc, ‚Üê Œπ_preservesColimitIso_inv]
            rfl }
      naturality := fun {X Y} f ‚Ü¶ by
        ext1 X
        simpa using colimit.w (F ‚ãô evaluation R X) f }

/-- The cocone `colimitCocone F` is colimit for any `F : J ‚•§ PresheafOfModules.{v} R`. -/
noncomputable def isColimitColimitCocone : IsColimit (colimitCocone F) :=
  evaluationJointlyReflectsColimits _ _ (fun _ => colimit.isColimit _)

instance hasColimit : HasColimit F := ‚ü®_, isColimitColimitCocone F‚ü©

instance evaluation_preservesColimit (X : C·µí·µñ) :
    PreservesColimit F (evaluation R X) :=
  preservesColimit_of_preserves_colimit_cocone (isColimitColimitCocone F) (colimit.isColimit _)

variable [‚àÄ X, PreservesColimit F
  (evaluation R X ‚ãô forget‚ÇÇ (ModuleCat (R.obj X)) AddCommGrp)]

instance toPresheaf_preservesColimit :
    PreservesColimit F (toPresheaf R) :=
  preservesColimit_of_preserves_colimit_cocone (isColimitColimitCocone F)
    (Limits.evaluationJointlyReflectsColimits _
      (fun X => isColimitOfPreserves (evaluation R X ‚ãô forget‚ÇÇ _ AddCommGrp)
        (isColimitColimitCocone F)))

end Colimits

variable (R J)

section HasColimitsOfShape

variable [HasColimitsOfShape J AddCommGrp.{v}]

instance hasColimitsOfShape : HasColimitsOfShape J (PresheafOfModules.{v} R) where

noncomputable instance evaluation_preservesColimitsOfShape (X : C·µí·µñ) :
    PreservesColimitsOfShape J (evaluation R X : PresheafOfModules.{v} R ‚•§ _) where

noncomputable instance toPresheaf_preservesColimitsOfShape :
    PreservesColimitsOfShape J (toPresheaf.{v} R) where

end HasColimitsOfShape

namespace Finite

instance hasFiniteColimits : HasFiniteColimits (PresheafOfModules.{v} R) :=
  ‚ü®fun _ => inferInstance‚ü©

noncomputable instance evaluation_preservesFiniteColimits (X : C·µí·µñ) :
    PreservesFiniteColimits (evaluation.{v} R X) where

noncomputable instance toPresheaf_preservesFiniteColimits :
    PreservesFiniteColimits (toPresheaf R) where

end Finite

end PresheafOfModules

-- END Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits --

-- BEGIN Mathlib.Algebra.Category.ModuleCat.Sheaf.Colimits --
/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification

/-!
# Colimits in categories of sheaves of modules

In this file, we show that colimits of shape `J` exists in a category
of sheaves of modules if it exists in the corresponding category
of presheaves of modules.

-/

universe w' w v v' u' u

namespace SheafOfModules

open CategoryTheory Limits

variable {C : Type u'} [Category.{v'} C] {J : GrothendieckTopology C}

variable (R : Sheaf J RingCat.{u}) [HasWeakSheafify J AddCommGrp.{v}]
  [J.WEqualsLocallyBijective AddCommGrp.{v}] (K : Type w) [Category.{w'} K]

instance [HasColimitsOfShape K (PresheafOfModules.{v} R.val)] :
    HasColimitsOfShape K (SheafOfModules.{v} R) where
  has_colimit F := by
    let e : F ‚âÖ (F ‚ãô forget R) ‚ãô PresheafOfModules.sheafification (ùüô R.val) :=
      isoWhiskerLeft F (asIso (PresheafOfModules.sheafificationAdjunction (ùüô R.val)).counit).symm
    exact hasColimit_of_iso e

end SheafOfModules

-- END Mathlib.Algebra.Category.ModuleCat.Sheaf.Colimits --

import Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Colimits

/-!
# Free sheaves of modules

In this file, we construct the functor
`SheafOfModules.freeFunctor : Type u ‚•§ SheafOfModules.{u} R` which sends
a type `I` to the coproduct of copies indexed by `I` of `unit R`.

## TODO

* In case the category `C` has a terminal object `X`, promote `freeHomEquiv`
into an adjunction between `freeFunctor` and the evaluation functor at `X`.
(Alternatively, assuming specific universe parameters, we could show that
`freeHomEquiv` is a left adjoint to `SheafOfModules.sectionsFunctor`.)

-/

universe u v' u'
open CategoryTheory Limits

variable {C : Type u'} [Category.{v'} C] {J : GrothendieckTopology C} {R : Sheaf J RingCat.{u}}
  [HasWeakSheafify J AddCommGrp.{u}] [J.WEqualsLocallyBijective AddCommGrp.{u}]
  [J.HasSheafCompose (forget‚ÇÇ RingCat.{u} AddCommGrp.{u})]

namespace SheafOfModules

/-- The free sheaf of modules on a certain type `I`. -/
noncomputable def free (I : Type u) : SheafOfModules.{u} R := ‚àê (fun (_ : I) ‚Ü¶ unit R)

/-- The data of a morphism `free I ‚ü∂ M` from a free sheaf of modules is
equivalent to the data of a family `I ‚Üí M.sections` of sections of `M`. -/
noncomputable def freeHomEquiv (M : SheafOfModules.{u} R) {I : Type u} :
    (free I ‚ü∂ M) ‚âÉ (I ‚Üí M.sections) where
  toFun f i := M.unitHomEquiv (Sigma.Œπ (fun (_ : I) ‚Ü¶ unit R) i ‚â´ f)
  invFun s := Sigma.desc (fun i ‚Ü¶ M.unitHomEquiv.symm (s i))
  left_inv s := Sigma.hom_ext _ _ (by simp)
  right_inv f := by

lemma freeHomEquiv_comp_apply {M N : SheafOfModules.{u} R} {I : Type u}
    (f : free I ‚ü∂ M) (p : M ‚ü∂ N) (i : I) :
    N.freeHomEquiv (f ‚â´ p) i = sectionsMap p (M.freeHomEquiv f i) := rfl

lemma freeHomEquiv_symm_comp {M N : SheafOfModules.{u} R} {I : Type u} (s : I ‚Üí M.sections)
    (p : M ‚ü∂ N) :
    M.freeHomEquiv.symm s ‚â´ p = N.freeHomEquiv.symm (fun i ‚Ü¶ sectionsMap p (s i)) :=
  N.freeHomEquiv.injective (by ext; simp [freeHomEquiv_comp_apply])

/-- The tautological section of `free I : SheafOfModules R` corresponding to `i : I`. -/
noncomputable abbrev freeSection {I : Type u} (i : I) : (free (R := R) I).sections :=
  (free (R := R) I).freeHomEquiv (ùüô (free I)) i

section

variable {I J : Type u} (f : I ‚Üí J)

/-- The morphism of presheaves of `R`-modules `free I ‚ü∂ free J` induced by
a map `f : I ‚Üí J`. -/
noncomputable def freeMap : free (R := R) I ‚ü∂ free J :=
  (freeHomEquiv _).symm (fun i ‚Ü¶ freeSection (f i))

@[simp]
lemma freeHomEquiv_freeMap :
    (freeHomEquiv _ (freeMap (R := R) f)) = freeSection.comp f :=
  (freeHomEquiv _).symm.injective (by simp; rfl)

@[simp]
lemma sectionMap_freeMap_freeSection (i : I) :
    sectionsMap (freeMap (R := R) f) (freeSection i) = freeSection (f i) := by

