
1. **Informal Theorem**  
Intrinsic Frontier of the Empty Set is the Empty Set : For any field \( \mathbb{K} \), vector space \( V \), and affine space \( P \) over \( \mathbb{K} \) with the necessary structures (ring, additive commutative group, module, topological space, and additive torsor), the intrinsic frontier of the empty set \( \emptyset \) is the empty set \( \emptyset \).

2. **Informal Proof**  
To prove that the intrinsic frontier of the empty set \( \emptyset \) is the empty set \( \emptyset \), we start by recalling the definition of the intrinsic frontier. The intrinsic frontier of a set \( s \) in an affine space \( P \) over a field \( \mathbb{K} \) is defined as the image of the frontier of the preimage of \( s \) under the canonical map from the affine span of \( s \) to \( P \).

1. **Step 1: Simplify the Proposition Using the Definition**
- The preimage of the empty set \( \emptyset \) under the canonical map from the affine span of \( \emptyset \) to \( P \) is the empty set. This is because there are no points in \( \emptyset \) to map.
- The frontier of the empty set is the empty set. This is a fundamental property of the frontier in topology: the frontier of the empty set is the empty set.
- Therefore, the intrinsic frontier of the empty set is the image of the empty set under the canonical map, which is the empty set.

Thus, the intrinsic frontier of the empty set \( \emptyset \) is the empty set \( \emptyset \). This completes the proof. \(\blacksquare\)

3. **Formal Theorem**  
example : intrinsicFrontier ùïú (‚àÖ : Set P) = ‚àÖ := by sorry

4. **Prefix**
import Mathlib.Analysis.Normed.Affine.AddTorsorBases
import Mathlib.Analysis.Convex.Intrinsic


open AffineSubspace Set
open scoped Pointwise
variable {ùïú V W Q P : Type*}
variable (ùïú) [Ring ùïú] [AddCommGroup V] [Module ùïú V] [TopologicalSpace P] [AddTorsor V P]
  {s t : Set P} {x : P}
variable {ùïú}

example : intrinsicFrontier ùïú (‚àÖ : Set P) = ‚àÖ := by

5. **Header Information**  
-- BEGIN Mathlib.Analysis.Normed.Affine.AddTorsorBases --
/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import Mathlib.Analysis.Normed.Module.FiniteDimension
import Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional

/-!
# Bases in normed affine spaces.

This file contains results about bases in normed affine spaces.

## Main definitions:

 * `continuous_barycentric_coord`
 * `isOpenMap_barycentric_coord`
 * `AffineBasis.interior_convexHull`
 * `IsOpen.exists_subset_affineIndependent_span_eq_top`
 * `interior_convexHull_nonempty_iff_affineSpan_eq_top`
-/

assert_not_exists HasFDerivAt

section Barycentric

variable {Œπ ùïú E P : Type*} [NontriviallyNormedField ùïú] [CompleteSpace ùïú]
variable [NormedAddCommGroup E] [NormedSpace ùïú E]
variable [MetricSpace P] [NormedAddTorsor E P]

theorem isOpenMap_barycentric_coord [Nontrivial Œπ] (b : AffineBasis Œπ ùïú P) (i : Œπ) :
    IsOpenMap (b.coord i) :=
  AffineMap.isOpenMap_linear_iff.mp <|
    (b.coord i).linear.isOpenMap_of_finiteDimensional <|
      (b.coord i).linear_surjective_iff.mpr (b.surjective_coord i)

variable [FiniteDimensional ùïú E] (b : AffineBasis Œπ ùïú P)

@[continuity]
theorem continuous_barycentric_coord (i : Œπ) : Continuous (b.coord i) :=
  (b.coord i).continuous_of_finiteDimensional

end Barycentric

open Set

/-- Given a finite-dimensional normed real vector space, the interior of the convex hull of an
affine basis is the set of points whose barycentric coordinates are strictly positive with respect
to this basis.

TODO Restate this result for affine spaces (instead of vector spaces) once the definition of
convexity is generalised to this setting. -/
theorem AffineBasis.interior_convexHull {Œπ E : Type*} [Finite Œπ] [NormedAddCommGroup E]
    [NormedSpace ‚Ñù E] (b : AffineBasis Œπ ‚Ñù E) :
    interior (convexHull ‚Ñù (range b)) = {x | ‚àÄ i, 0 < b.coord i x} := by
  cases subsingleton_or_nontrivial Œπ
  ¬∑ -- The zero-dimensional case.
    have : range b = univ :=
      AffineSubspace.eq_univ_of_subsingleton_span_eq_top (subsingleton_range _) b.tot
    simp [this]
  ¬∑ -- The positive-dimensional case.
    haveI : FiniteDimensional ‚Ñù E := b.finiteDimensional
    have : convexHull ‚Ñù (range b) = ‚ãÇ i, b.coord i ‚Åª¬π' Ici 0 := by
      rw [b.convexHull_eq_nonneg_coord, setOf_forall]; rfl
    ext
    simp only [this, interior_iInter_of_finite, ‚Üê
      IsOpenMap.preimage_interior_eq_interior_preimage (isOpenMap_barycentric_coord b _)
        (continuous_barycentric_coord b _),
      interior_Ici, mem_iInter, mem_setOf_eq, mem_Ioi, mem_preimage]

variable {V P : Type*} [NormedAddCommGroup V] [NormedSpace ‚Ñù V] [MetricSpace P]
  [NormedAddTorsor V P]

open AffineMap

/-- Given a set `s` of affine-independent points belonging to an open set `u`, we may extend `s` to
an affine basis, all of whose elements belong to `u`. -/
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ‚äÜ u) (hne : s.Nonempty) (h : AffineIndependent ‚Ñù ((‚Üë) : s ‚Üí P)) :
    ‚àÉ t : Set P, s ‚äÜ t ‚àß t ‚äÜ u ‚àß AffineIndependent ‚Ñù ((‚Üë) : t ‚Üí P) ‚àß affineSpan ‚Ñù t = ‚ä§ := by
  obtain ‚ü®q, hq‚ü© := hne
  obtain ‚ü®Œµ, Œµ0, hŒµu‚ü© := Metric.nhds_basis_closedBall.mem_iff.1 (hu.mem_nhds <| hsu hq)
  obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ, ht‚ÇÉ‚ü© := exists_subset_affineIndependent_affineSpan_eq_top h
  let f : P ‚Üí P := fun y => lineMap q y (Œµ / dist y q)
  have hf : ‚àÄ y, f y ‚àà u := by
    refine fun y => hŒµu ?_
    simp only [f]
    rw [Metric.mem_closedBall, lineMap_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,
      dist_eq_norm_vsub V y q, abs_div, abs_of_pos Œµ0, abs_of_nonneg (norm_nonneg _), div_mul_comm]
    exact mul_le_of_le_one_left Œµ0.le (div_self_le_one _)
  have hŒµyq : ‚àÄ y ‚àâ s, Œµ / dist y q ‚â† 0 := fun y hy =>
    div_ne_zero Œµ0.ne' (dist_ne_zero.2 (ne_of_mem_of_not_mem hq hy).symm)
  classical
  let w : t ‚Üí ‚ÑùÀ£ := fun p => if hp : (p : P) ‚àà s then 1 else Units.mk0 _ (hŒµyq (‚Üëp) hp)
  refine ‚ü®Set.range fun p : t => lineMap q p (w p : ‚Ñù), ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp; use ‚ü®p, ht‚ÇÅ hp‚ü©; simp [w, hp]
  ¬∑ rintro y ‚ü®‚ü®p, hp‚ü©, rfl‚ü©
    by_cases hps : p ‚àà s <;>
    simp only [w, hps, lineMap_apply_one, Units.val_mk0, dif_neg, dif_pos, not_false_iff,
      Units.val_one, Subtype.coe_mk] <;>
    [exact hsu hps; exact hf p]
  ¬∑ exact (ht‚ÇÇ.units_lineMap ‚ü®q, ht‚ÇÅ hq‚ü© w).range
  ¬∑ rw [affineSpan_eq_affineSpan_lineMap_units (ht‚ÇÅ hq) w, ht‚ÇÉ]

theorem IsOpen.exists_subset_affineIndependent_span_eq_top {u : Set P} (hu : IsOpen u)
    (hne : u.Nonempty) : ‚àÉ s ‚äÜ u, AffineIndependent ‚Ñù ((‚Üë) : s ‚Üí P) ‚àß affineSpan ‚Ñù s = ‚ä§ := by
  rcases hne with ‚ü®x, hx‚ü©
  rcases hu.exists_between_affineIndependent_span_eq_top (singleton_subset_iff.mpr hx)
    (singleton_nonempty _) (affineIndependent_of_subsingleton _ _) with ‚ü®s, -, hsu, hs‚ü©
  exact ‚ü®s, hsu, hs‚ü©

/-- The affine span of a nonempty open set is `‚ä§`. -/
theorem IsOpen.affineSpan_eq_top {u : Set P} (hu : IsOpen u) (hne : u.Nonempty) :
    affineSpan ‚Ñù u = ‚ä§ :=
  let ‚ü®_, hsu, _, hs'‚ü© := hu.exists_subset_affineIndependent_span_eq_top hne
  top_unique <| hs' ‚ñ∏ affineSpan_mono _ hsu

theorem affineSpan_eq_top_of_nonempty_interior {s : Set V}
    (hs : (interior <| convexHull ‚Ñù s).Nonempty) : affineSpan ‚Ñù s = ‚ä§ :=
  top_unique <| isOpen_interior.affineSpan_eq_top hs ‚ñ∏
    (affineSpan_mono _ interior_subset).trans_eq (affineSpan_convexHull _)

theorem AffineBasis.centroid_mem_interior_convexHull {Œπ} [Fintype Œπ] (b : AffineBasis Œπ ‚Ñù V) :
    Finset.univ.centroid ‚Ñù b ‚àà interior (convexHull ‚Ñù (range b)) := by
  haveI := b.nonempty
  simp only [b.interior_convexHull, mem_setOf_eq, b.coord_apply_centroid (Finset.mem_univ _),
    inv_pos, Nat.cast_pos, Finset.card_pos, Finset.univ_nonempty, forall_true_iff]

theorem interior_convexHull_nonempty_iff_affineSpan_eq_top [FiniteDimensional ‚Ñù V] {s : Set V} :
    (interior (convexHull ‚Ñù s)).Nonempty ‚Üî affineSpan ‚Ñù s = ‚ä§ := by
  refine ‚ü®affineSpan_eq_top_of_nonempty_interior, fun h => ?_‚ü©
  obtain ‚ü®t, hts, b, hb‚ü© := AffineBasis.exists_affine_subbasis h
  suffices (interior (convexHull ‚Ñù (range b))).Nonempty by
    rw [hb, Subtype.range_coe_subtype, setOf_mem_eq] at this
    refine this.mono (by gcongr)
  lift t to Finset V using b.finite_set
  exact ‚ü®_, b.centroid_mem_interior_convexHull‚ü©

theorem Convex.interior_nonempty_iff_affineSpan_eq_top [FiniteDimensional ‚Ñù V] {s : Set V}
    (hs : Convex ‚Ñù s) : (interior s).Nonempty ‚Üî affineSpan ‚Ñù s = ‚ä§ := by
  rw [‚Üê interior_convexHull_nonempty_iff_affineSpan_eq_top, hs.convexHull_eq]

-- END Mathlib.Analysis.Normed.Affine.AddTorsorBases --

import Mathlib.Analysis.Normed.Affine.AddTorsorBases

/-!
# Intrinsic frontier and interior

This file defines the intrinsic frontier, interior and closure of a set in a normed additive torsor.
These are also known as relative frontier, interior, closure.

The intrinsic frontier/interior/closure of a set `s` is the frontier/interior/closure of `s`
considered as a set in its affine span.

The intrinsic interior is in general greater than the topological interior, the intrinsic frontier
in general less than the topological frontier, and the intrinsic closure in cases of interest the
same as the topological closure.

## Definitions

* `intrinsicInterior`: Intrinsic interior
* `intrinsicFrontier`: Intrinsic frontier
* `intrinsicClosure`: Intrinsic closure

## Results

The main results are:
* `AffineIsometry.image_intrinsicInterior`/`AffineIsometry.image_intrinsicFrontier`/
  `AffineIsometry.image_intrinsicClosure`: Intrinsic interiors/frontiers/closures commute with
  taking the image under an affine isometry.
* `Set.Nonempty.intrinsicInterior`: The intrinsic interior of a nonempty convex set is nonempty.

## References

* Chapter 8 of [Barry Simon, *Convexity*][simon2011]
* Chapter 1 of [Rolf Schneider, *Convex Bodies: The Brunn-Minkowski theory*][schneider2013].

## TODO

* `IsClosed s ‚Üí IsExtreme ùïú s (intrinsicFrontier ùïú s)`
* `x ‚àà s ‚Üí y ‚àà intrinsicInterior ùïú s ‚Üí openSegment ùïú x y ‚äÜ intrinsicInterior ùïú s`
-/

open AffineSubspace Set Topology
open scoped Pointwise

variable {ùïú V W Q P : Type*}

section AddTorsor

variable (ùïú) [Ring ùïú] [AddCommGroup V] [Module ùïú V] [TopologicalSpace P] [AddTorsor V P]
  {s t : Set P} {x : P}

/-- The intrinsic interior of a set is its interior considered as a set in its affine span. -/
def intrinsicInterior (s : Set P) : Set P :=
  (‚Üë) '' interior ((‚Üë) ‚Åª¬π' s : Set <| affineSpan ùïú s)

/-- The intrinsic frontier of a set is its frontier considered as a set in its affine span. -/
def intrinsicFrontier (s : Set P) : Set P :=
  (‚Üë) '' frontier ((‚Üë) ‚Åª¬π' s : Set <| affineSpan ùïú s)

/-- The intrinsic closure of a set is its closure considered as a set in its affine span. -/
def intrinsicClosure (s : Set P) : Set P :=
  (‚Üë) '' closure ((‚Üë) ‚Åª¬π' s : Set <| affineSpan ùïú s)

variable {ùïú}

@[simp]
theorem mem_intrinsicInterior :
    x ‚àà intrinsicInterior ùïú s ‚Üî ‚àÉ y, y ‚àà interior ((‚Üë) ‚Åª¬π' s : Set <| affineSpan ùïú s) ‚àß ‚Üëy = x :=
  mem_image _ _ _

@[simp]
theorem mem_intrinsicFrontier :
    x ‚àà intrinsicFrontier ùïú s ‚Üî ‚àÉ y, y ‚àà frontier ((‚Üë) ‚Åª¬π' s : Set <| affineSpan ùïú s) ‚àß ‚Üëy = x :=
  mem_image _ _ _

@[simp]
theorem mem_intrinsicClosure :
    x ‚àà intrinsicClosure ùïú s ‚Üî ‚àÉ y, y ‚àà closure ((‚Üë) ‚Åª¬π' s : Set <| affineSpan ùïú s) ‚àß ‚Üëy = x :=
  mem_image _ _ _

theorem intrinsicInterior_subset : intrinsicInterior ùïú s ‚äÜ s :=
  image_subset_iff.2 interior_subset

theorem intrinsicFrontier_subset (hs : IsClosed s) : intrinsicFrontier ùïú s ‚äÜ s :=
  image_subset_iff.2 (hs.preimage continuous_induced_dom).frontier_subset

theorem intrinsicFrontier_subset_intrinsicClosure : intrinsicFrontier ùïú s ‚äÜ intrinsicClosure ùïú s :=
  image_subset _ frontier_subset_closure

theorem subset_intrinsicClosure : s ‚äÜ intrinsicClosure ùïú s :=
  fun x hx => ‚ü®‚ü®x, subset_affineSpan _ _ hx‚ü©, subset_closure hx, rfl‚ü©

@[simp]
theorem intrinsicInterior_empty : intrinsicInterior ùïú (‚àÖ : Set P) = ‚àÖ := by

@[simp]
theorem intrinsicFrontier_empty : intrinsicFrontier ùïú (‚àÖ : Set P) = ‚àÖ := by

