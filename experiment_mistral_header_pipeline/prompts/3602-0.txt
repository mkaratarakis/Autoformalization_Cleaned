
1. **Informal Theorem**  
Continuum is Strictly Less Than Lifted Cardinal if and Only if Continuum is Strictly Less Than Original Cardinal: \( \mathfrak{c} < \text{Cardinal.lift} \, c \leftrightarrow \mathfrak{c} < c \) : For any cardinal number \( c \) in a universe \( u \), the cardinality of the continuum \( \mathfrak{c} \) is strictly less than the lifted cardinal number \( \text{Cardinal.lift} \, c \) in the universe \( \max(v, u) \) if and only if \( \mathfrak{c} \) is strictly less than \( c \). Formally, this is expressed as:
\[ \mathfrak{c} < \text{Cardinal.lift} \, c \leftrightarrow \mathfrak{c} < c \]

2. **Informal Proof**  
We start by using the property that the lift of the continuum cardinality is equal to the continuum itself, i.e., \( \mathfrak{c}^{\max(v, u)} = \mathfrak{c} \). This allows us to rewrite the left-hand side of the goal as \( \mathfrak{c} < \text{Cardinal.lift} \, c \). Next, we apply the theorem that lifting preserves strict inequality of cardinal numbers, i.e., \( \text{Cardinal.lift} \, a < \text{Cardinal.lift} \, b \leftrightarrow a < b \). By applying this theorem, we transform the goal into \( \mathfrak{c} < c \leftrightarrow \mathfrak{c} < c \), which is trivially true. Therefore, the original statement holds.

3. **Formal Theorem**  
example {c : Cardinal.{u}} : ğ”  < lift.{v} c â†” ğ”  < c := by sorry

4. **Prefix**
import Mathlib.SetTheory.Cardinal.Ordinal
import Mathlib.SetTheory.Cardinal.Continuum

open Cardinal
open Cardinal

example {c : Cardinal.{u}} : ğ”  < lift.{v} c â†” ğ”  < c := by

5. **Header Information**  
-- BEGIN Mathlib.SetTheory.Cardinal.Ordinal --
/-
Copyright (c) 2024 Violeta HernÃ¡ndez Palacios. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Violeta HernÃ¡ndez Palacios
-/
import Mathlib.SetTheory.Cardinal.Arithmetic
import Mathlib.SetTheory.Ordinal.Principal

/-!
# Ordinal arithmetic with cardinals

This file collects results about the cardinality of different ordinal operations.
-/

universe u v
open Cardinal Ordinal Set

/-! ### Cardinal operations with ordinal indices -/

namespace Cardinal

/-- Bounds the cardinal of an ordinal-indexed union of sets. -/
lemma mk_iUnion_Ordinal_lift_le_of_le {Î² : Type v} {o : Ordinal.{u}} {c : Cardinal.{v}}
    (ho : lift.{v} o.card â‰¤ lift.{u} c) (hc : â„µâ‚€ â‰¤ c) (A : Ordinal â†’ Set Î²)
    (hA : âˆ€ j < o, #(A j) â‰¤ c) : #(â‹ƒ j < o, A j) â‰¤ c := by
  simp_rw [â† mem_Iio, biUnion_eq_iUnion, iUnion, iSup, â† o.enumIsoToType.symm.surjective.range_comp]
  rw [â† lift_le.{u}]
  apply ((mk_iUnion_le_lift _).trans _).trans_eq (mul_eq_self (aleph0_le_lift.2 hc))
  rw [mk_toType]
  refine mul_le_mul' ho (ciSup_le' ?_)
  intro i
  simpa using hA _ (o.enumIsoToType.symm i).2

lemma mk_iUnion_Ordinal_le_of_le {Î² : Type*} {o : Ordinal} {c : Cardinal}
    (ho : o.card â‰¤ c) (hc : â„µâ‚€ â‰¤ c) (A : Ordinal â†’ Set Î²)
    (hA : âˆ€ j < o, #(A j) â‰¤ c) : #(â‹ƒ j < o, A j) â‰¤ c := by
  apply mk_iUnion_Ordinal_lift_le_of_le _ hc A hA
  rwa [Cardinal.lift_le]

end Cardinal

@[deprecated mk_iUnion_Ordinal_le_of_le (since := "2024-11-02")]
alias Ordinal.Cardinal.mk_iUnion_Ordinal_le_of_le := mk_iUnion_Ordinal_le_of_le

/-! ### Cardinality of ordinals -/

namespace Ordinal

theorem lift_card_iSup_le_sum_card {Î¹ : Type u} [Small.{v} Î¹] (f : Î¹ â†’ Ordinal.{v}) :
    Cardinal.lift.{u} (â¨† i, f i).card â‰¤ Cardinal.sum fun i â†¦ (f i).card := by
  simp_rw [â† mk_toType]
  rw [â† mk_sigma, â† Cardinal.lift_id'.{v} #(Î£ _, _), â† Cardinal.lift_umax.{v, u}]
  apply lift_mk_le_lift_mk_of_surjective (f := enumIsoToType _ âˆ˜ (âŸ¨(enumIsoToType _).symm Â·.2,
    (mem_Iio.mp ((enumIsoToType _).symm _).2).trans_le (Ordinal.le_iSup _ _)âŸ©))
  rw [EquivLike.comp_surjective]
  rintro âŸ¨x, hxâŸ©
  obtain âŸ¨i, hiâŸ© := Ordinal.lt_iSup_iff.mp hx
  exact âŸ¨âŸ¨i, enumIsoToType _ âŸ¨x, hiâŸ©âŸ©, by simpâŸ©

theorem card_iSup_le_sum_card {Î¹ : Type u} (f : Î¹ â†’ Ordinal.{max u v}) :
    (â¨† i, f i).card â‰¤ Cardinal.sum (fun i â†¦ (f i).card) := by
  have := lift_card_iSup_le_sum_card f
  rwa [Cardinal.lift_id'] at this

theorem card_iSup_Iio_le_sum_card {o : Ordinal.{u}} (f : Iio o â†’ Ordinal.{max u v}) :
    (â¨† a : Iio o, f a).card â‰¤ Cardinal.sum fun i â†¦ (f ((enumIsoToType o).symm i)).card := by
  apply le_of_eq_of_le (congr_arg _ _).symm (card_iSup_le_sum_card _)
  simpa using (enumIsoToType o).symm.iSup_comp (g := fun x â†¦ f x)

theorem card_iSup_Iio_le_card_mul_iSup {o : Ordinal.{u}} (f : Iio o â†’ Ordinal.{max u v}) :
    (â¨† a : Iio o, f a).card â‰¤ Cardinal.lift.{v} o.card * â¨† a : Iio o, (f a).card := by
  apply (card_iSup_Iio_le_sum_card f).trans
  convert â† sum_le_iSup_lift _
  Â· exact mk_toType o
  Â· exact (enumIsoToType o).symm.iSup_comp (g := fun x â†¦ (f x).card)

theorem card_opow_le_of_omega0_le_left {a : Ordinal} (ha : Ï‰ â‰¤ a) (b : Ordinal) :
    (a ^ b).card â‰¤ max a.card b.card := by
  refine limitRecOn b ?_ ?_ ?_
  Â· simpa using one_lt_omega0.le.trans ha
  Â· intro b IH
    rw [opow_succ, card_mul, card_succ, Cardinal.mul_eq_max_of_aleph0_le_right, max_comm]
    Â· apply (max_le_max_left _ IH).trans
      rw [â† max_assoc, max_self]
      exact max_le_max_left _ le_self_add
    Â· rw [ne_eq, card_eq_zero, opow_eq_zero]
      rintro âŸ¨rfl, -âŸ©
      cases omega0_pos.not_le ha
    Â· rwa [aleph0_le_card]
  Â· intro b hb IH
    rw [(isNormal_opow (one_lt_omega0.trans_le ha)).apply_of_isLimit hb]
    apply (card_iSup_Iio_le_card_mul_iSup _).trans
    rw [Cardinal.lift_id, Cardinal.mul_eq_max_of_aleph0_le_right, max_comm]
    Â· apply max_le _ (le_max_right _ _)
      apply ciSup_le'
      intro c
      exact (IH c.1 c.2).trans (max_le_max_left _ (card_le_card c.2.le))
    Â· simpa using hb.pos.ne'
    Â· refine le_ciSup_of_le ?_ âŸ¨1, one_lt_omega0.trans_le <| omega0_le_of_isLimit hbâŸ© ?_
      Â· exact Cardinal.bddAbove_of_small _
      Â· simpa

theorem card_opow_le_of_omega0_le_right (a : Ordinal) {b : Ordinal} (hb : Ï‰ â‰¤ b) :
    (a ^ b).card â‰¤ max a.card b.card := by
  obtain âŸ¨n, rflâŸ© | ha := eq_nat_or_omega0_le a
  Â· apply (card_le_card <| opow_le_opow_left b (nat_lt_omega0 n).le).trans
    apply (card_opow_le_of_omega0_le_left le_rfl _).trans
    simp [hb]
  Â· exact card_opow_le_of_omega0_le_left ha b

theorem card_opow_le (a b : Ordinal) : (a ^ b).card â‰¤ max â„µâ‚€ (max a.card b.card) := by
  obtain âŸ¨n, rflâŸ© | ha := eq_nat_or_omega0_le a
  Â· obtain âŸ¨m, rflâŸ© | hb := eq_nat_or_omega0_le b
    Â· rw [â† natCast_opow, card_nat]
      exact le_max_of_le_left (nat_lt_aleph0 _).le
    Â· exact (card_opow_le_of_omega0_le_right _ hb).trans (le_max_right _ _)
  Â· exact (card_opow_le_of_omega0_le_left ha _).trans (le_max_right _ _)

theorem card_opow_eq_of_omega0_le_left {a b : Ordinal} (ha : Ï‰ â‰¤ a) (hb : 0 < b) :
    (a ^ b).card = max a.card b.card := by
  apply (card_opow_le_of_omega0_le_left ha b).antisymm (max_le _ _) <;> apply card_le_card
  Â· exact left_le_opow a hb
  Â· exact right_le_opow b (one_lt_omega0.trans_le ha)

theorem card_opow_eq_of_omega0_le_right {a b : Ordinal} (ha : 1 < a) (hb : Ï‰ â‰¤ b) :
    (a ^ b).card = max a.card b.card := by
  apply (card_opow_le_of_omega0_le_right a hb).antisymm (max_le _ _) <;> apply card_le_card
  Â· exact left_le_opow a (omega0_pos.trans_le hb)
  Â· exact right_le_opow b ha

theorem card_omega0_opow {a : Ordinal} (h : a â‰  0) : card (Ï‰ ^ a) = max â„µâ‚€ a.card := by
  rw [card_opow_eq_of_omega0_le_left le_rfl h.bot_lt, card_omega0]

theorem card_opow_omega0 {a : Ordinal} (h : 1 < a) : card (a ^ Ï‰) = max â„µâ‚€ a.card := by
  rw [card_opow_eq_of_omega0_le_right h le_rfl, card_omega0, max_comm]

theorem principal_opow_omega (o : Ordinal) : Principal (Â· ^ Â·) (Ï‰_ o) := by
  obtain rfl | ho := Ordinal.eq_zero_or_pos o
  Â· rw [omega_zero]
    exact principal_opow_omega0
  Â· intro a b ha hb
    rw [lt_omega_iff_card_lt] at ha hb âŠ¢
    apply (card_opow_le a b).trans_lt (max_lt _ (max_lt ha hb))
    rwa [â† aleph_zero, aleph_lt_aleph]

theorem IsInitial.principal_opow {o : Ordinal} (h : IsInitial o) (ho : Ï‰ â‰¤ o) :
    Principal (Â· ^ Â·) o := by
  obtain âŸ¨a, rflâŸ© := mem_range_omega_iff.2 âŸ¨ho, hâŸ©
  exact principal_opow_omega a

theorem principal_opow_ord {c : Cardinal} (hc : â„µâ‚€ â‰¤ c) : Principal (Â· ^ Â·) c.ord := by
  apply (isInitial_ord c).principal_opow
  rwa [omega0_le_ord]

/-! ### Initial ordinals are principal -/

theorem principal_add_ord {c : Cardinal} (hc : â„µâ‚€ â‰¤ c) : Principal (Â· + Â·) c.ord := by
  intro a b ha hb
  rw [lt_ord, card_add] at *
  exact add_lt_of_lt hc ha hb

theorem IsInitial.principal_add {o : Ordinal} (h : IsInitial o) (ho : Ï‰ â‰¤ o) :
    Principal (Â· + Â·) o := by
  rw [â† h.ord_card]
  apply principal_add_ord
  rwa [aleph0_le_card]

theorem principal_add_omega (o : Ordinal) : Principal (Â· + Â·) (Ï‰_ o) :=
  (isInitial_omega o).principal_add (omega0_le_omega o)

theorem principal_mul_ord {c : Cardinal} (hc : â„µâ‚€ â‰¤ c) : Principal (Â· * Â·) c.ord := by
  intro a b ha hb
  rw [lt_ord, card_mul] at *
  exact mul_lt_of_lt hc ha hb

theorem IsInitial.principal_mul {o : Ordinal} (h : IsInitial o) (ho : Ï‰ â‰¤ o) :
    Principal (Â· * Â·) o := by
  rw [â† h.ord_card]
  apply principal_mul_ord
  rwa [aleph0_le_card]

theorem principal_mul_omega (o : Ordinal) : Principal (Â· * Â·) (Ï‰_ o) :=
  (isInitial_omega o).principal_mul (omega0_le_omega o)

@[deprecated principal_add_omega (since := "2024-11-08")]
theorem _root_.Cardinal.principal_add_aleph (o : Ordinal) : Principal (Â· + Â·) (â„µ_ o).ord :=
  principal_add_ord <| aleph0_le_aleph o

end Ordinal

-- END Mathlib.SetTheory.Cardinal.Ordinal --

import Mathlib.SetTheory.Cardinal.Arithmetic

/-!
# Cardinality of continuum

In this file we define `Cardinal.continuum` (notation: `ğ” `, localized in `Cardinal`) to be `2 ^ â„µâ‚€`.
We also prove some `simp` lemmas about cardinal arithmetic involving `ğ” `.

## Notation

- `ğ” ` : notation for `Cardinal.continuum` in locale `Cardinal`.
-/


namespace Cardinal

universe u v

open Cardinal

/-- Cardinality of the continuum. -/
def continuum : Cardinal.{u} :=
  2 ^ â„µâ‚€

@[inherit_doc] scoped notation "ğ” " => Cardinal.continuum

@[simp]
theorem two_power_aleph0 : 2 ^ â„µâ‚€ = ğ”  :=
  rfl

@[simp]
theorem lift_continuum : lift.{v} ğ”  = ğ”  := by
  rw [â† two_power_aleph0, lift_two_power, lift_aleph0, two_power_aleph0]

@[simp]
theorem continuum_le_lift {c : Cardinal.{u}} : ğ”  â‰¤ lift.{v} c â†” ğ”  â‰¤ c := by
  rw [â† lift_continuum.{v, u}, lift_le]

@[simp]
theorem lift_le_continuum {c : Cardinal.{u}} : lift.{v} c â‰¤ ğ”  â†” c â‰¤ ğ”  := by
  rw [â† lift_continuum.{v, u}, lift_le]

@[simp]
theorem continuum_lt_lift {c : Cardinal.{u}} : ğ”  < lift.{v} c â†” ğ”  < c := by

