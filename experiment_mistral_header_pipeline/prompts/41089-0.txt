
1. **Informal Theorem**  
Strict Product Rule for Derivatives : For a nontrivially normed field \( \mathbb{K} \), let \( x \) be an element of \( \mathbb{K} \), and let \( \mathbb{A} \) be a normed ring that is also a normed algebra over \( \mathbb{K} \). Suppose \( c \) and \( d \) are functions from \( \mathbb{K} \) to \( \mathbb{A} \) with strict derivatives \( c' \) and \( d' \) at \( x \), respectively. Then, the function \( f(y) = c(y) \cdot d(y) \) has the strict derivative \( f'(x) = c'(x) \cdot d(x) + c(x) \cdot d'(x) \) at \( x \).

2. **Informal Proof**  
To prove the theorem, we start by using the fact that if \( c \) has a strict derivative \( c' \) at \( x \) and \( d \) has a strict derivative \( d' \) at \( x \), then the function \( y \mapsto c(y) \cdot d(y) \) has a strict derivative at \( x \) given by \( c(x) \cdot d' + c'(x) \cdot d(x) \). This gives us a new hypothesis that \( y \mapsto c(y) \cdot d(y) \) has a strict derivative at \( x \) given by \( c(x) \cdot d' + c'(x) \cdot d(x) \).

Next, we simplify the expression for the strict derivative of \( y \mapsto c(y) \cdot d(y) \) at \( x \) using the properties of continuous linear maps and scalar multiplication:
1. The addition of continuous linear maps applied to an element: \((f + g)(x) = f(x) + g(x)\).
2. Scalar multiplication on continuous linear maps: \((c \cdot f)(x) = c \cdot f(x)\).
3. Application of continuous scalar multiplication on the right: \((c \cdot f)(x) = c(x) \cdot f\).
4. The identity map in continuous linear maps: \(\text{id}(x) = x\).
5. The multiplicative identity action: \(1 \cdot b = b\).
6. The commutativity of addition: \(a + b = b + a\).

After applying these properties, we find that the strict derivative of \( y \mapsto c(y) \cdot d(y) \) at \( x \) is \( c'(x) \cdot d(x) + c(x) \cdot d'(x) \).

Thus, the function \( f(y) = c(y) \cdot d(y) \) has the strict derivative \( f'(x) = c'(x) \cdot d(x) + c(x) \cdot d'(x) \) at \( x \). This completes the proof. \(\blacksquare\)

3. **Formal Theorem**  
example (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :
    HasStrictDerivAt (fun y => c y * d y) (c' * d x + c x * d') x := by sorry

4. **Prefix**
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Analysis.Calculus.FDeriv.Mul
import Mathlib.Analysis.Calculus.FDeriv.Add
import Mathlib.Analysis.Calculus.Deriv.Mul

open HasStrictDerivAt
open scoped Topology Filter ENNReal
open Filter Asymptotics Set
open ContinuousLinearMap (smulRight smulRight_one_eq_iff)
variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {B : E â†’L[ğ•œ] F â†’L[ğ•œ] G} {u : ğ•œ â†’ E} {v : ğ•œ â†’ F} {u' : E} {v' : F}
variable {ğ•œ' : Type*} [NontriviallyNormedField ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] [NormedSpace ğ•œ' F]
  [IsScalarTower ğ•œ ğ•œ' F] {c : ğ•œ â†’ ğ•œ'} {c' : ğ•œ'}
variable {R : Type*} [Semiring R] [Module R F] [SMulCommClass ğ•œ R F] [ContinuousConstSMul R F]
variable {ğ•œ' ğ”¸ : Type*} [NormedField ğ•œ'] [NormedRing ğ”¸] [NormedAlgebra ğ•œ ğ•œ'] [NormedAlgebra ğ•œ ğ”¸]
  {c d : ğ•œ â†’ ğ”¸} {c' d' : ğ”¸} {u v : ğ•œ â†’ ğ•œ'}

example (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :
    HasStrictDerivAt (fun y => c y * d y) (c' * d x + c x * d') x := by

5. **Header Information**  
-- BEGIN Mathlib.Analysis.Calculus.Deriv.Basic --
/-
Copyright (c) 2019 Gabriel Ebner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner, SÃ©bastien GouÃ«zel
-/
import Mathlib.Analysis.Calculus.FDeriv.Basic
import Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace

/-!

# One-dimensional derivatives

This file defines the derivative of a function `f : ğ•œ â†’ F` where `ğ•œ` is a
normed field and `F` is a normed space over this field. The derivative of
such a function `f` at a point `x` is given by an element `f' : F`.

The theory is developed analogously to the [FrÃ©chet
derivatives](./fderiv.html). We first introduce predicates defined in terms
of the corresponding predicates for FrÃ©chet derivatives:

 - `HasDerivAtFilter f f' x L` states that the function `f` has the
    derivative `f'` at the point `x` as `x` goes along the filter `L`.

 - `HasDerivWithinAt f f' s x` states that the function `f` has the
    derivative `f'` at the point `x` within the subset `s`.

 - `HasDerivAt f f' x` states that the function `f` has the derivative `f'`
    at the point `x`.

 - `HasStrictDerivAt f f' x` states that the function `f` has the derivative `f'`
    at the point `x` in the sense of strict differentiability, i.e.,
   `f y - f z = (y - z) â€¢ f' + o (y - z)` as `y, z â†’ x`.

For the last two notions we also define a functional version:

  - `derivWithin f s x` is a derivative of `f` at `x` within `s`. If the
    derivative does not exist, then `derivWithin f s x` equals zero.

  - `deriv f x` is a derivative of `f` at `x`. If the derivative does not
    exist, then `deriv f x` equals zero.

The theorems `fderivWithin_derivWithin` and `fderiv_deriv` show that the
one-dimensional derivatives coincide with the general FrÃ©chet derivatives.

We also show the existence and compute the derivatives of:
  - constants
  - the identity function
  - linear maps (in `Linear.lean`)
  - addition (in `Add.lean`)
  - sum of finitely many functions (in `Add.lean`)
  - negation (in `Add.lean`)
  - subtraction (in `Add.lean`)
  - star (in `Star.lean`)
  - multiplication of two functions in `ğ•œ â†’ ğ•œ` (in `Mul.lean`)
  - multiplication of a function in `ğ•œ â†’ ğ•œ` and of a function in `ğ•œ â†’ E` (in `Mul.lean`)
  - powers of a function (in `Pow.lean` and `ZPow.lean`)
  - inverse `x â†’ xâ»Â¹` (in `Inv.lean`)
  - division (in `Inv.lean`)
  - composition of a function in `ğ•œ â†’ F` with a function in `ğ•œ â†’ ğ•œ` (in `Comp.lean`)
  - composition of a function in `F â†’ E` with a function in `ğ•œ â†’ F` (in `Comp.lean`)
  - inverse function (assuming that it exists; the inverse function theorem is in `Inverse.lean`)
  - polynomials (in `Polynomial.lean`)

For most binary operations we also define `const_op` and `op_const` theorems for the cases when
the first or second argument is a constant. This makes writing chains of `HasDerivAt`'s easier,
and they more frequently lead to the desired result.

We set up the simplifier so that it can compute the derivative of simple functions. For instance,
```lean
example (x : â„) :
    deriv (fun x â†¦ cos (sin x) * exp x) x = (cos (sin x) - sin (sin x) * cos x) * exp x := by
  simp; ring
```

The relationship between the derivative of a function and its definition from a standard
undergraduate course as the limit of the slope `(f y - f x) / (y - x)` as `y` tends to `ğ“[â‰ ] x`
is developed in the file `Slope.lean`.

## Implementation notes

Most of the theorems are direct restatements of the corresponding theorems
for FrÃ©chet derivatives.

The strategy to construct simp lemmas that give the simplifier the possibility to compute
derivatives is the same as the one for differentiability statements, as explained in
`FDeriv/Basic.lean`. See the explanations there.
-/

universe u v w

noncomputable section

open scoped Topology ENNReal NNReal
open Filter Asymptotics Set

open ContinuousLinearMap (smulRight smulRight_one_eq_iff)

section TVS

variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [AddCommGroup F] [Module ğ•œ F] [TopologicalSpace F]

section
variable [ContinuousSMul ğ•œ F]
/-- `f` has the derivative `f'` at the point `x` as `x` goes along the filter `L`.

That is, `f x' = f x + (x' - x) â€¢ f' + o(x' - x)` where `x'` converges along the filter `L`.
-/
def HasDerivAtFilter (f : ğ•œ â†’ F) (f' : F) (x : ğ•œ) (L : Filter ğ•œ) :=
  HasFDerivAtFilter f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x L

/-- `f` has the derivative `f'` at the point `x` within the subset `s`.

That is, `f x' = f x + (x' - x) â€¢ f' + o(x' - x)` where `x'` converges to `x` inside `s`.
-/
def HasDerivWithinAt (f : ğ•œ â†’ F) (f' : F) (s : Set ğ•œ) (x : ğ•œ) :=
  HasDerivAtFilter f f' x (ğ“[s] x)

/-- `f` has the derivative `f'` at the point `x`.

That is, `f x' = f x + (x' - x) â€¢ f' + o(x' - x)` where `x'` converges to `x`.
-/
def HasDerivAt (f : ğ•œ â†’ F) (f' : F) (x : ğ•œ) :=
  HasDerivAtFilter f f' x (ğ“ x)

/-- `f` has the derivative `f'` at the point `x` in the sense of strict differentiability.

That is, `f y - f z = (y - z) â€¢ f' + o(y - z)` as `y, z â†’ x`. -/
def HasStrictDerivAt (f : ğ•œ â†’ F) (f' : F) (x : ğ•œ) :=
  HasStrictFDerivAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x

end
/-- Derivative of `f` at the point `x` within the set `s`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `âˆƒ f', HasDerivWithinAt f f' s x`), then
`f x' = f x + (x' - x) â€¢ derivWithin f s x + o(x' - x)` where `x'` converges to `x` inside `s`.
-/
def derivWithin (f : ğ•œ â†’ F) (s : Set ğ•œ) (x : ğ•œ) :=
  fderivWithin ğ•œ f s x 1

/-- Derivative of `f` at the point `x`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `âˆƒ f', HasDerivAt f f' x`), then
`f x' = f x + (x' - x) â€¢ deriv f x + o(x' - x)` where `x'` converges to `x`.
-/
def deriv (f : ğ•œ â†’ F) (x : ğ•œ) :=
  fderiv ğ•œ f x 1

variable {f fâ‚€ fâ‚ : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}

section
variable [ContinuousSMul ğ•œ F]
/-- Expressing `HasFDerivAtFilter f f' x L` in terms of `HasDerivAtFilter` -/
theorem hasFDerivAtFilter_iff_hasDerivAtFilter {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivAtFilter f f' x L â†” HasDerivAtFilter f (f' 1) x L := by simp [HasDerivAtFilter]

theorem HasFDerivAtFilter.hasDerivAtFilter {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivAtFilter f f' x L â†’ HasDerivAtFilter f (f' 1) x L :=
  hasFDerivAtFilter_iff_hasDerivAtFilter.mp

/-- Expressing `HasFDerivWithinAt f f' s x` in terms of `HasDerivWithinAt` -/
theorem hasFDerivWithinAt_iff_hasDerivWithinAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivWithinAt f f' s x â†” HasDerivWithinAt f (f' 1) s x :=
  hasFDerivAtFilter_iff_hasDerivAtFilter

/-- Expressing `HasDerivWithinAt f f' s x` in terms of `HasFDerivWithinAt` -/
theorem hasDerivWithinAt_iff_hasFDerivWithinAt {f' : F} :
    HasDerivWithinAt f f' s x â†” HasFDerivWithinAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') s x :=
  Iff.rfl

theorem HasFDerivWithinAt.hasDerivWithinAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivWithinAt f f' s x â†’ HasDerivWithinAt f (f' 1) s x :=
  hasFDerivWithinAt_iff_hasDerivWithinAt.mp

theorem HasDerivWithinAt.hasFDerivWithinAt {f' : F} :
    HasDerivWithinAt f f' s x â†’ HasFDerivWithinAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') s x :=
  hasDerivWithinAt_iff_hasFDerivWithinAt.mp

/-- Expressing `HasFDerivAt f f' x` in terms of `HasDerivAt` -/
theorem hasFDerivAt_iff_hasDerivAt {f' : ğ•œ â†’L[ğ•œ] F} : HasFDerivAt f f' x â†” HasDerivAt f (f' 1) x :=
  hasFDerivAtFilter_iff_hasDerivAtFilter

theorem HasFDerivAt.hasDerivAt {f' : ğ•œ â†’L[ğ•œ] F} : HasFDerivAt f f' x â†’ HasDerivAt f (f' 1) x :=
  hasFDerivAt_iff_hasDerivAt.mp

theorem hasStrictFDerivAt_iff_hasStrictDerivAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasStrictFDerivAt f f' x â†” HasStrictDerivAt f (f' 1) x := by
  simp [HasStrictDerivAt, HasStrictFDerivAt]

protected theorem HasStrictFDerivAt.hasStrictDerivAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasStrictFDerivAt f f' x â†’ HasStrictDerivAt f (f' 1) x :=
  hasStrictFDerivAt_iff_hasStrictDerivAt.mp

theorem hasStrictDerivAt_iff_hasStrictFDerivAt :
    HasStrictDerivAt f f' x â†” HasStrictFDerivAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x :=
  Iff.rfl

alias âŸ¨HasStrictDerivAt.hasStrictFDerivAt, _âŸ© := hasStrictDerivAt_iff_hasStrictFDerivAt

/-- Expressing `HasDerivAt f f' x` in terms of `HasFDerivAt` -/
theorem hasDerivAt_iff_hasFDerivAt {f' : F} :
    HasDerivAt f f' x â†” HasFDerivAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x :=
  Iff.rfl

alias âŸ¨HasDerivAt.hasFDerivAt, _âŸ© := hasDerivAt_iff_hasFDerivAt

end
theorem derivWithin_zero_of_not_differentiableWithinAt (h : Â¬DifferentiableWithinAt ğ•œ f s x) :
    derivWithin f s x = 0 := by
  unfold derivWithin
  rw [fderivWithin_zero_of_not_differentiableWithinAt h]
  simp

theorem differentiableWithinAt_of_derivWithin_ne_zero (h : derivWithin f s x â‰  0) :
    DifferentiableWithinAt ğ•œ f s x :=
  not_imp_comm.1 derivWithin_zero_of_not_differentiableWithinAt h

end TVS

variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]

variable {f fâ‚€ fâ‚ : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}

theorem derivWithin_zero_of_isolated (h : ğ“[s \ {x}] x = âŠ¥) : derivWithin f s x = 0 := by
  rw [derivWithin, fderivWithin_zero_of_isolated h, ContinuousLinearMap.zero_apply]

theorem derivWithin_zero_of_nmem_closure (h : x âˆ‰ closure s) : derivWithin f s x = 0 := by
  rw [derivWithin, fderivWithin_zero_of_nmem_closure h, ContinuousLinearMap.zero_apply]

theorem deriv_zero_of_not_differentiableAt (h : Â¬DifferentiableAt ğ•œ f x) : deriv f x = 0 := by
  unfold deriv
  rw [fderiv_zero_of_not_differentiableAt h]
  simp

theorem differentiableAt_of_deriv_ne_zero (h : deriv f x â‰  0) : DifferentiableAt ğ•œ f x :=
  not_imp_comm.1 deriv_zero_of_not_differentiableAt h

theorem UniqueDiffWithinAt.eq_deriv (s : Set ğ•œ) (H : UniqueDiffWithinAt ğ•œ s x)
    (h : HasDerivWithinAt f f' s x) (hâ‚ : HasDerivWithinAt f fâ‚' s x) : f' = fâ‚' :=
  smulRight_one_eq_iff.mp <| UniqueDiffWithinAt.eq H h hâ‚

theorem hasDerivAtFilter_iff_isLittleO :
    HasDerivAtFilter f f' x L â†” (fun x' : ğ•œ => f x' - f x - (x' - x) â€¢ f') =o[L] fun x' => x' - x :=
  hasFDerivAtFilter_iff_isLittleO ..

theorem hasDerivAtFilter_iff_tendsto :
    HasDerivAtFilter f f' x L â†”
      Tendsto (fun x' : ğ•œ => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - (x' - x) â€¢ f'â€–) L (ğ“ 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem hasDerivWithinAt_iff_isLittleO :
    HasDerivWithinAt f f' s x â†”
      (fun x' : ğ•œ => f x' - f x - (x' - x) â€¢ f') =o[ğ“[s] x] fun x' => x' - x :=
  hasFDerivAtFilter_iff_isLittleO ..

theorem hasDerivWithinAt_iff_tendsto :
    HasDerivWithinAt f f' s x â†”
      Tendsto (fun x' => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - (x' - x) â€¢ f'â€–) (ğ“[s] x) (ğ“ 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem hasDerivAt_iff_isLittleO :
    HasDerivAt f f' x â†” (fun x' : ğ•œ => f x' - f x - (x' - x) â€¢ f') =o[ğ“ x] fun x' => x' - x :=
  hasFDerivAtFilter_iff_isLittleO ..

theorem hasDerivAt_iff_tendsto :
    HasDerivAt f f' x â†” Tendsto (fun x' => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - (x' - x) â€¢ f'â€–) (ğ“ x) (ğ“ 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem HasDerivAtFilter.isBigO_sub (h : HasDerivAtFilter f f' x L) :
    (fun x' => f x' - f x) =O[L] fun x' => x' - x :=
  HasFDerivAtFilter.isBigO_sub h

nonrec theorem HasDerivAtFilter.isBigO_sub_rev (hf : HasDerivAtFilter f f' x L) (hf' : f' â‰  0) :
    (fun x' => x' - x) =O[L] fun x' => f x' - f x :=
  suffices AntilipschitzWith â€–f'â€–â‚Šâ»Â¹ (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') from hf.isBigO_sub_rev this
  AddMonoidHomClass.antilipschitz_of_bound (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') fun x => by
    simp [norm_smul, â† div_eq_inv_mul, mul_div_cancel_rightâ‚€ _ (mt norm_eq_zero.1 hf')]

theorem HasStrictDerivAt.hasDerivAt (h : HasStrictDerivAt f f' x) : HasDerivAt f f' x :=
  h.hasFDerivAt

theorem hasDerivWithinAt_congr_set' {s t : Set ğ•œ} (y : ğ•œ) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :
    HasDerivWithinAt f f' s x â†” HasDerivWithinAt f f' t x :=
  hasFDerivWithinAt_congr_set' y h

theorem hasDerivWithinAt_congr_set {s t : Set ğ•œ} (h : s =á¶ [ğ“ x] t) :
    HasDerivWithinAt f f' s x â†” HasDerivWithinAt f f' t x :=
  hasFDerivWithinAt_congr_set h

alias âŸ¨HasDerivWithinAt.congr_set, _âŸ© := hasDerivWithinAt_congr_set

@[simp]
theorem hasDerivWithinAt_diff_singleton :
    HasDerivWithinAt f f' (s \ {x}) x â†” HasDerivWithinAt f f' s x :=
  hasFDerivWithinAt_diff_singleton _

@[simp]
theorem hasDerivWithinAt_Ioi_iff_Ici [PartialOrder ğ•œ] :
    HasDerivWithinAt f f' (Ioi x) x â†” HasDerivWithinAt f f' (Ici x) x := by
  rw [â† Ici_diff_left, hasDerivWithinAt_diff_singleton]

alias âŸ¨HasDerivWithinAt.Ici_of_Ioi, HasDerivWithinAt.Ioi_of_IciâŸ© := hasDerivWithinAt_Ioi_iff_Ici

@[simp]
theorem hasDerivWithinAt_Iio_iff_Iic [PartialOrder ğ•œ] :
    HasDerivWithinAt f f' (Iio x) x â†” HasDerivWithinAt f f' (Iic x) x := by
  rw [â† Iic_diff_right, hasDerivWithinAt_diff_singleton]

alias âŸ¨HasDerivWithinAt.Iic_of_Iio, HasDerivWithinAt.Iio_of_IicâŸ© := hasDerivWithinAt_Iio_iff_Iic

theorem HasDerivWithinAt.Ioi_iff_Ioo [LinearOrder ğ•œ] [OrderClosedTopology ğ•œ] {x y : ğ•œ} (h : x < y) :
    HasDerivWithinAt f f' (Ioo x y) x â†” HasDerivWithinAt f f' (Ioi x) x :=
  hasFDerivWithinAt_inter <| Iio_mem_nhds h

alias âŸ¨HasDerivWithinAt.Ioi_of_Ioo, HasDerivWithinAt.Ioo_of_IoiâŸ© := HasDerivWithinAt.Ioi_iff_Ioo

theorem hasDerivAt_iff_isLittleO_nhds_zero :
    HasDerivAt f f' x â†” (fun h => f (x + h) - f x - h â€¢ f') =o[ğ“ 0] fun h => h :=
  hasFDerivAt_iff_isLittleO_nhds_zero

theorem HasDerivAtFilter.mono (h : HasDerivAtFilter f f' x Lâ‚‚) (hst : Lâ‚ â‰¤ Lâ‚‚) :
    HasDerivAtFilter f f' x Lâ‚ :=
  HasFDerivAtFilter.mono h hst

theorem HasDerivWithinAt.mono (h : HasDerivWithinAt f f' t x) (hst : s âŠ† t) :
    HasDerivWithinAt f f' s x :=
  HasFDerivWithinAt.mono h hst

theorem HasDerivWithinAt.mono_of_mem_nhdsWithin (h : HasDerivWithinAt f f' t x) (hst : t âˆˆ ğ“[s] x) :
    HasDerivWithinAt f f' s x :=
  HasFDerivWithinAt.mono_of_mem_nhdsWithin h hst

@[deprecated (since := "2024-10-31")]
alias HasDerivWithinAt.mono_of_mem := HasDerivWithinAt.mono_of_mem_nhdsWithin

theorem HasDerivAt.hasDerivAtFilter (h : HasDerivAt f f' x) (hL : L â‰¤ ğ“ x) :
    HasDerivAtFilter f f' x L :=
  HasFDerivAt.hasFDerivAtFilter h hL

theorem HasDerivAt.hasDerivWithinAt (h : HasDerivAt f f' x) : HasDerivWithinAt f f' s x :=
  HasFDerivAt.hasFDerivWithinAt h

theorem HasDerivWithinAt.differentiableWithinAt (h : HasDerivWithinAt f f' s x) :
    DifferentiableWithinAt ğ•œ f s x :=
  HasFDerivWithinAt.differentiableWithinAt h

theorem HasDerivAt.differentiableAt (h : HasDerivAt f f' x) : DifferentiableAt ğ•œ f x :=
  HasFDerivAt.differentiableAt h

@[simp]
theorem hasDerivWithinAt_univ : HasDerivWithinAt f f' univ x â†” HasDerivAt f f' x :=
  hasFDerivWithinAt_univ

theorem HasDerivAt.unique (hâ‚€ : HasDerivAt f fâ‚€' x) (hâ‚ : HasDerivAt f fâ‚' x) : fâ‚€' = fâ‚' :=
  smulRight_one_eq_iff.mp <| hâ‚€.hasFDerivAt.unique hâ‚

theorem hasDerivWithinAt_inter' (h : t âˆˆ ğ“[s] x) :
    HasDerivWithinAt f f' (s âˆ© t) x â†” HasDerivWithinAt f f' s x :=
  hasFDerivWithinAt_inter' h

theorem hasDerivWithinAt_inter (h : t âˆˆ ğ“ x) :
    HasDerivWithinAt f f' (s âˆ© t) x â†” HasDerivWithinAt f f' s x :=
  hasFDerivWithinAt_inter h

theorem HasDerivWithinAt.union (hs : HasDerivWithinAt f f' s x) (ht : HasDerivWithinAt f f' t x) :
    HasDerivWithinAt f f' (s âˆª t) x :=
  hs.hasFDerivWithinAt.union ht.hasFDerivWithinAt

theorem HasDerivWithinAt.hasDerivAt (h : HasDerivWithinAt f f' s x) (hs : s âˆˆ ğ“ x) :
    HasDerivAt f f' x :=
  HasFDerivWithinAt.hasFDerivAt h hs

theorem DifferentiableWithinAt.hasDerivWithinAt (h : DifferentiableWithinAt ğ•œ f s x) :
    HasDerivWithinAt f (derivWithin f s x) s x :=
  h.hasFDerivWithinAt.hasDerivWithinAt

theorem DifferentiableAt.hasDerivAt (h : DifferentiableAt ğ•œ f x) : HasDerivAt f (deriv f x) x :=
  h.hasFDerivAt.hasDerivAt

@[simp]
theorem hasDerivAt_deriv_iff : HasDerivAt f (deriv f x) x â†” DifferentiableAt ğ•œ f x :=
  âŸ¨fun h => h.differentiableAt, fun h => h.hasDerivAtâŸ©

@[simp]
theorem hasDerivWithinAt_derivWithin_iff :
    HasDerivWithinAt f (derivWithin f s x) s x â†” DifferentiableWithinAt ğ•œ f s x :=
  âŸ¨fun h => h.differentiableWithinAt, fun h => h.hasDerivWithinAtâŸ©

theorem DifferentiableOn.hasDerivAt (h : DifferentiableOn ğ•œ f s) (hs : s âˆˆ ğ“ x) :
    HasDerivAt f (deriv f x) x :=
  (h.hasFDerivAt hs).hasDerivAt

theorem HasDerivAt.deriv (h : HasDerivAt f f' x) : deriv f x = f' :=
  h.differentiableAt.hasDerivAt.unique h

theorem deriv_eq {f' : ğ•œ â†’ F} (h : âˆ€ x, HasDerivAt f (f' x) x) : deriv f = f' :=
  funext fun x => (h x).deriv

theorem HasDerivWithinAt.derivWithin (h : HasDerivWithinAt f f' s x)
    (hxs : UniqueDiffWithinAt ğ•œ s x) : derivWithin f s x = f' :=
  hxs.eq_deriv _ h.differentiableWithinAt.hasDerivWithinAt h

theorem fderivWithin_derivWithin : (fderivWithin ğ•œ f s x : ğ•œ â†’ F) 1 = derivWithin f s x :=
  rfl

theorem derivWithin_fderivWithin :
    smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (derivWithin f s x) = fderivWithin ğ•œ f s x := by simp [derivWithin]

theorem norm_derivWithin_eq_norm_fderivWithin : â€–derivWithin f s xâ€– = â€–fderivWithin ğ•œ f s xâ€– := by
  simp [â† derivWithin_fderivWithin]

theorem fderiv_deriv : (fderiv ğ•œ f x : ğ•œ â†’ F) 1 = deriv f x :=
  rfl

@[simp]
theorem fderiv_eq_smul_deriv (y : ğ•œ) : (fderiv ğ•œ f x : ğ•œ â†’ F) y = y â€¢ deriv f x := by
  rw [â† fderiv_deriv, â† ContinuousLinearMap.map_smul]
  simp only [smul_eq_mul, mul_one]

theorem deriv_fderiv : smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (deriv f x) = fderiv ğ•œ f x := by
  simp only [deriv, ContinuousLinearMap.smulRight_one_one]

lemma fderiv_eq_deriv_mul {f : ğ•œ â†’ ğ•œ} {x y : ğ•œ} : (fderiv ğ•œ f x : ğ•œ â†’ ğ•œ) y = (deriv f x) * y := by
  simp [mul_comm]

theorem norm_deriv_eq_norm_fderiv : â€–deriv f xâ€– = â€–fderiv ğ•œ f xâ€– := by
  simp [â† deriv_fderiv]

theorem DifferentiableAt.derivWithin (h : DifferentiableAt ğ•œ f x) (hxs : UniqueDiffWithinAt ğ•œ s x) :
    derivWithin f s x = deriv f x := by
  unfold _root_.derivWithin deriv
  rw [h.fderivWithin hxs]

theorem HasDerivWithinAt.deriv_eq_zero (hd : HasDerivWithinAt f 0 s x)
    (H : UniqueDiffWithinAt ğ•œ s x) : deriv f x = 0 :=
  (em' (DifferentiableAt ğ•œ f x)).elim deriv_zero_of_not_differentiableAt fun h =>
    H.eq_deriv _ h.hasDerivAt.hasDerivWithinAt hd

theorem derivWithin_of_mem_nhdsWithin (st : t âˆˆ ğ“[s] x) (ht : UniqueDiffWithinAt ğ•œ s x)
    (h : DifferentiableWithinAt ğ•œ f t x) : derivWithin f s x = derivWithin f t x :=
  ((DifferentiableWithinAt.hasDerivWithinAt h).mono_of_mem_nhdsWithin st).derivWithin ht

@[deprecated (since := "2024-10-31")] alias derivWithin_of_mem := derivWithin_of_mem_nhdsWithin

theorem derivWithin_subset (st : s âŠ† t) (ht : UniqueDiffWithinAt ğ•œ s x)
    (h : DifferentiableWithinAt ğ•œ f t x) : derivWithin f s x = derivWithin f t x :=
  ((DifferentiableWithinAt.hasDerivWithinAt h).mono st).derivWithin ht

theorem derivWithin_congr_set' (y : ğ•œ) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :
    derivWithin f s x = derivWithin f t x := by simp only [derivWithin, fderivWithin_congr_set' y h]

theorem derivWithin_congr_set (h : s =á¶ [ğ“ x] t) : derivWithin f s x = derivWithin f t x := by
  simp only [derivWithin, fderivWithin_congr_set h]

@[simp]
theorem derivWithin_univ : derivWithin f univ = deriv f := by
  ext
  unfold derivWithin deriv
  rw [fderivWithin_univ]

theorem derivWithin_inter (ht : t âˆˆ ğ“ x) : derivWithin f (s âˆ© t) x = derivWithin f s x := by
  unfold derivWithin
  rw [fderivWithin_inter ht]

theorem derivWithin_of_mem_nhds (h : s âˆˆ ğ“ x) : derivWithin f s x = deriv f x := by
  simp only [derivWithin, deriv, fderivWithin_of_mem_nhds h]

theorem derivWithin_of_isOpen (hs : IsOpen s) (hx : x âˆˆ s) : derivWithin f s x = deriv f x :=
  derivWithin_of_mem_nhds (hs.mem_nhds hx)

lemma deriv_eqOn {f' : ğ•œ â†’ F} (hs : IsOpen s) (hf' : âˆ€ x âˆˆ s, HasDerivWithinAt f (f' x) s x) :
    s.EqOn (deriv f) f' := fun x hx â†¦ by
  rw [â† derivWithin_of_isOpen hs hx, (hf' _ hx).derivWithin <| hs.uniqueDiffWithinAt hx]

theorem deriv_mem_iff {f : ğ•œ â†’ F} {s : Set F} {x : ğ•œ} :
    deriv f x âˆˆ s â†”
      DifferentiableAt ğ•œ f x âˆ§ deriv f x âˆˆ s âˆ¨ Â¬DifferentiableAt ğ•œ f x âˆ§ (0 : F) âˆˆ s := by
  by_cases hx : DifferentiableAt ğ•œ f x <;> simp [deriv_zero_of_not_differentiableAt, *]

theorem derivWithin_mem_iff {f : ğ•œ â†’ F} {t : Set ğ•œ} {s : Set F} {x : ğ•œ} :
    derivWithin f t x âˆˆ s â†”
      DifferentiableWithinAt ğ•œ f t x âˆ§ derivWithin f t x âˆˆ s âˆ¨
        Â¬DifferentiableWithinAt ğ•œ f t x âˆ§ (0 : F) âˆˆ s := by
  by_cases hx : DifferentiableWithinAt ğ•œ f t x <;>
    simp [derivWithin_zero_of_not_differentiableWithinAt, *]

theorem differentiableWithinAt_Ioi_iff_Ici [PartialOrder ğ•œ] :
    DifferentiableWithinAt ğ•œ f (Ioi x) x â†” DifferentiableWithinAt ğ•œ f (Ici x) x :=
  âŸ¨fun h => h.hasDerivWithinAt.Ici_of_Ioi.differentiableWithinAt, fun h =>
    h.hasDerivWithinAt.Ioi_of_Ici.differentiableWithinAtâŸ©

-- Golfed while splitting the file
theorem derivWithin_Ioi_eq_Ici {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] (f : â„ â†’ E)
    (x : â„) : derivWithin f (Ioi x) x = derivWithin f (Ici x) x := by
  by_cases H : DifferentiableWithinAt â„ f (Ioi x) x
  Â· have A := H.hasDerivWithinAt.Ici_of_Ioi
    have B := (differentiableWithinAt_Ioi_iff_Ici.1 H).hasDerivWithinAt
    simpa using (uniqueDiffOn_Ici x).eq left_mem_Ici A B
  Â· rw [derivWithin_zero_of_not_differentiableWithinAt H,
      derivWithin_zero_of_not_differentiableWithinAt]
    rwa [differentiableWithinAt_Ioi_iff_Ici] at H

section congr

/-! ### Congruence properties of derivatives -/

theorem Filter.EventuallyEq.hasDerivAtFilter_iff (hâ‚€ : fâ‚€ =á¶ [L] fâ‚) (hx : fâ‚€ x = fâ‚ x)
    (hâ‚ : fâ‚€' = fâ‚') : HasDerivAtFilter fâ‚€ fâ‚€' x L â†” HasDerivAtFilter fâ‚ fâ‚' x L :=
  hâ‚€.hasFDerivAtFilter_iff hx (by simp [hâ‚])

theorem HasDerivAtFilter.congr_of_eventuallyEq (h : HasDerivAtFilter f f' x L) (hL : fâ‚ =á¶ [L] f)
    (hx : fâ‚ x = f x) : HasDerivAtFilter fâ‚ f' x L := by rwa [hL.hasDerivAtFilter_iff hx rfl]

theorem HasDerivWithinAt.congr_mono (h : HasDerivWithinAt f f' s x) (ht : âˆ€ x âˆˆ t, fâ‚ x = f x)
    (hx : fâ‚ x = f x) (hâ‚ : t âŠ† s) : HasDerivWithinAt fâ‚ f' t x :=
  HasFDerivWithinAt.congr_mono h ht hx hâ‚

theorem HasDerivWithinAt.congr (h : HasDerivWithinAt f f' s x) (hs : âˆ€ x âˆˆ s, fâ‚ x = f x)
    (hx : fâ‚ x = f x) : HasDerivWithinAt fâ‚ f' s x :=
  h.congr_mono hs hx (Subset.refl _)

theorem HasDerivWithinAt.congr_of_mem (h : HasDerivWithinAt f f' s x) (hs : âˆ€ x âˆˆ s, fâ‚ x = f x)
    (hx : x âˆˆ s) : HasDerivWithinAt fâ‚ f' s x :=
  h.congr hs (hs _ hx)

theorem HasDerivWithinAt.congr_of_eventuallyEq (h : HasDerivWithinAt f f' s x)
    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) : HasDerivWithinAt fâ‚ f' s x :=
  HasDerivAtFilter.congr_of_eventuallyEq h hâ‚ hx

theorem Filter.EventuallyEq.hasDerivWithinAt_iff (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :
    HasDerivWithinAt fâ‚ f' s x â†” HasDerivWithinAt f f' s x :=
  âŸ¨fun h' â†¦ h'.congr_of_eventuallyEq hâ‚.symm hx.symm, fun h' â†¦ h'.congr_of_eventuallyEq hâ‚ hxâŸ©

theorem HasDerivWithinAt.congr_of_eventuallyEq_of_mem (h : HasDerivWithinAt f f' s x)
    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) : HasDerivWithinAt fâ‚ f' s x :=
  h.congr_of_eventuallyEq hâ‚ (hâ‚.eq_of_nhdsWithin hx)

theorem Filter.EventuallyEq.hasDerivWithinAt_iff_of_mem (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) :
    HasDerivWithinAt fâ‚ f' s x â†” HasDerivWithinAt f f' s x :=
  âŸ¨fun h' â†¦ h'.congr_of_eventuallyEq_of_mem hâ‚.symm hx,
  fun h' â†¦ h'.congr_of_eventuallyEq_of_mem hâ‚ hxâŸ©

theorem HasStrictDerivAt.congr_deriv (h : HasStrictDerivAt f f' x) (h' : f' = g') :
    HasStrictDerivAt f g' x :=
  h.congr_fderiv <| congr_arg _ h'

theorem HasDerivAt.congr_deriv (h : HasDerivAt f f' x) (h' : f' = g') : HasDerivAt f g' x :=
  HasFDerivAt.congr_fderiv h <| congr_arg _ h'

theorem HasDerivWithinAt.congr_deriv (h : HasDerivWithinAt f f' s x) (h' : f' = g') :
    HasDerivWithinAt f g' s x :=
  HasFDerivWithinAt.congr_fderiv h <| congr_arg _ h'

theorem HasDerivAt.congr_of_eventuallyEq (h : HasDerivAt f f' x) (hâ‚ : fâ‚ =á¶ [ğ“ x] f) :
    HasDerivAt fâ‚ f' x :=
  HasDerivAtFilter.congr_of_eventuallyEq h hâ‚ (mem_of_mem_nhds hâ‚ :)

theorem Filter.EventuallyEq.hasDerivAt_iff (h : fâ‚€ =á¶ [ğ“ x] fâ‚) :
    HasDerivAt fâ‚€ f' x â†” HasDerivAt fâ‚ f' x :=
  âŸ¨fun h' â†¦ h'.congr_of_eventuallyEq h.symm, fun h' â†¦ h'.congr_of_eventuallyEq hâŸ©

theorem Filter.EventuallyEq.derivWithin_eq (hs : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :
    derivWithin fâ‚ s x = derivWithin f s x := by
  unfold derivWithin
  rw [hs.fderivWithin_eq hx]

theorem derivWithin_congr (hs : EqOn fâ‚ f s) (hx : fâ‚ x = f x) :
    derivWithin fâ‚ s x = derivWithin f s x := by
  unfold derivWithin
  rw [fderivWithin_congr hs hx]

theorem Filter.EventuallyEq.deriv_eq (hL : fâ‚ =á¶ [ğ“ x] f) : deriv fâ‚ x = deriv f x := by
  unfold deriv
  rwa [Filter.EventuallyEq.fderiv_eq]

protected theorem Filter.EventuallyEq.deriv (h : fâ‚ =á¶ [ğ“ x] f) : deriv fâ‚ =á¶ [ğ“ x] deriv f :=
  h.eventuallyEq_nhds.mono fun _ h => h.deriv_eq

end congr

section id

/-! ### Derivative of the identity -/

variable (s x L)

theorem hasDerivAtFilter_id : HasDerivAtFilter id 1 x L :=
  (hasFDerivAtFilter_id x L).hasDerivAtFilter

theorem hasDerivWithinAt_id : HasDerivWithinAt id 1 s x :=
  hasDerivAtFilter_id _ _

theorem hasDerivAt_id : HasDerivAt id 1 x :=
  hasDerivAtFilter_id _ _

theorem hasDerivAt_id' : HasDerivAt (fun x : ğ•œ => x) 1 x :=
  hasDerivAtFilter_id _ _

theorem hasStrictDerivAt_id : HasStrictDerivAt id 1 x :=
  (hasStrictFDerivAt_id x).hasStrictDerivAt

theorem deriv_id : deriv id x = 1 :=
  HasDerivAt.deriv (hasDerivAt_id x)

@[simp]
theorem deriv_id' : deriv (@id ğ•œ) = fun _ => 1 :=
  funext deriv_id

/-- Variant with `fun x => x` rather than `id` -/
@[simp]
theorem deriv_id'' : (deriv fun x : ğ•œ => x) = fun _ => 1 :=
  deriv_id'

theorem derivWithin_id (hxs : UniqueDiffWithinAt ğ•œ s x) : derivWithin id s x = 1 :=
  (hasDerivWithinAt_id x s).derivWithin hxs

/-- Variant with `fun x => x` rather than `id` -/
theorem derivWithin_id' (hxs : UniqueDiffWithinAt ğ•œ s x) : derivWithin (fun x => x) s x = 1 :=
  derivWithin_id x s hxs

end id

section Const

/-! ### Derivative of constant functions

This include the constant functions `0`, `1`, `Nat.cast n`, `Int.cast z`, and other numerals.
-/

variable (c : F) (s x L)

theorem hasDerivAtFilter_const : HasDerivAtFilter (fun _ => c) 0 x L :=
  (hasFDerivAtFilter_const c x L).hasDerivAtFilter

theorem hasDerivAtFilter_zero : HasDerivAtFilter (0 : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_one [One F] : HasDerivAtFilter (1 : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_natCast [NatCast F] (n : â„•) : HasDerivAtFilter (n : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_intCast [IntCast F] (z : â„¤) : HasDerivAtFilter (z : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_ofNat (n : â„•) [OfNat F n] : HasDerivAtFilter (ofNat(n) : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasStrictDerivAt_const : HasStrictDerivAt (fun _ => c) 0 x :=
  (hasStrictFDerivAt_const c x).hasStrictDerivAt

theorem hasStrictDerivAt_zero : HasStrictDerivAt (0 : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasStrictDerivAt_one [One F] : HasStrictDerivAt (1 : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasStrictDerivAt_natCast [NatCast F] (n : â„•) : HasStrictDerivAt (n : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasStrictDerivAt_intCast [IntCast F] (z : â„¤) : HasStrictDerivAt (z : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem HasStrictDerivAt_ofNat (n : â„•) [OfNat F n] : HasStrictDerivAt (ofNat(n) : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasDerivWithinAt_const : HasDerivWithinAt (fun _ => c) 0 s x :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivWithinAt_zero : HasDerivWithinAt (0 : ğ•œ â†’ F) 0 s x :=
  hasDerivAtFilter_zero _ _

theorem hasDerivWithinAt_one [One F] : HasDerivWithinAt (1 : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivWithinAt_natCast [NatCast F] (n : â„•) : HasDerivWithinAt (n : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivWithinAt_intCast [IntCast F] (z : â„¤) : HasDerivWithinAt (z : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivWithinAt_ofNat (n : â„•) [OfNat F n] : HasDerivWithinAt (ofNat(n) : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivAt_const : HasDerivAt (fun _ => c) 0 x :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAt_zero : HasDerivAt (0 : ğ•œ â†’ F) 0 x :=
  hasDerivAtFilter_zero _ _

theorem hasDerivAt_one [One F] : HasDerivAt (1 : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem hasDerivAt_natCast [NatCast F] (n : â„•) : HasDerivAt (n : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem hasDerivAt_intCast [IntCast F] (z : â„¤) : HasDerivAt (z : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem hasDerivAt_ofNat (n : â„•) [OfNat F n] : HasDerivAt (ofNat(n) : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem deriv_const : deriv (fun _ => c) x = 0 :=
  HasDerivAt.deriv (hasDerivAt_const x c)

@[simp]
theorem deriv_const' : (deriv fun _ : ğ•œ => c) = fun _ => 0 :=
  funext fun x => deriv_const x c

@[simp]
theorem deriv_zero : deriv (0 : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp]
theorem deriv_one [One F] : deriv (1 : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp]
theorem deriv_natCast [NatCast F] (n : â„•) : deriv (n : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp]
theorem deriv_intCast [IntCast F] (z : â„¤) : deriv (z : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp low]
theorem deriv_ofNat (n : â„•) [OfNat F n] : deriv (ofNat(n) : ğ•œ â†’ F) = 0 :=
  funext fun _ => deriv_const _ _

@[simp]
theorem derivWithin_const : derivWithin (fun _ => c) s = 0 := by
  ext; simp [derivWithin]

@[simp]
theorem derivWithin_zero : derivWithin (0 : ğ•œ â†’ F) s = 0 := derivWithin_const _ _

@[simp]
theorem derivWithin_one [One F] : derivWithin (1 : ğ•œ â†’ F) s = 0 := derivWithin_const _ _

@[simp]
theorem derivWithin_natCast [NatCast F] (n : â„•) : derivWithin (n : ğ•œ â†’ F) s = 0 :=
  derivWithin_const _ _

@[simp]
theorem derivWithin_intCast [IntCast F] (z : â„¤) : derivWithin (z : ğ•œ â†’ F) s = 0 :=
  derivWithin_const _ _

@[simp low]
theorem derivWithin_ofNat (n : â„•) [OfNat F n] : derivWithin (ofNat(n) : ğ•œ â†’ F) s = 0 :=
  derivWithin_const _ _

end Const

section Continuous

/-! ### Continuity of a function admitting a derivative -/

nonrec theorem HasDerivAtFilter.tendsto_nhds (hL : L â‰¤ ğ“ x) (h : HasDerivAtFilter f f' x L) :
    Tendsto f L (ğ“ (f x)) :=
  h.tendsto_nhds hL

theorem HasDerivWithinAt.continuousWithinAt (h : HasDerivWithinAt f f' s x) :
    ContinuousWithinAt f s x :=
  HasDerivAtFilter.tendsto_nhds inf_le_left h

theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=
  HasDerivAtFilter.tendsto_nhds le_rfl h

protected theorem HasDerivAt.continuousOn {f f' : ğ•œ â†’ F} (hderiv : âˆ€ x âˆˆ s, HasDerivAt f (f' x) x) :
    ContinuousOn f s := fun x hx => (hderiv x hx).continuousAt.continuousWithinAt

end Continuous

section MeanValue

/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. This version
only assumes that `â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–` in a neighborhood of `x`. -/
theorem HasDerivAt.le_of_lip' {f : ğ•œ â†’ F} {f' : F} {xâ‚€ : ğ•œ} (hf : HasDerivAt f f' xâ‚€)
    {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  x in ğ“ xâ‚€, â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–) :
    â€–f'â€– â‰¤ C := by
  simpa using HasFDerivAt.le_of_lip' hf.hasFDerivAt hCâ‚€ hlip

/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. -/
theorem HasDerivAt.le_of_lipschitzOn {f : ğ•œ â†’ F} {f' : F} {xâ‚€ : ğ•œ} (hf : HasDerivAt f f' xâ‚€)
    {s : Set ğ•œ} (hs : s âˆˆ ğ“ xâ‚€) {C : â„â‰¥0} (hlip : LipschitzOnWith C f s) : â€–f'â€– â‰¤ C := by
  simpa using HasFDerivAt.le_of_lipschitzOn hf.hasFDerivAt hs hlip

/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz
then its derivative at `xâ‚€` has norm bounded by `C`. -/
theorem HasDerivAt.le_of_lipschitz {f : ğ•œ â†’ F} {f' : F} {xâ‚€ : ğ•œ} (hf : HasDerivAt f f' xâ‚€)
    {C : â„â‰¥0} (hlip : LipschitzWith C f) : â€–f'â€– â‰¤ C := by
  simpa using HasFDerivAt.le_of_lipschitz hf.hasFDerivAt hlip

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. This version
only assumes that `â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–` in a neighborhood of `x`. -/
theorem norm_deriv_le_of_lip' {f : ğ•œ â†’ F} {xâ‚€ : ğ•œ}
    {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  x in ğ“ xâ‚€, â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–) :
    â€–deriv f xâ‚€â€– â‰¤ C := by
  simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lip' ğ•œ hCâ‚€ hlip

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`.
Version using `deriv`. -/
theorem norm_deriv_le_of_lipschitzOn {f : ğ•œ â†’ F} {xâ‚€ : ğ•œ} {s : Set ğ•œ} (hs : s âˆˆ ğ“ xâ‚€)
    {C : â„â‰¥0} (hlip : LipschitzOnWith C f s) : â€–deriv f xâ‚€â€– â‰¤ C := by
  simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lipschitzOn ğ•œ hs hlip

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz then
its derivative at `xâ‚€` has norm bounded by `C`.
Version using `deriv`. -/
theorem norm_deriv_le_of_lipschitz {f : ğ•œ â†’ F} {xâ‚€ : ğ•œ}
    {C : â„â‰¥0} (hlip : LipschitzWith C f) : â€–deriv f xâ‚€â€– â‰¤ C := by
  simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lipschitz ğ•œ hlip

end MeanValue

-- END Mathlib.Analysis.Calculus.Deriv.Basic --

-- BEGIN Mathlib.Analysis.Calculus.FDeriv.Mul --
/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, SÃ©bastien GouÃ«zel, Yury Kudryashov
-/
import Mathlib.Analysis.Analytic.Constructions
import Mathlib.Analysis.Calculus.FDeriv.Analytic
import Mathlib.Analysis.Calculus.FDeriv.Bilinear

/-!
# Multiplicative operations on derivatives

For detailed documentation of the FrÃ©chet derivative,
see the module docstring of `Mathlib/Analysis/Calculus/FDeriv/Basic.lean`.

This file contains the usual formulas (and existence assertions) for the derivative of

* multiplication of a function by a scalar function
* product of finitely many scalar functions
* taking the pointwise multiplicative inverse (i.e. `Inv.inv` or `Ring.inverse`) of a function
-/


open Asymptotics ContinuousLinearMap Topology

section

variable {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {f : E â†’ F}
variable {f' : E â†’L[ğ•œ] F}
variable {x : E}
variable {s : Set E}

section CLMCompApply

/-! ### Derivative of the pointwise composition/application of continuous linear maps -/


variable {H : Type*} [NormedAddCommGroup H] [NormedSpace ğ•œ H] {c : E â†’ G â†’L[ğ•œ] H}
  {c' : E â†’L[ğ•œ] G â†’L[ğ•œ] H} {d : E â†’ F â†’L[ğ•œ] G} {d' : E â†’L[ğ•œ] F â†’L[ğ•œ] G} {u : E â†’ G} {u' : E â†’L[ğ•œ] G}

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  split proof term into steps to solve unification issues. -/
@[fun_prop]
theorem HasStrictFDerivAt.clm_comp (hc : HasStrictFDerivAt c c' x) (hd : HasStrictFDerivAt d d' x) :
    HasStrictFDerivAt (fun y => (c y).comp (d y))
      ((compL ğ•œ F G H (c x)).comp d' + ((compL ğ•œ F G H).flip (d x)).comp c') x := by
  have := isBoundedBilinearMap_comp.hasStrictFDerivAt (c x, d x)
  have := this.comp x (hc.prodMk hd)
  exact this

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivWithinAt.clm_comp (hc : HasFDerivWithinAt c c' s x)
    (hd : HasFDerivWithinAt d d' s x) :
    HasFDerivWithinAt (fun y => (c y).comp (d y))
      ((compL ğ•œ F G H (c x)).comp d' + ((compL ğ•œ F G H).flip (d x)).comp c') s x := by
  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp_hasFDerivWithinAt x (hc.prodMk hd)

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivAt.clm_comp (hc : HasFDerivAt c c' x) (hd : HasFDerivAt d d' x) :
    HasFDerivAt (fun y => (c y).comp (d y))
      ((compL ğ•œ F G H (c x)).comp d' + ((compL ğ•œ F G H).flip (d x)).comp c') x := by
  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp x <| hc.prodMk hd

@[fun_prop]
theorem DifferentiableWithinAt.clm_comp (hc : DifferentiableWithinAt ğ•œ c s x)
    (hd : DifferentiableWithinAt ğ•œ d s x) :
    DifferentiableWithinAt ğ•œ (fun y => (c y).comp (d y)) s x :=
  (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).differentiableWithinAt

@[fun_prop]
theorem DifferentiableAt.clm_comp (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :
    DifferentiableAt ğ•œ (fun y => (c y).comp (d y)) x :=
  (hc.hasFDerivAt.clm_comp hd.hasFDerivAt).differentiableAt

@[fun_prop]
theorem DifferentiableOn.clm_comp (hc : DifferentiableOn ğ•œ c s) (hd : DifferentiableOn ğ•œ d s) :
    DifferentiableOn ğ•œ (fun y => (c y).comp (d y)) s := fun x hx => (hc x hx).clm_comp (hd x hx)

@[fun_prop]
theorem Differentiable.clm_comp (hc : Differentiable ğ•œ c) (hd : Differentiable ğ•œ d) :
    Differentiable ğ•œ fun y => (c y).comp (d y) := fun x => (hc x).clm_comp (hd x)

theorem fderivWithin_clm_comp (hxs : UniqueDiffWithinAt ğ•œ s x) (hc : DifferentiableWithinAt ğ•œ c s x)
    (hd : DifferentiableWithinAt ğ•œ d s x) :
    fderivWithin ğ•œ (fun y => (c y).comp (d y)) s x =
      (compL ğ•œ F G H (c x)).comp (fderivWithin ğ•œ d s x) +
        ((compL ğ•œ F G H).flip (d x)).comp (fderivWithin ğ•œ c s x) :=
  (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).fderivWithin hxs

theorem fderiv_clm_comp (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :
    fderiv ğ•œ (fun y => (c y).comp (d y)) x =
      (compL ğ•œ F G H (c x)).comp (fderiv ğ•œ d x) +
        ((compL ğ•œ F G H).flip (d x)).comp (fderiv ğ•œ c x) :=
  (hc.hasFDerivAt.clm_comp hd.hasFDerivAt).fderiv

@[fun_prop]
theorem HasStrictFDerivAt.clm_apply (hc : HasStrictFDerivAt c c' x)
    (hu : HasStrictFDerivAt u u' x) :
    HasStrictFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x :=
  (isBoundedBilinearMap_apply.hasStrictFDerivAt (c x, u x)).comp x (hc.prodMk hu)

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivWithinAt.clm_apply (hc : HasFDerivWithinAt c c' s x)
    (hu : HasFDerivWithinAt u u' s x) :
    HasFDerivWithinAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) s x := by
  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp_hasFDerivWithinAt x
    (hc.prodMk hu)

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivAt.clm_apply (hc : HasFDerivAt c c' x) (hu : HasFDerivAt u u' x) :
    HasFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x := by
  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp x (hc.prodMk hu)

@[fun_prop]
theorem DifferentiableWithinAt.clm_apply (hc : DifferentiableWithinAt ğ•œ c s x)
    (hu : DifferentiableWithinAt ğ•œ u s x) : DifferentiableWithinAt ğ•œ (fun y => (c y) (u y)) s x :=
  (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).differentiableWithinAt

@[fun_prop]
theorem DifferentiableAt.clm_apply (hc : DifferentiableAt ğ•œ c x) (hu : DifferentiableAt ğ•œ u x) :
    DifferentiableAt ğ•œ (fun y => (c y) (u y)) x :=
  (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).differentiableAt

@[fun_prop]
theorem DifferentiableOn.clm_apply (hc : DifferentiableOn ğ•œ c s) (hu : DifferentiableOn ğ•œ u s) :
    DifferentiableOn ğ•œ (fun y => (c y) (u y)) s := fun x hx => (hc x hx).clm_apply (hu x hx)

@[fun_prop]
theorem Differentiable.clm_apply (hc : Differentiable ğ•œ c) (hu : Differentiable ğ•œ u) :
    Differentiable ğ•œ fun y => (c y) (u y) := fun x => (hc x).clm_apply (hu x)

theorem fderivWithin_clm_apply (hxs : UniqueDiffWithinAt ğ•œ s x)
    (hc : DifferentiableWithinAt ğ•œ c s x) (hu : DifferentiableWithinAt ğ•œ u s x) :
    fderivWithin ğ•œ (fun y => (c y) (u y)) s x =
      (c x).comp (fderivWithin ğ•œ u s x) + (fderivWithin ğ•œ c s x).flip (u x) :=
  (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).fderivWithin hxs

theorem fderiv_clm_apply (hc : DifferentiableAt ğ•œ c x) (hu : DifferentiableAt ğ•œ u x) :
    fderiv ğ•œ (fun y => (c y) (u y)) x = (c x).comp (fderiv ğ•œ u x) + (fderiv ğ•œ c x).flip (u x) :=
  (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).fderiv

end CLMCompApply

section ContinuousMultilinearApplyConst

/-! ### Derivative of the application of continuous multilinear maps to a constant -/

variable {Î¹ : Type*} [Fintype Î¹]
  {M : Î¹ â†’ Type*} [âˆ€ i, NormedAddCommGroup (M i)] [âˆ€ i, NormedSpace ğ•œ (M i)]
  {H : Type*} [NormedAddCommGroup H] [NormedSpace ğ•œ H]
  {c : E â†’ ContinuousMultilinearMap ğ•œ M H}
  {c' : E â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ M H}

@[fun_prop]
theorem HasStrictFDerivAt.continuousMultilinear_apply_const (hc : HasStrictFDerivAt c c' x)
    (u : âˆ€ i, M i) : HasStrictFDerivAt (fun y â†¦ (c y) u) (c'.flipMultilinear u) x :=
  (ContinuousMultilinearMap.apply ğ•œ M H u).hasStrictFDerivAt.comp x hc

@[fun_prop]
theorem HasFDerivWithinAt.continuousMultilinear_apply_const (hc : HasFDerivWithinAt c c' s x)
    (u : âˆ€ i, M i) :
    HasFDerivWithinAt (fun y â†¦ (c y) u) (c'.flipMultilinear u) s x :=
  (ContinuousMultilinearMap.apply ğ•œ M H u).hasFDerivAt.comp_hasFDerivWithinAt x hc

@[fun_prop]
theorem HasFDerivAt.continuousMultilinear_apply_const (hc : HasFDerivAt c c' x) (u : âˆ€ i, M i) :
    HasFDerivAt (fun y â†¦ (c y) u) (c'.flipMultilinear u) x :=
  (ContinuousMultilinearMap.apply ğ•œ M H u).hasFDerivAt.comp x hc

@[fun_prop]
theorem DifferentiableWithinAt.continuousMultilinear_apply_const
    (hc : DifferentiableWithinAt ğ•œ c s x) (u : âˆ€ i, M i) :
    DifferentiableWithinAt ğ•œ (fun y â†¦ (c y) u) s x :=
  (hc.hasFDerivWithinAt.continuousMultilinear_apply_const u).differentiableWithinAt

@[fun_prop]
theorem DifferentiableAt.continuousMultilinear_apply_const (hc : DifferentiableAt ğ•œ c x)
    (u : âˆ€ i, M i) :
    DifferentiableAt ğ•œ (fun y â†¦ (c y) u) x :=
  (hc.hasFDerivAt.continuousMultilinear_apply_const u).differentiableAt

@[fun_prop]
theorem DifferentiableOn.continuousMultilinear_apply_const (hc : DifferentiableOn ğ•œ c s)
    (u : âˆ€ i, M i) : DifferentiableOn ğ•œ (fun y â†¦ (c y) u) s :=
  fun x hx â†¦ (hc x hx).continuousMultilinear_apply_const u

@[fun_prop]
theorem Differentiable.continuousMultilinear_apply_const (hc : Differentiable ğ•œ c) (u : âˆ€ i, M i) :
    Differentiable ğ•œ fun y â†¦ (c y) u := fun x â†¦ (hc x).continuousMultilinear_apply_const u

theorem fderivWithin_continuousMultilinear_apply_const (hxs : UniqueDiffWithinAt ğ•œ s x)
    (hc : DifferentiableWithinAt ğ•œ c s x) (u : âˆ€ i, M i) :
    fderivWithin ğ•œ (fun y â†¦ (c y) u) s x = ((fderivWithin ğ•œ c s x).flipMultilinear u) :=
  (hc.hasFDerivWithinAt.continuousMultilinear_apply_const u).fderivWithin hxs

theorem fderiv_continuousMultilinear_apply_const (hc : DifferentiableAt ğ•œ c x) (u : âˆ€ i, M i) :
    (fderiv ğ•œ (fun y â†¦ (c y) u) x) = (fderiv ğ•œ c x).flipMultilinear u :=
  (hc.hasFDerivAt.continuousMultilinear_apply_const u).fderiv

/-- Application of a `ContinuousMultilinearMap` to a constant commutes with `fderivWithin`. -/
theorem fderivWithin_continuousMultilinear_apply_const_apply (hxs : UniqueDiffWithinAt ğ•œ s x)
    (hc : DifferentiableWithinAt ğ•œ c s x) (u : âˆ€ i, M i) (m : E) :
    (fderivWithin ğ•œ (fun y â†¦ (c y) u) s x) m = (fderivWithin ğ•œ c s x) m u := by
  simp [fderivWithin_continuousMultilinear_apply_const hxs hc]

/-- Application of a `ContinuousMultilinearMap` to a constant commutes with `fderiv`. -/
theorem fderiv_continuousMultilinear_apply_const_apply (hc : DifferentiableAt ğ•œ c x)
    (u : âˆ€ i, M i) (m : E) :
    (fderiv ğ•œ (fun y â†¦ (c y) u) x) m = (fderiv ğ•œ c x) m u := by
  simp [fderiv_continuousMultilinear_apply_const hc]

end ContinuousMultilinearApplyConst

section SMul

/-! ### Derivative of the product of a scalar-valued function and a vector-valued function

If `c` is a differentiable scalar-valued function and `f` is a differentiable vector-valued
function, then `fun x â†¦ c x â€¢ f x` is differentiable as well. Lemmas in this section works for
function `c` taking values in the base field, as well as in a normed algebra over the base
field: e.g., they work for `c : E â†’ â„‚` and `f : E â†’ F` provided that `F` is a complex
normed vector space.
-/


variable {ğ•œ' : Type*} [NontriviallyNormedField ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] [NormedSpace ğ•œ' F]
  [IsScalarTower ğ•œ ğ•œ' F]

variable {c : E â†’ ğ•œ'} {c' : E â†’L[ğ•œ] ğ•œ'}

@[fun_prop]
theorem HasStrictFDerivAt.smul (hc : HasStrictFDerivAt c c' x) (hf : HasStrictFDerivAt f f' x) :
    HasStrictFDerivAt (fun y => c y â€¢ f y) (c x â€¢ f' + c'.smulRight (f x)) x :=
  (isBoundedBilinearMap_smul.hasStrictFDerivAt (c x, f x)).comp x <| hc.prodMk hf

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivWithinAt.smul (hc : HasFDerivWithinAt c c' s x) (hf : HasFDerivWithinAt f f' s x) :
    HasFDerivWithinAt (fun y => c y â€¢ f y) (c x â€¢ f' + c'.smulRight (f x)) s x := by
  exact (isBoundedBilinearMap_smul.hasFDerivAt (ğ•œ := ğ•œ) (c x, f x) :).comp_hasFDerivWithinAt x <|
    hc.prodMk hf

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivAt.smul (hc : HasFDerivAt c c' x) (hf : HasFDerivAt f f' x) :
    HasFDerivAt (fun y => c y â€¢ f y) (c x â€¢ f' + c'.smulRight (f x)) x := by
  exact (isBoundedBilinearMap_smul.hasFDerivAt (ğ•œ := ğ•œ) (c x, f x) :).comp x <| hc.prodMk hf

@[fun_prop]
theorem DifferentiableWithinAt.smul (hc : DifferentiableWithinAt ğ•œ c s x)
    (hf : DifferentiableWithinAt ğ•œ f s x) : DifferentiableWithinAt ğ•œ (fun y => c y â€¢ f y) s x :=
  (hc.hasFDerivWithinAt.smul hf.hasFDerivWithinAt).differentiableWithinAt

@[simp, fun_prop]
theorem DifferentiableAt.smul (hc : DifferentiableAt ğ•œ c x) (hf : DifferentiableAt ğ•œ f x) :
    DifferentiableAt ğ•œ (fun y => c y â€¢ f y) x :=
  (hc.hasFDerivAt.smul hf.hasFDerivAt).differentiableAt

@[fun_prop]
theorem DifferentiableOn.smul (hc : DifferentiableOn ğ•œ c s) (hf : DifferentiableOn ğ•œ f s) :
    DifferentiableOn ğ•œ (fun y => c y â€¢ f y) s := fun x hx => (hc x hx).smul (hf x hx)

@[simp, fun_prop]
theorem Differentiable.smul (hc : Differentiable ğ•œ c) (hf : Differentiable ğ•œ f) :
    Differentiable ğ•œ fun y => c y â€¢ f y := fun x => (hc x).smul (hf x)

theorem fderivWithin_smul (hxs : UniqueDiffWithinAt ğ•œ s x) (hc : DifferentiableWithinAt ğ•œ c s x)
    (hf : DifferentiableWithinAt ğ•œ f s x) :
    fderivWithin ğ•œ (fun y => c y â€¢ f y) s x =
      c x â€¢ fderivWithin ğ•œ f s x + (fderivWithin ğ•œ c s x).smulRight (f x) :=
  (hc.hasFDerivWithinAt.smul hf.hasFDerivWithinAt).fderivWithin hxs

theorem fderiv_smul (hc : DifferentiableAt ğ•œ c x) (hf : DifferentiableAt ğ•œ f x) :
    fderiv ğ•œ (fun y => c y â€¢ f y) x = c x â€¢ fderiv ğ•œ f x + (fderiv ğ•œ c x).smulRight (f x) :=
  (hc.hasFDerivAt.smul hf.hasFDerivAt).fderiv

@[fun_prop]
theorem HasStrictFDerivAt.smul_const (hc : HasStrictFDerivAt c c' x) (f : F) :
    HasStrictFDerivAt (fun y => c y â€¢ f) (c'.smulRight f) x := by
  simpa only [smul_zero, zero_add] using hc.smul (hasStrictFDerivAt_const f x)

@[fun_prop]
theorem HasFDerivWithinAt.smul_const (hc : HasFDerivWithinAt c c' s x) (f : F) :
    HasFDerivWithinAt (fun y => c y â€¢ f) (c'.smulRight f) s x := by
  simpa only [smul_zero, zero_add] using hc.smul (hasFDerivWithinAt_const f x s)

@[fun_prop]
theorem HasFDerivAt.smul_const (hc : HasFDerivAt c c' x) (f : F) :
    HasFDerivAt (fun y => c y â€¢ f) (c'.smulRight f) x := by
  simpa only [smul_zero, zero_add] using hc.smul (hasFDerivAt_const f x)

@[fun_prop]
theorem DifferentiableWithinAt.smul_const (hc : DifferentiableWithinAt ğ•œ c s x) (f : F) :
    DifferentiableWithinAt ğ•œ (fun y => c y â€¢ f) s x :=
  (hc.hasFDerivWithinAt.smul_const f).differentiableWithinAt

@[fun_prop]
theorem DifferentiableAt.smul_const (hc : DifferentiableAt ğ•œ c x) (f : F) :
    DifferentiableAt ğ•œ (fun y => c y â€¢ f) x :=
  (hc.hasFDerivAt.smul_const f).differentiableAt

@[fun_prop]
theorem DifferentiableOn.smul_const (hc : DifferentiableOn ğ•œ c s) (f : F) :
    DifferentiableOn ğ•œ (fun y => c y â€¢ f) s := fun x hx => (hc x hx).smul_const f

@[fun_prop]
theorem Differentiable.smul_const (hc : Differentiable ğ•œ c) (f : F) :
    Differentiable ğ•œ fun y => c y â€¢ f := fun x => (hc x).smul_const f

theorem fderivWithin_smul_const (hxs : UniqueDiffWithinAt ğ•œ s x)
    (hc : DifferentiableWithinAt ğ•œ c s x) (f : F) :
    fderivWithin ğ•œ (fun y => c y â€¢ f) s x = (fderivWithin ğ•œ c s x).smulRight f :=
  (hc.hasFDerivWithinAt.smul_const f).fderivWithin hxs

theorem fderiv_smul_const (hc : DifferentiableAt ğ•œ c x) (f : F) :
    fderiv ğ•œ (fun y => c y â€¢ f) x = (fderiv ğ•œ c x).smulRight f :=
  (hc.hasFDerivAt.smul_const f).fderiv

end SMul

section Mul

/-! ### Derivative of the product of two functions -/


variable {ğ”¸ ğ”¸' : Type*} [NormedRing ğ”¸] [NormedCommRing ğ”¸'] [NormedAlgebra ğ•œ ğ”¸] [NormedAlgebra ğ•œ ğ”¸']
  {a b : E â†’ ğ”¸} {a' b' : E â†’L[ğ•œ] ğ”¸} {c d : E â†’ ğ”¸'} {c' d' : E â†’L[ğ•œ] ğ”¸'}

@[fun_prop]
theorem HasStrictFDerivAt.mul' {x : E} (ha : HasStrictFDerivAt a a' x)
    (hb : HasStrictFDerivAt b b' x) :
    HasStrictFDerivAt (fun y => a y * b y) (a x â€¢ b' + a'.smulRight (b x)) x :=
  ((ContinuousLinearMap.mul ğ•œ ğ”¸).isBoundedBilinearMap.hasStrictFDerivAt (a x, b x)).comp x
    (ha.prodMk hb)

@[fun_prop]
theorem HasStrictFDerivAt.mul (hc : HasStrictFDerivAt c c' x) (hd : HasStrictFDerivAt d d' x) :
    HasStrictFDerivAt (fun y => c y * d y) (c x â€¢ d' + d x â€¢ c') x := by
  convert hc.mul' hd
  ext z
  apply mul_comm

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivWithinAt.mul' (ha : HasFDerivWithinAt a a' s x) (hb : HasFDerivWithinAt b b' s x) :
    HasFDerivWithinAt (fun y => a y * b y) (a x â€¢ b' + a'.smulRight (b x)) s x := by
  exact ((ContinuousLinearMap.mul ğ•œ ğ”¸).isBoundedBilinearMap.hasFDerivAt
    (a x, b x)).comp_hasFDerivWithinAt x (ha.prodMk hb)

@[fun_prop]
theorem HasFDerivWithinAt.mul (hc : HasFDerivWithinAt c c' s x) (hd : HasFDerivWithinAt d d' s x) :
    HasFDerivWithinAt (fun y => c y * d y) (c x â€¢ d' + d x â€¢ c') s x := by
  convert hc.mul' hd
  ext z
  apply mul_comm

#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024
  `by exact` to solve unification issues. -/
@[fun_prop]
theorem HasFDerivAt.mul' (ha : HasFDerivAt a a' x) (hb : HasFDerivAt b b' x) :
    HasFDerivAt (fun y => a y * b y) (a x â€¢ b' + a'.smulRight (b x)) x := by
  exact ((ContinuousLinearMap.mul ğ•œ ğ”¸).isBoundedBilinearMap.hasFDerivAt
    (a x, b x)).comp x (ha.prodMk hb)

@[fun_prop]
theorem HasFDerivAt.mul (hc : HasFDerivAt c c' x) (hd : HasFDerivAt d d' x) :
    HasFDerivAt (fun y => c y * d y) (c x â€¢ d' + d x â€¢ c') x := by
  convert hc.mul' hd
  ext z
  apply mul_comm

@[fun_prop]
theorem DifferentiableWithinAt.mul (ha : DifferentiableWithinAt ğ•œ a s x)
    (hb : DifferentiableWithinAt ğ•œ b s x) : DifferentiableWithinAt ğ•œ (fun y => a y * b y) s x :=
  (ha.hasFDerivWithinAt.mul' hb.hasFDerivWithinAt).differentiableWithinAt

@[simp, fun_prop]
theorem DifferentiableAt.mul (ha : DifferentiableAt ğ•œ a x) (hb : DifferentiableAt ğ•œ b x) :
    DifferentiableAt ğ•œ (fun y => a y * b y) x :=
  (ha.hasFDerivAt.mul' hb.hasFDerivAt).differentiableAt

@[fun_prop]
theorem DifferentiableOn.mul (ha : DifferentiableOn ğ•œ a s) (hb : DifferentiableOn ğ•œ b s) :
    DifferentiableOn ğ•œ (fun y => a y * b y) s := fun x hx => (ha x hx).mul (hb x hx)

@[simp, fun_prop]
theorem Differentiable.mul (ha : Differentiable ğ•œ a) (hb : Differentiable ğ•œ b) :
    Differentiable ğ•œ fun y => a y * b y := fun x => (ha x).mul (hb x)

@[fun_prop]
theorem DifferentiableWithinAt.pow (ha : DifferentiableWithinAt ğ•œ a s x) :
    âˆ€ n : â„•, DifferentiableWithinAt ğ•œ (fun x => a x ^ n) s x
  | 0 => by simp only [pow_zero, differentiableWithinAt_const]
  | n + 1 => by simp only [pow_succ', DifferentiableWithinAt.pow ha n, ha.mul]

@[simp, fun_prop]
theorem DifferentiableAt.pow (ha : DifferentiableAt ğ•œ a x) (n : â„•) :
    DifferentiableAt ğ•œ (fun x => a x ^ n) x :=
  differentiableWithinAt_univ.mp <| ha.differentiableWithinAt.pow n

@[fun_prop]
theorem DifferentiableOn.pow (ha : DifferentiableOn ğ•œ a s) (n : â„•) :
    DifferentiableOn ğ•œ (fun x => a x ^ n) s := fun x h => (ha x h).pow n

@[simp, fun_prop]
theorem Differentiable.pow (ha : Differentiable ğ•œ a) (n : â„•) : Differentiable ğ•œ fun x => a x ^ n :=
  fun x => (ha x).pow n

theorem fderivWithin_mul' (hxs : UniqueDiffWithinAt ğ•œ s x) (ha : DifferentiableWithinAt ğ•œ a s x)
    (hb : DifferentiableWithinAt ğ•œ b s x) :
    fderivWithin ğ•œ (fun y => a y * b y) s x =
      a x â€¢ fderivWithin ğ•œ b s x + (fderivWithin ğ•œ a s x).smulRight (b x) :=
  (ha.hasFDerivWithinAt.mul' hb.hasFDerivWithinAt).fderivWithin hxs

theorem fderivWithin_mul (hxs : UniqueDiffWithinAt ğ•œ s x) (hc : DifferentiableWithinAt ğ•œ c s x)
    (hd : DifferentiableWithinAt ğ•œ d s x) :
    fderivWithin ğ•œ (fun y => c y * d y) s x =
      c x â€¢ fderivWithin ğ•œ d s x + d x â€¢ fderivWithin ğ•œ c s x :=
  (hc.hasFDerivWithinAt.mul hd.hasFDerivWithinAt).fderivWithin hxs

theorem fderiv_mul' (ha : DifferentiableAt ğ•œ a x) (hb : DifferentiableAt ğ•œ b x) :
    fderiv ğ•œ (fun y => a y * b y) x = a x â€¢ fderiv ğ•œ b x + (fderiv ğ•œ a x).smulRight (b x) :=
  (ha.hasFDerivAt.mul' hb.hasFDerivAt).fderiv

theorem fderiv_mul (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :
    fderiv ğ•œ (fun y => c y * d y) x = c x â€¢ fderiv ğ•œ d x + d x â€¢ fderiv ğ•œ c x :=
  (hc.hasFDerivAt.mul hd.hasFDerivAt).fderiv

@[fun_prop]
theorem HasStrictFDerivAt.mul_const' (ha : HasStrictFDerivAt a a' x) (b : ğ”¸) :
    HasStrictFDerivAt (fun y => a y * b) (a'.smulRight b) x :=
  ((ContinuousLinearMap.mul ğ•œ ğ”¸).flip b).hasStrictFDerivAt.comp x ha

@[fun_prop]
theorem HasStrictFDerivAt.mul_const (hc : HasStrictFDerivAt c c' x) (d : ğ”¸') :
    HasStrictFDerivAt (fun y => c y * d) (d â€¢ c') x := by
  convert hc.mul_const' d
  ext z
  apply mul_comm

@[fun_prop]
theorem HasFDerivWithinAt.mul_const' (ha : HasFDerivWithinAt a a' s x) (b : ğ”¸) :
    HasFDerivWithinAt (fun y => a y * b) (a'.smulRight b) s x :=
  ((ContinuousLinearMap.mul ğ•œ ğ”¸).flip b).hasFDerivAt.comp_hasFDerivWithinAt x ha

@[fun_prop]
theorem HasFDerivWithinAt.mul_const (hc : HasFDerivWithinAt c c' s x) (d : ğ”¸') :
    HasFDerivWithinAt (fun y => c y * d) (d â€¢ c') s x := by
  convert hc.mul_const' d
  ext z
  apply mul_comm

@[fun_prop]
theorem HasFDerivAt.mul_const' (ha : HasFDerivAt a a' x) (b : ğ”¸) :
    HasFDerivAt (fun y => a y * b) (a'.smulRight b) x :=
  ((ContinuousLinearMap.mul ğ•œ ğ”¸).flip b).hasFDerivAt.comp x ha

@[fun_prop]
theorem HasFDerivAt.mul_const (hc : HasFDerivAt c c' x) (d : ğ”¸') :
    HasFDerivAt (fun y => c y * d) (d â€¢ c') x := by
  convert hc.mul_const' d
  ext z
  apply mul_comm

@[fun_prop]
theorem DifferentiableWithinAt.mul_const (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :
    DifferentiableWithinAt ğ•œ (fun y => a y * b) s x :=
  (ha.hasFDerivWithinAt.mul_const' b).differentiableWithinAt

@[fun_prop]
theorem DifferentiableAt.mul_const (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :
    DifferentiableAt ğ•œ (fun y => a y * b) x :=
  (ha.hasFDerivAt.mul_const' b).differentiableAt

@[fun_prop]
theorem DifferentiableOn.mul_const (ha : DifferentiableOn ğ•œ a s) (b : ğ”¸) :
    DifferentiableOn ğ•œ (fun y => a y * b) s := fun x hx => (ha x hx).mul_const b

@[fun_prop]
theorem Differentiable.mul_const (ha : Differentiable ğ•œ a) (b : ğ”¸) :
    Differentiable ğ•œ fun y => a y * b := fun x => (ha x).mul_const b

theorem fderivWithin_mul_const' (hxs : UniqueDiffWithinAt ğ•œ s x)
    (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :
    fderivWithin ğ•œ (fun y => a y * b) s x = (fderivWithin ğ•œ a s x).smulRight b :=
  (ha.hasFDerivWithinAt.mul_const' b).fderivWithin hxs

theorem fderivWithin_mul_const (hxs : UniqueDiffWithinAt ğ•œ s x)
    (hc : DifferentiableWithinAt ğ•œ c s x) (d : ğ”¸') :
    fderivWithin ğ•œ (fun y => c y * d) s x = d â€¢ fderivWithin ğ•œ c s x :=
  (hc.hasFDerivWithinAt.mul_const d).fderivWithin hxs

theorem fderiv_mul_const' (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :
    fderiv ğ•œ (fun y => a y * b) x = (fderiv ğ•œ a x).smulRight b :=
  (ha.hasFDerivAt.mul_const' b).fderiv

theorem fderiv_mul_const (hc : DifferentiableAt ğ•œ c x) (d : ğ”¸') :
    fderiv ğ•œ (fun y => c y * d) x = d â€¢ fderiv ğ•œ c x :=
  (hc.hasFDerivAt.mul_const d).fderiv

@[fun_prop]
theorem HasStrictFDerivAt.const_mul (ha : HasStrictFDerivAt a a' x) (b : ğ”¸) :
    HasStrictFDerivAt (fun y => b * a y) (b â€¢ a') x :=
  ((ContinuousLinearMap.mul ğ•œ ğ”¸) b).hasStrictFDerivAt.comp x ha

@[fun_prop]
theorem HasFDerivWithinAt.const_mul (ha : HasFDerivWithinAt a a' s x) (b : ğ”¸) :
    HasFDerivWithinAt (fun y => b * a y) (b â€¢ a') s x :=
  ((ContinuousLinearMap.mul ğ•œ ğ”¸) b).hasFDerivAt.comp_hasFDerivWithinAt x ha

@[fun_prop]
theorem HasFDerivAt.const_mul (ha : HasFDerivAt a a' x) (b : ğ”¸) :
    HasFDerivAt (fun y => b * a y) (b â€¢ a') x :=
  ((ContinuousLinearMap.mul ğ•œ ğ”¸) b).hasFDerivAt.comp x ha

@[fun_prop]
theorem DifferentiableWithinAt.const_mul (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :
    DifferentiableWithinAt ğ•œ (fun y => b * a y) s x :=
  (ha.hasFDerivWithinAt.const_mul b).differentiableWithinAt

@[fun_prop]
theorem DifferentiableAt.const_mul (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :
    DifferentiableAt ğ•œ (fun y => b * a y) x :=
  (ha.hasFDerivAt.const_mul b).differentiableAt

@[fun_prop]
theorem DifferentiableOn.const_mul (ha : DifferentiableOn ğ•œ a s) (b : ğ”¸) :
    DifferentiableOn ğ•œ (fun y => b * a y) s := fun x hx => (ha x hx).const_mul b

@[fun_prop]
theorem Differentiable.const_mul (ha : Differentiable ğ•œ a) (b : ğ”¸) :
    Differentiable ğ•œ fun y => b * a y := fun x => (ha x).const_mul b

theorem fderivWithin_const_mul (hxs : UniqueDiffWithinAt ğ•œ s x)
    (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :
    fderivWithin ğ•œ (fun y => b * a y) s x = b â€¢ fderivWithin ğ•œ a s x :=
  (ha.hasFDerivWithinAt.const_mul b).fderivWithin hxs

theorem fderiv_const_mul (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :
    fderiv ğ•œ (fun y => b * a y) x = b â€¢ fderiv ğ•œ a x :=
  (ha.hasFDerivAt.const_mul b).fderiv

end Mul

section Prod

/-! ### Derivative of a finite product of functions -/

variable {Î¹ : Type*} {ğ”¸ ğ”¸' : Type*} [NormedRing ğ”¸] [NormedCommRing ğ”¸'] [NormedAlgebra ğ•œ ğ”¸]
  [NormedAlgebra ğ•œ ğ”¸'] {u : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸} {f' : Î¹ â†’ E â†’L[ğ•œ] ğ”¸} {g : Î¹ â†’ E â†’ ğ”¸'}
  {g' : Î¹ â†’ E â†’L[ğ•œ] ğ”¸'}

@[fun_prop]
theorem hasStrictFDerivAt_list_prod' [Fintype Î¹] {l : List Î¹} {x : Î¹ â†’ ğ”¸} :
    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.map x).prod)
      (âˆ‘ i : Fin l.length, ((l.take i).map x).prod â€¢
        smulRight (proj l[i]) ((l.drop (.succ i)).map x).prod) x := by
  induction l with
  | nil => simp [hasStrictFDerivAt_const]
  | cons a l IH =>
    simp only [List.map_cons, List.prod_cons, â† proj_apply (R := ğ•œ) (Ï† := fun _ : Î¹ â†¦ ğ”¸) a]
    exact .congr_fderiv (.mul' (ContinuousLinearMap.hasStrictFDerivAt _) IH)
      (by ext; simp [Fin.sum_univ_succ, Finset.mul_sum, mul_assoc, add_comm])

@[fun_prop]
theorem hasStrictFDerivAt_list_prod_finRange' {n : â„•} {x : Fin n â†’ ğ”¸} :
    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ ((List.finRange n).map x).prod)
      (âˆ‘ i : Fin n, (((List.finRange n).take i).map x).prod â€¢
        smulRight (proj i) (((List.finRange n).drop (.succ i)).map x).prod) x :=
  hasStrictFDerivAt_list_prod'.congr_fderiv <|
    Finset.sum_equiv (finCongr List.length_finRange) (by simp) (by simp [Fin.forall_iff])

@[fun_prop]
theorem hasStrictFDerivAt_list_prod_attach' {l : List Î¹} {x : {i // i âˆˆ l} â†’ ğ”¸} :
    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.attach.map x).prod)
      (âˆ‘ i : Fin l.length, ((l.attach.take i).map x).prod â€¢
        smulRight (proj l.attach[i.cast List.length_attach.symm])
          ((l.attach.drop (.succ i)).map x).prod) x := by
  classical exact hasStrictFDerivAt_list_prod'.congr_fderiv <| Eq.symm <|
    Finset.sum_equiv (finCongr List.length_attach.symm) (by simp) (by simp)

@[fun_prop]
theorem hasFDerivAt_list_prod' [Fintype Î¹] {l : List Î¹} {x : Î¹ â†’ ğ”¸'} :
    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.map x).prod)
      (âˆ‘ i : Fin l.length, ((l.take i).map x).prod â€¢
        smulRight (proj l[i]) ((l.drop (.succ i)).map x).prod) x :=
  hasStrictFDerivAt_list_prod'.hasFDerivAt

@[fun_prop]
theorem hasFDerivAt_list_prod_finRange' {n : â„•} {x : Fin n â†’ ğ”¸} :
    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ ((List.finRange n).map x).prod)
      (âˆ‘ i : Fin n, (((List.finRange n).take i).map x).prod â€¢
        smulRight (proj i) (((List.finRange n).drop (.succ i)).map x).prod) x :=
  (hasStrictFDerivAt_list_prod_finRange').hasFDerivAt

@[fun_prop]
theorem hasFDerivAt_list_prod_attach' {l : List Î¹} {x : {i // i âˆˆ l} â†’ ğ”¸} :
    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.attach.map x).prod)
      (âˆ‘ i : Fin l.length, ((l.attach.take i).map x).prod â€¢
        smulRight (proj l.attach[i.cast List.length_attach.symm])
          ((l.attach.drop (.succ i)).map x).prod) x := by
  classical exact hasStrictFDerivAt_list_prod_attach'.hasFDerivAt

/--
Auxiliary lemma for `hasStrictFDerivAt_multiset_prod`.

For `NormedCommRing ğ”¸'`, can rewrite as `Multiset` using `Multiset.prod_coe`.
-/
@[fun_prop]
theorem hasStrictFDerivAt_list_prod [DecidableEq Î¹] [Fintype Î¹] {l : List Î¹} {x : Î¹ â†’ ğ”¸'} :
    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.map x).prod)
      (l.map fun i â†¦ ((l.erase i).map x).prod â€¢ proj i).sum x := by
  refine hasStrictFDerivAt_list_prod'.congr_fderiv ?_
  conv_rhs => arg 1; arg 2; rw [â† List.finRange_map_get l]
  simp only [List.map_map, â† List.sum_toFinset _ (List.nodup_finRange _), List.toFinset_finRange,
    Function.comp_def, ((List.erase_getElem _).map _).prod_eq, List.eraseIdx_eq_take_drop_succ,
    List.map_append, List.prod_append, List.get_eq_getElem, Fin.getElem_fin, Nat.succ_eq_add_one]
  exact Finset.sum_congr rfl fun i _ â†¦ by
    ext; simp only [smul_apply, smulRight_apply, smul_eq_mul]; ring

@[fun_prop]
theorem hasStrictFDerivAt_multiset_prod [DecidableEq Î¹] [Fintype Î¹] {u : Multiset Î¹} {x : Î¹ â†’ ğ”¸'} :
    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (u.map x).prod)
      (u.map (fun i â†¦ ((u.erase i).map x).prod â€¢ proj i)).sum x :=
  u.inductionOn fun l â†¦ by simpa using hasStrictFDerivAt_list_prod

@[fun_prop]
theorem hasFDerivAt_multiset_prod [DecidableEq Î¹] [Fintype Î¹] {u : Multiset Î¹} {x : Î¹ â†’ ğ”¸'} :
    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (u.map x).prod)
      (Multiset.sum (u.map (fun i â†¦ ((u.erase i).map x).prod â€¢ proj i))) x :=
  hasStrictFDerivAt_multiset_prod.hasFDerivAt

theorem hasStrictFDerivAt_finset_prod [DecidableEq Î¹] [Fintype Î¹] {x : Î¹ â†’ ğ”¸'} :
    HasStrictFDerivAt (ğ•œ := ğ•œ) (âˆ i âˆˆ u, Â· i) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, x j) â€¢ proj i) x := by
  simp only [Finset.sum_eq_multiset_sum, Finset.prod_eq_multiset_prod]
  exact hasStrictFDerivAt_multiset_prod

theorem hasFDerivAt_finset_prod [DecidableEq Î¹] [Fintype Î¹] {x : Î¹ â†’ ğ”¸'} :
    HasFDerivAt (ğ•œ := ğ•œ) (âˆ i âˆˆ u, Â· i) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, x j) â€¢ proj i) x :=
  hasStrictFDerivAt_finset_prod.hasFDerivAt

section Comp

@[fun_prop]
theorem HasStrictFDerivAt.list_prod' {l : List Î¹} {x : E}
    (h : âˆ€ i âˆˆ l, HasStrictFDerivAt (f i Â·) (f' i) x) :
    HasStrictFDerivAt (fun x â†¦ (l.map (f Â· x)).prod)
      (âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢
        smulRight (f' l[i]) ((l.drop (.succ i)).map (f Â· x)).prod) x := by
  simp_rw [Fin.getElem_fin, â† l.get_eq_getElem, â† List.finRange_map_get l, List.map_map]
  -- After #19108, we have to be optimistic with `:)`s; otherwise Lean decides it need to find
  -- `NormedAddCommGroup (List ğ”¸)` which is nonsense.
  refine .congr_fderiv (hasStrictFDerivAt_list_prod_finRange'.comp x
    (hasStrictFDerivAt_pi.mpr fun i â†¦ h (l.get i) (List.getElem_mem ..)) :) ?_
  ext m
  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,
    smulRight_apply, proj_apply, pi_apply, Function.comp_def]

/--
Unlike `HasFDerivAt.finset_prod`, supports non-commutative multiply and duplicate elements.
-/
@[fun_prop]
theorem HasFDerivAt.list_prod' {l : List Î¹} {x : E}
    (h : âˆ€ i âˆˆ l, HasFDerivAt (f i Â·) (f' i) x) :
    HasFDerivAt (fun x â†¦ (l.map (f Â· x)).prod)
      (âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢
        smulRight (f' l[i]) ((l.drop (.succ i)).map (f Â· x)).prod) x := by
  simp_rw [Fin.getElem_fin, â† l.get_eq_getElem, â† List.finRange_map_get l, List.map_map]
  refine .congr_fderiv (hasFDerivAt_list_prod_finRange'.comp x
    (hasFDerivAt_pi.mpr fun i â†¦ h (l.get i) (l.get_mem i)) :) ?_
  ext m
  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,
    smulRight_apply, proj_apply, pi_apply, Function.comp_def]

@[fun_prop]
theorem HasFDerivWithinAt.list_prod' {l : List Î¹} {x : E}
    (h : âˆ€ i âˆˆ l, HasFDerivWithinAt (f i Â·) (f' i) s x) :
    HasFDerivWithinAt (fun x â†¦ (l.map (f Â· x)).prod)
      (âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢
        smulRight (f' l[i]) ((l.drop (.succ i)).map (f Â· x)).prod) s x := by
  simp_rw [Fin.getElem_fin, â† l.get_eq_getElem, â† List.finRange_map_get l, List.map_map]
  refine .congr_fderiv (hasFDerivAt_list_prod_finRange'.comp_hasFDerivWithinAt x
    (hasFDerivWithinAt_pi.mpr fun i â†¦ h (l.get i) (l.get_mem i)) :) ?_
  ext m
  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,
    smulRight_apply, proj_apply, pi_apply, Function.comp_def]

theorem fderiv_list_prod' {l : List Î¹} {x : E}
    (h : âˆ€ i âˆˆ l, DifferentiableAt ğ•œ (f i Â·) x) :
    fderiv ğ•œ (fun x â†¦ (l.map (f Â· x)).prod) x =
      âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢
        smulRight (fderiv ğ•œ (fun x â†¦ f l[i] x) x) ((l.drop (.succ i)).map (f Â· x)).prod :=
  (HasFDerivAt.list_prod' fun i hi â†¦ (h i hi).hasFDerivAt).fderiv

theorem fderivWithin_list_prod' {l : List Î¹} {x : E}
    (hxs : UniqueDiffWithinAt ğ•œ s x) (h : âˆ€ i âˆˆ l, DifferentiableWithinAt ğ•œ (f i Â·) s x) :
    fderivWithin ğ•œ (fun x â†¦ (l.map (f Â· x)).prod) s x =
      âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢
        smulRight (fderivWithin ğ•œ (fun x â†¦ f l[i] x) s x) ((l.drop (.succ i)).map (f Â· x)).prod :=
  (HasFDerivWithinAt.list_prod' fun i hi â†¦ (h i hi).hasFDerivWithinAt).fderivWithin hxs

@[fun_prop]
theorem HasStrictFDerivAt.multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}
    (h : âˆ€ i âˆˆ u, HasStrictFDerivAt (g i Â·) (g' i) x) :
    HasStrictFDerivAt (fun x â†¦ (u.map (g Â· x)).prod)
      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ g' i).sum x := by
  simp only [â† Multiset.attach_map_val u, Multiset.map_map]
  exact .congr_fderiv
    (hasStrictFDerivAt_multiset_prod.comp x <|
      hasStrictFDerivAt_pi.mpr fun i â†¦ h (Subtype.val i) i.prop :)
    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g Â· x)])

/--
Unlike `HasFDerivAt.finset_prod`, supports duplicate elements.
-/
@[fun_prop]
theorem HasFDerivAt.multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}
    (h : âˆ€ i âˆˆ u, HasFDerivAt (g i Â·) (g' i) x) :
    HasFDerivAt (fun x â†¦ (u.map (g Â· x)).prod)
      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ g' i).sum x := by
  simp only [â† Multiset.attach_map_val u, Multiset.map_map]
  exact .congr_fderiv
    (hasFDerivAt_multiset_prod.comp x <| hasFDerivAt_pi.mpr fun i â†¦ h (Subtype.val i) i.prop :)
    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g Â· x)])

@[fun_prop]
theorem HasFDerivWithinAt.multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}
    (h : âˆ€ i âˆˆ u, HasFDerivWithinAt (g i Â·) (g' i) s x) :
    HasFDerivWithinAt (fun x â†¦ (u.map (g Â· x)).prod)
      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ g' i).sum s x := by
  simp only [â† Multiset.attach_map_val u, Multiset.map_map]
  exact .congr_fderiv
    (hasFDerivAt_multiset_prod.comp_hasFDerivWithinAt x <|
      hasFDerivWithinAt_pi.mpr fun i â†¦ h (Subtype.val i) i.prop :)
    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g Â· x)])

theorem fderiv_multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}
    (h : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (g i Â·) x) :
    fderiv ğ•œ (fun x â†¦ (u.map (g Â· x)).prod) x =
      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ fderiv ğ•œ (g i) x).sum :=
  (HasFDerivAt.multiset_prod fun i hi â†¦ (h i hi).hasFDerivAt).fderiv

theorem fderivWithin_multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}
    (hxs : UniqueDiffWithinAt ğ•œ s x) (h : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (g i Â·) s x) :
    fderivWithin ğ•œ (fun x â†¦ (u.map (g Â· x)).prod) s x =
      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ fderivWithin ğ•œ (g i) s x).sum :=
  (HasFDerivWithinAt.multiset_prod fun i hi â†¦ (h i hi).hasFDerivWithinAt).fderivWithin hxs

theorem HasStrictFDerivAt.finset_prod [DecidableEq Î¹] {x : E}
    (hg : âˆ€ i âˆˆ u, HasStrictFDerivAt (g i) (g' i) x) :
    HasStrictFDerivAt (âˆ i âˆˆ u, g i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, g j x) â€¢ g' i) x := by
  simpa [â† Finset.prod_attach u] using .congr_fderiv
    (hasStrictFDerivAt_finset_prod.comp x <| hasStrictFDerivAt_pi.mpr fun i â†¦ hg i i.prop)
    (by ext; simp [Finset.prod_erase_attach (g Â· x), â† u.sum_attach])

theorem HasFDerivAt.finset_prod [DecidableEq Î¹] {x : E}
    (hg : âˆ€ i âˆˆ u, HasFDerivAt (g i) (g' i) x) :
    HasFDerivAt (âˆ i âˆˆ u, g i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, g j x) â€¢ g' i) x := by
  simpa [â† Finset.prod_attach u] using .congr_fderiv
    (hasFDerivAt_finset_prod.comp x <| hasFDerivAt_pi.mpr fun i â†¦ hg (Subtype.val i) i.prop :)
    (by ext; simp [Finset.prod_erase_attach (g Â· x), â† u.sum_attach])

theorem HasFDerivWithinAt.finset_prod [DecidableEq Î¹] {x : E}
    (hg : âˆ€ i âˆˆ u, HasFDerivWithinAt (g i) (g' i) s x) :
    HasFDerivWithinAt (âˆ i âˆˆ u, g i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, g j x) â€¢ g' i) s x := by
  simpa [â† Finset.prod_attach u] using .congr_fderiv
    (hasFDerivAt_finset_prod.comp_hasFDerivWithinAt x <|
      hasFDerivWithinAt_pi.mpr fun i â†¦ hg (Subtype.val i) i.prop :)
    (by ext; simp [Finset.prod_erase_attach (g Â· x), â† u.sum_attach])

theorem fderiv_finset_prod [DecidableEq Î¹] {x : E} (hg : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (g i) x) :
    fderiv ğ•œ (âˆ i âˆˆ u, g i Â·) x = âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, (g j x)) â€¢ fderiv ğ•œ (g i) x :=
  (HasFDerivAt.finset_prod fun i hi â†¦ (hg i hi).hasFDerivAt).fderiv

theorem fderivWithin_finset_prod [DecidableEq Î¹] {x : E} (hxs : UniqueDiffWithinAt ğ•œ s x)
    (hg : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (g i) s x) :
    fderivWithin ğ•œ (âˆ i âˆˆ u, g i Â·) s x =
      âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, (g j x)) â€¢ fderivWithin ğ•œ (g i) s x :=
  (HasFDerivWithinAt.finset_prod fun i hi â†¦ (hg i hi).hasFDerivWithinAt).fderivWithin hxs

end Comp

end Prod

section AlgebraInverse

variable {R : Type*} [NormedRing R] [HasSummableGeomSeries R] [NormedAlgebra ğ•œ R]

open NormedRing ContinuousLinearMap Ring

/-- At an invertible element `x` of a normed algebra `R`, the FrÃ©chet derivative of the inversion
operation is the linear map `fun t â†¦ - xâ»Â¹ * t * xâ»Â¹`.

TODO (low prio): prove a version without assumption `[HasSummableGeomSeries R]` but within the set
of units. -/
@[fun_prop]
theorem hasFDerivAt_ring_inverse (x : RË£) :
    HasFDerivAt Ring.inverse (-mulLeftRight ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹) x :=
  have : (fun t : R => Ring.inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =o[ğ“ 0] id :=
    (inverse_add_norm_diff_second_order x).trans_isLittleO (isLittleO_norm_pow_id one_lt_two)
  by simpa [hasFDerivAt_iff_isLittleO_nhds_zero] using this

@[fun_prop]
theorem differentiableAt_inverse {x : R} (hx : IsUnit x) :
    DifferentiableAt ğ•œ (@Ring.inverse R _) x :=
  let âŸ¨u, huâŸ© := hx; hu â–¸ (hasFDerivAt_ring_inverse u).differentiableAt

@[fun_prop]
theorem differentiableWithinAt_inverse {x : R} (hx : IsUnit x) (s : Set R) :
    DifferentiableWithinAt ğ•œ (@Ring.inverse R _) s x :=
  (differentiableAt_inverse hx).differentiableWithinAt

@[fun_prop]
theorem differentiableOn_inverse : DifferentiableOn ğ•œ (@Ring.inverse R _) {x | IsUnit x} :=
  fun _x hx => differentiableWithinAt_inverse hx _

theorem fderiv_inverse (x : RË£) : fderiv ğ•œ (@Ring.inverse R _) x = -mulLeftRight ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹ :=
  (hasFDerivAt_ring_inverse x).fderiv

theorem hasStrictFDerivAt_ring_inverse (x : RË£) :
    HasStrictFDerivAt Ring.inverse (-mulLeftRight ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹) x := by
  convert (analyticAt_inverse (ğ•œ := ğ•œ) x).hasStrictFDerivAt
  exact (fderiv_inverse x).symm

variable {h : E â†’ R} {z : E} {S : Set E}

@[fun_prop]
theorem DifferentiableWithinAt.inverse (hf : DifferentiableWithinAt ğ•œ h S z) (hz : IsUnit (h z)) :
    DifferentiableWithinAt ğ•œ (fun x => Ring.inverse (h x)) S z :=
  (differentiableAt_inverse hz).comp_differentiableWithinAt z hf

@[simp, fun_prop]
theorem DifferentiableAt.inverse (hf : DifferentiableAt ğ•œ h z) (hz : IsUnit (h z)) :
    DifferentiableAt ğ•œ (fun x => Ring.inverse (h x)) z :=
  (differentiableAt_inverse hz).comp z hf

@[fun_prop]
theorem DifferentiableOn.inverse (hf : DifferentiableOn ğ•œ h S) (hz : âˆ€ x âˆˆ S, IsUnit (h x)) :
    DifferentiableOn ğ•œ (fun x => Ring.inverse (h x)) S := fun x h => (hf x h).inverse (hz x h)

@[simp, fun_prop]
theorem Differentiable.inverse (hf : Differentiable ğ•œ h) (hz : âˆ€ x, IsUnit (h x)) :
    Differentiable ğ•œ fun x => Ring.inverse (h x) := fun x => (hf x).inverse (hz x)

end AlgebraInverse

/-! ### Derivative of the inverse in a division ring

Note that some lemmas are primed as they are expressed without commutativity, whereas their
counterparts in commutative fields involve simpler expressions, and are given in
`Mathlib/Analysis/Calculus/Deriv/Inv.lean`.
-/

section DivisionRingInverse

variable {R : Type*} [NormedDivisionRing R] [NormedAlgebra ğ•œ R]

open NormedRing ContinuousLinearMap Ring

/-- At an invertible element `x` of a normed division algebra `R`, the inversion is strictly
differentiable, with derivative the linear map `fun t â†¦ - xâ»Â¹ * t * xâ»Â¹`. For a nicer formula in
the commutative case, see `hasStrictFDerivAt_inv`. -/
theorem hasStrictFDerivAt_inv' {x : R} (hx : x â‰  0) :
    HasStrictFDerivAt Inv.inv (-mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹) x := by
  simpa using hasStrictFDerivAt_ring_inverse (Units.mk0 _ hx)

/-- At an invertible element `x` of a normed division algebra `R`, the FrÃ©chet derivative of the
inversion operation is the linear map `fun t â†¦ - xâ»Â¹ * t * xâ»Â¹`. For a nicer formula in the
commutative case, see `hasFDerivAt_inv`. -/
@[fun_prop]
theorem hasFDerivAt_inv' {x : R} (hx : x â‰  0) :
    HasFDerivAt Inv.inv (-mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹) x := by
  simpa using hasFDerivAt_ring_inverse (Units.mk0 _ hx)

@[fun_prop]
theorem differentiableAt_inv {x : R} (hx : x â‰  0) : DifferentiableAt ğ•œ Inv.inv x :=
  (hasFDerivAt_inv' hx).differentiableAt

@[fun_prop]
theorem differentiableWithinAt_inv {x : R} (hx : x â‰  0) (s : Set R) :
    DifferentiableWithinAt ğ•œ (fun x => xâ»Â¹) s x :=
  (differentiableAt_inv hx).differentiableWithinAt

@[fun_prop]
theorem differentiableOn_inv : DifferentiableOn ğ•œ (fun x : R => xâ»Â¹) {x | x â‰  0} := fun _x hx =>
  differentiableWithinAt_inv hx _

/-- Non-commutative version of `fderiv_inv` -/
theorem fderiv_inv' {x : R} (hx : x â‰  0) : fderiv ğ•œ Inv.inv x = -mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹ :=
  (hasFDerivAt_inv' hx).fderiv

/-- Non-commutative version of `fderivWithin_inv` -/
theorem fderivWithin_inv' {s : Set R} {x : R} (hx : x â‰  0) (hxs : UniqueDiffWithinAt ğ•œ s x) :
    fderivWithin ğ•œ (fun x => xâ»Â¹) s x = -mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹ := by
  rw [DifferentiableAt.fderivWithin (differentiableAt_inv hx) hxs]
  exact fderiv_inv' hx

variable {h : E â†’ R} {z : E} {S : Set E}

@[fun_prop]
theorem DifferentiableWithinAt.inv (hf : DifferentiableWithinAt ğ•œ h S z) (hz : h z â‰  0) :
    DifferentiableWithinAt ğ•œ (fun x => (h x)â»Â¹) S z :=
  (differentiableAt_inv hz).comp_differentiableWithinAt z hf

@[simp, fun_prop]
theorem DifferentiableAt.inv (hf : DifferentiableAt ğ•œ h z) (hz : h z â‰  0) :
    DifferentiableAt ğ•œ (fun x => (h x)â»Â¹) z :=
  (differentiableAt_inv hz).comp z hf

@[fun_prop]
theorem DifferentiableOn.inv (hf : DifferentiableOn ğ•œ h S) (hz : âˆ€ x âˆˆ S, h x â‰  0) :
    DifferentiableOn ğ•œ (fun x => (h x)â»Â¹) S := fun x h => (hf x h).inv (hz x h)

@[simp, fun_prop]
theorem Differentiable.inv (hf : Differentiable ğ•œ h) (hz : âˆ€ x, h x â‰  0) :
    Differentiable ğ•œ fun x => (h x)â»Â¹ := fun x => (hf x).inv (hz x)

end DivisionRingInverse

end

-- END Mathlib.Analysis.Calculus.FDeriv.Mul --

-- BEGIN Mathlib.Analysis.Calculus.FDeriv.Add --
/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, SÃ©bastien GouÃ«zel, Yury Kudryashov
-/
import Mathlib.Analysis.Calculus.FDeriv.Linear
import Mathlib.Analysis.Calculus.FDeriv.Comp

/-!
# Additive operations on derivatives

For detailed documentation of the FrÃ©chet derivative,
see the module docstring of `Analysis/Calculus/FDeriv/Basic.lean`.

This file contains the usual formulas (and existence assertions) for the derivative of

* sum of finitely many functions
* multiplication of a function by a scalar constant
* negative of a function
* subtraction of two functions
-/


open Filter Asymptotics ContinuousLinearMap

noncomputable section

section

variable {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {f g : E â†’ F}
variable {f' g' : E â†’L[ğ•œ] F}
variable {x : E}
variable {s : Set E}
variable {L : Filter E}

section ConstSMul

variable {R : Type*} [Semiring R] [Module R F] [SMulCommClass ğ•œ R F] [ContinuousConstSMul R F]

/-! ### Derivative of a function multiplied by a constant -/

@[fun_prop]
theorem HasStrictFDerivAt.const_smul (h : HasStrictFDerivAt f f' x) (c : R) :
    HasStrictFDerivAt (fun x => c â€¢ f x) (c â€¢ f') x :=
  (c â€¢ (1 : F â†’L[ğ•œ] F)).hasStrictFDerivAt.comp x h

theorem HasFDerivAtFilter.const_smul (h : HasFDerivAtFilter f f' x L) (c : R) :
    HasFDerivAtFilter (fun x => c â€¢ f x) (c â€¢ f') x L :=
  (c â€¢ (1 : F â†’L[ğ•œ] F)).hasFDerivAtFilter.comp x h tendsto_map

@[fun_prop]
nonrec theorem HasFDerivWithinAt.const_smul (h : HasFDerivWithinAt f f' s x) (c : R) :
    HasFDerivWithinAt (fun x => c â€¢ f x) (c â€¢ f') s x :=
  h.const_smul c

@[fun_prop]
nonrec theorem HasFDerivAt.const_smul (h : HasFDerivAt f f' x) (c : R) :
    HasFDerivAt (fun x => c â€¢ f x) (c â€¢ f') x :=
  h.const_smul c

@[fun_prop]
theorem DifferentiableWithinAt.const_smul (h : DifferentiableWithinAt ğ•œ f s x) (c : R) :
    DifferentiableWithinAt ğ•œ (fun y => c â€¢ f y) s x :=
  (h.hasFDerivWithinAt.const_smul c).differentiableWithinAt

@[fun_prop]
theorem DifferentiableAt.const_smul (h : DifferentiableAt ğ•œ f x) (c : R) :
    DifferentiableAt ğ•œ (fun y => c â€¢ f y) x :=
  (h.hasFDerivAt.const_smul c).differentiableAt

@[fun_prop]
theorem DifferentiableOn.const_smul (h : DifferentiableOn ğ•œ f s) (c : R) :
    DifferentiableOn ğ•œ (fun y => c â€¢ f y) s := fun x hx => (h x hx).const_smul c

@[fun_prop]
theorem Differentiable.const_smul (h : Differentiable ğ•œ f) (c : R) :
    Differentiable ğ•œ fun y => c â€¢ f y := fun x => (h x).const_smul c

theorem fderivWithin_const_smul (hxs : UniqueDiffWithinAt ğ•œ s x)
    (h : DifferentiableWithinAt ğ•œ f s x) (c : R) :
    fderivWithin ğ•œ (fun y => c â€¢ f y) s x = c â€¢ fderivWithin ğ•œ f s x :=
  (h.hasFDerivWithinAt.const_smul c).fderivWithin hxs

/-- Version of `fderivWithin_const_smul` written with `c â€¢ f` instead of `fun y â†¦ c â€¢ f y`. -/
theorem fderivWithin_const_smul' (hxs : UniqueDiffWithinAt ğ•œ s x)
    (h : DifferentiableWithinAt ğ•œ f s x) (c : R) :
    fderivWithin ğ•œ (c â€¢ f) s x = c â€¢ fderivWithin ğ•œ f s x :=
  fderivWithin_const_smul hxs h c

theorem fderiv_const_smul (h : DifferentiableAt ğ•œ f x) (c : R) :
    fderiv ğ•œ (fun y => c â€¢ f y) x = c â€¢ fderiv ğ•œ f x :=
  (h.hasFDerivAt.const_smul c).fderiv

/-- Version of `fderiv_const_smul` written with `c â€¢ f` instead of `fun y â†¦ c â€¢ f y`. -/
theorem fderiv_const_smul' (h : DifferentiableAt ğ•œ f x) (c : R) :
    fderiv ğ•œ (c â€¢ f) x = c â€¢ fderiv ğ•œ f x :=
  (h.hasFDerivAt.const_smul c).fderiv

end ConstSMul

section Add

/-! ### Derivative of the sum of two functions -/


@[fun_prop]
nonrec theorem HasStrictFDerivAt.add (hf : HasStrictFDerivAt f f' x)
    (hg : HasStrictFDerivAt g g' x) : HasStrictFDerivAt (fun y => f y + g y) (f' + g') x :=
   .of_isLittleO <| (hf.isLittleO.add hg.isLittleO).congr_left fun y => by
    simp only [LinearMap.sub_apply, LinearMap.add_apply, map_sub, map_add, add_apply]
    abel

theorem HasFDerivAtFilter.add (hf : HasFDerivAtFilter f f' x L)
    (hg : HasFDerivAtFilter g g' x L) : HasFDerivAtFilter (fun y => f y + g y) (f' + g') x L :=
  .of_isLittleO <| (hf.isLittleO.add hg.isLittleO).congr_left fun _ => by
    simp only [LinearMap.sub_apply, LinearMap.add_apply, map_sub, map_add, add_apply]
    abel

@[fun_prop]
nonrec theorem HasFDerivWithinAt.add (hf : HasFDerivWithinAt f f' s x)
    (hg : HasFDerivWithinAt g g' s x) : HasFDerivWithinAt (fun y => f y + g y) (f' + g') s x :=
  hf.add hg

@[fun_prop]
nonrec theorem HasFDerivAt.add (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) :
    HasFDerivAt (fun x => f x + g x) (f' + g') x :=
  hf.add hg

@[fun_prop]
theorem DifferentiableWithinAt.add (hf : DifferentiableWithinAt ğ•œ f s x)
    (hg : DifferentiableWithinAt ğ•œ g s x) : DifferentiableWithinAt ğ•œ (fun y => f y + g y) s x :=
  (hf.hasFDerivWithinAt.add hg.hasFDerivWithinAt).differentiableWithinAt

@[simp, fun_prop]
theorem DifferentiableAt.add (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :
    DifferentiableAt ğ•œ (fun y => f y + g y) x :=
  (hf.hasFDerivAt.add hg.hasFDerivAt).differentiableAt

@[fun_prop]
theorem DifferentiableOn.add (hf : DifferentiableOn ğ•œ f s) (hg : DifferentiableOn ğ•œ g s) :
    DifferentiableOn ğ•œ (fun y => f y + g y) s := fun x hx => (hf x hx).add (hg x hx)

@[simp, fun_prop]
theorem Differentiable.add (hf : Differentiable ğ•œ f) (hg : Differentiable ğ•œ g) :
    Differentiable ğ•œ fun y => f y + g y := fun x => (hf x).add (hg x)

theorem fderivWithin_add (hxs : UniqueDiffWithinAt ğ•œ s x) (hf : DifferentiableWithinAt ğ•œ f s x)
    (hg : DifferentiableWithinAt ğ•œ g s x) :
    fderivWithin ğ•œ (fun y => f y + g y) s x = fderivWithin ğ•œ f s x + fderivWithin ğ•œ g s x :=
  (hf.hasFDerivWithinAt.add hg.hasFDerivWithinAt).fderivWithin hxs

/-- Version of `fderivWithin_add` where the function is written as `f + g` instead
of `fun y â†¦ f y + g y`. -/
theorem fderivWithin_add' (hxs : UniqueDiffWithinAt ğ•œ s x) (hf : DifferentiableWithinAt ğ•œ f s x)
    (hg : DifferentiableWithinAt ğ•œ g s x) :
    fderivWithin ğ•œ (f + g) s x = fderivWithin ğ•œ f s x + fderivWithin ğ•œ g s x :=
  fderivWithin_add hxs hf hg

theorem fderiv_add (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :
    fderiv ğ•œ (fun y => f y + g y) x = fderiv ğ•œ f x + fderiv ğ•œ g x :=
  (hf.hasFDerivAt.add hg.hasFDerivAt).fderiv

/-- Version of `fderiv_add` where the function is written as `f + g` instead
of `fun y â†¦ f y + g y`. -/
theorem fderiv_add' (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :
    fderiv ğ•œ (f + g) x = fderiv ğ•œ f x + fderiv ğ•œ g x :=
  fderiv_add hf hg

@[simp]
theorem hasFDerivAtFilter_add_const_iff (c : F) :
    HasFDerivAtFilter (f Â· + c) f' x L â†” HasFDerivAtFilter f f' x L := by
  simp [hasFDerivAtFilter_iff_isLittleOTVS]

alias âŸ¨_, HasFDerivAtFilter.add_constâŸ© := hasFDerivAtFilter_add_const_iff

@[simp]
theorem hasStrictFDerivAt_add_const_iff (c : F) :
    HasStrictFDerivAt (f Â· + c) f' x â†” HasStrictFDerivAt f f' x := by
  simp [hasStrictFDerivAt_iff_isLittleO]

@[fun_prop]
alias âŸ¨_, HasStrictFDerivAt.add_constâŸ© := hasStrictFDerivAt_add_const_iff

@[simp]
theorem hasFDerivWithinAt_add_const_iff (c : F) :
    HasFDerivWithinAt (f Â· + c) f' s x â†” HasFDerivWithinAt f f' s x :=
  hasFDerivAtFilter_add_const_iff c

@[fun_prop]
alias âŸ¨_, HasFDerivWithinAt.add_constâŸ© := hasFDerivWithinAt_add_const_iff

@[simp]
theorem hasFDerivAt_add_const_iff (c : F) : HasFDerivAt (f Â· + c) f' x â†” HasFDerivAt f f' x :=
  hasFDerivAtFilter_add_const_iff c

@[fun_prop]
alias âŸ¨_, HasFDerivAt.add_constâŸ© := hasFDerivAt_add_const_iff

@[simp]
theorem differentiableWithinAt_add_const_iff (c : F) :
    DifferentiableWithinAt ğ•œ (fun y => f y + c) s x â†” DifferentiableWithinAt ğ•œ f s x :=
  exists_congr fun _ â†¦ hasFDerivWithinAt_add_const_iff c

@[fun_prop]
alias âŸ¨_, DifferentiableWithinAt.add_constâŸ© := differentiableWithinAt_add_const_iff

@[simp]
theorem differentiableAt_add_const_iff (c : F) :
    DifferentiableAt ğ•œ (fun y => f y + c) x â†” DifferentiableAt ğ•œ f x :=
  exists_congr fun _ â†¦ hasFDerivAt_add_const_iff c

@[fun_prop]
alias âŸ¨_, DifferentiableAt.add_constâŸ© := differentiableAt_add_const_iff

@[simp]
theorem differentiableOn_add_const_iff (c : F) :
    DifferentiableOn ğ•œ (fun y => f y + c) s â†” DifferentiableOn ğ•œ f s :=
  forallâ‚‚_congr fun _ _ â†¦ differentiableWithinAt_add_const_iff c

@[fun_prop]
alias âŸ¨_, DifferentiableOn.add_constâŸ© := differentiableOn_add_const_iff

@[simp]
theorem differentiable_add_const_iff (c : F) :
    (Differentiable ğ•œ fun y => f y + c) â†” Differentiable ğ•œ f :=
  forall_congr' fun _ â†¦ differentiableAt_add_const_iff c

@[fun_prop]
alias âŸ¨_,  Differentiable.add_constâŸ© := differentiable_add_const_iff

@[simp]
theorem fderivWithin_add_const (c : F) :
    fderivWithin ğ•œ (fun y => f y + c) s x = fderivWithin ğ•œ f s x := by
  classical simp [fderivWithin]

@[simp]
theorem fderiv_add_const (c : F) : fderiv ğ•œ (fun y => f y + c) x = fderiv ğ•œ f x := by
  simp only [â† fderivWithin_univ, fderivWithin_add_const]

@[simp]
theorem hasFDerivAtFilter_const_add_iff (c : F) :
    HasFDerivAtFilter (c + f Â·) f' x L â†” HasFDerivAtFilter f f' x L := by
  simpa only [add_comm] using hasFDerivAtFilter_add_const_iff c

alias âŸ¨_, HasFDerivAtFilter.const_addâŸ© := hasFDerivAtFilter_const_add_iff

@[simp]
theorem hasStrictFDerivAt_const_add_iff (c : F) :
    HasStrictFDerivAt (c + f Â·) f' x â†” HasStrictFDerivAt f f' x := by
  simpa only [add_comm] using hasStrictFDerivAt_add_const_iff c

@[fun_prop]
alias âŸ¨_, HasStrictFDerivAt.const_addâŸ© := hasStrictFDerivAt_const_add_iff

@[simp]
theorem hasFDerivWithinAt_const_add_iff (c : F) :
    HasFDerivWithinAt (c + f Â·) f' s x â†” HasFDerivWithinAt f f' s x :=
  hasFDerivAtFilter_const_add_iff c

@[fun_prop]
alias âŸ¨_, HasFDerivWithinAt.const_addâŸ© := hasFDerivWithinAt_const_add_iff

@[simp]
theorem hasFDerivAt_const_add_iff (c : F) : HasFDerivAt (c + f Â·) f' x â†” HasFDerivAt f f' x :=
  hasFDerivAtFilter_const_add_iff c

@[fun_prop]
alias âŸ¨_, HasFDerivAt.const_addâŸ© := hasFDerivAt_const_add_iff

@[simp]
theorem differentiableWithinAt_const_add_iff (c : F) :
    DifferentiableWithinAt ğ•œ (fun y => c + f y) s x â†” DifferentiableWithinAt ğ•œ f s x :=
  exists_congr fun _ â†¦ hasFDerivWithinAt_const_add_iff c

@[fun_prop]
alias âŸ¨_, DifferentiableWithinAt.const_addâŸ© := differentiableWithinAt_const_add_iff

@[simp]
theorem differentiableAt_const_add_iff (c : F) :
    DifferentiableAt ğ•œ (fun y => c + f y) x â†” DifferentiableAt ğ•œ f x :=
  exists_congr fun _ â†¦ hasFDerivAt_const_add_iff c

@[fun_prop]
alias âŸ¨_, DifferentiableAt.const_addâŸ© := differentiableAt_const_add_iff

@[simp]
theorem differentiableOn_const_add_iff (c : F) :
    DifferentiableOn ğ•œ (fun y => c + f y) s â†” DifferentiableOn ğ•œ f s :=
  forallâ‚‚_congr fun _ _ â†¦ differentiableWithinAt_const_add_iff c

@[fun_prop]
alias âŸ¨_, DifferentiableOn.const_addâŸ© := differentiableOn_const_add_iff

@[simp]
theorem differentiable_const_add_iff (c : F) :
    (Differentiable ğ•œ fun y => c + f y) â†” Differentiable ğ•œ f :=
  forall_congr' fun _ â†¦ differentiableAt_const_add_iff c

@[fun_prop]
alias âŸ¨_, Differentiable.const_addâŸ© := differentiable_const_add_iff

@[simp]
theorem fderivWithin_const_add (c : F) :
    fderivWithin ğ•œ (fun y => c + f y) s x = fderivWithin ğ•œ f s x := by
  simpa only [add_comm] using fderivWithin_add_const c

@[simp]
theorem fderiv_const_add (c : F) : fderiv ğ•œ (fun y => c + f y) x = fderiv ğ•œ f x := by
  simp only [add_comm c, fderiv_add_const]

end Add

section Sum

/-! ### Derivative of a finite sum of functions -/


variable {Î¹ : Type*} {u : Finset Î¹} {A : Î¹ â†’ E â†’ F} {A' : Î¹ â†’ E â†’L[ğ•œ] F}

@[fun_prop]
theorem HasStrictFDerivAt.sum (h : âˆ€ i âˆˆ u, HasStrictFDerivAt (A i) (A' i) x) :
    HasStrictFDerivAt (fun y => âˆ‘ i âˆˆ u, A i y) (âˆ‘ i âˆˆ u, A' i) x := by
  simp only [hasStrictFDerivAt_iff_isLittleO] at *
  convert IsLittleO.sum h
  simp [Finset.sum_sub_distrib, ContinuousLinearMap.sum_apply]

theorem HasFDerivAtFilter.sum (h : âˆ€ i âˆˆ u, HasFDerivAtFilter (A i) (A' i) x L) :
    HasFDerivAtFilter (fun y => âˆ‘ i âˆˆ u, A i y) (âˆ‘ i âˆˆ u, A' i) x L := by
  simp only [hasFDerivAtFilter_iff_isLittleO] at *
  convert IsLittleO.sum h
  simp [ContinuousLinearMap.sum_apply]

@[fun_prop]
theorem HasFDerivWithinAt.sum (h : âˆ€ i âˆˆ u, HasFDerivWithinAt (A i) (A' i) s x) :
    HasFDerivWithinAt (fun y => âˆ‘ i âˆˆ u, A i y) (âˆ‘ i âˆˆ u, A' i) s x :=
  HasFDerivAtFilter.sum h

@[fun_prop]
theorem HasFDerivAt.sum (h : âˆ€ i âˆˆ u, HasFDerivAt (A i) (A' i) x) :
    HasFDerivAt (fun y => âˆ‘ i âˆˆ u, A i y) (âˆ‘ i âˆˆ u, A' i) x :=
  HasFDerivAtFilter.sum h

@[fun_prop]
theorem DifferentiableWithinAt.sum (h : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (A i) s x) :
    DifferentiableWithinAt ğ•œ (fun y => âˆ‘ i âˆˆ u, A i y) s x :=
  HasFDerivWithinAt.differentiableWithinAt <|
    HasFDerivWithinAt.sum fun i hi => (h i hi).hasFDerivWithinAt

@[simp, fun_prop]
theorem DifferentiableAt.sum (h : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (A i) x) :
    DifferentiableAt ğ•œ (fun y => âˆ‘ i âˆˆ u, A i y) x :=
  HasFDerivAt.differentiableAt <| HasFDerivAt.sum fun i hi => (h i hi).hasFDerivAt

@[fun_prop]
theorem DifferentiableOn.sum (h : âˆ€ i âˆˆ u, DifferentiableOn ğ•œ (A i) s) :
    DifferentiableOn ğ•œ (fun y => âˆ‘ i âˆˆ u, A i y) s := fun x hx =>
  DifferentiableWithinAt.sum fun i hi => h i hi x hx

@[simp, fun_prop]
theorem Differentiable.sum (h : âˆ€ i âˆˆ u, Differentiable ğ•œ (A i)) :
    Differentiable ğ•œ fun y => âˆ‘ i âˆˆ u, A i y := fun x => DifferentiableAt.sum fun i hi => h i hi x

theorem fderivWithin_sum (hxs : UniqueDiffWithinAt ğ•œ s x)
    (h : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (A i) s x) :
    fderivWithin ğ•œ (fun y => âˆ‘ i âˆˆ u, A i y) s x = âˆ‘ i âˆˆ u, fderivWithin ğ•œ (A i) s x :=
  (HasFDerivWithinAt.sum fun i hi => (h i hi).hasFDerivWithinAt).fderivWithin hxs

theorem fderiv_sum (h : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (A i) x) :
    fderiv ğ•œ (fun y => âˆ‘ i âˆˆ u, A i y) x = âˆ‘ i âˆˆ u, fderiv ğ•œ (A i) x :=
  (HasFDerivAt.sum fun i hi => (h i hi).hasFDerivAt).fderiv

end Sum

section Neg

/-! ### Derivative of the negative of a function -/


@[fun_prop]
theorem HasStrictFDerivAt.neg (h : HasStrictFDerivAt f f' x) :
    HasStrictFDerivAt (fun x => -f x) (-f') x :=
  (-1 : F â†’L[ğ•œ] F).hasStrictFDerivAt.comp x h

theorem HasFDerivAtFilter.neg (h : HasFDerivAtFilter f f' x L) :
    HasFDerivAtFilter (fun x => -f x) (-f') x L :=
  (-1 : F â†’L[ğ•œ] F).hasFDerivAtFilter.comp x h tendsto_map

@[fun_prop]
nonrec theorem HasFDerivWithinAt.neg (h : HasFDerivWithinAt f f' s x) :
    HasFDerivWithinAt (fun x => -f x) (-f') s x :=
  h.neg

@[fun_prop]
nonrec theorem HasFDerivAt.neg (h : HasFDerivAt f f' x) : HasFDerivAt (fun x => -f x) (-f') x :=
  h.neg

@[fun_prop]
theorem DifferentiableWithinAt.neg (h : DifferentiableWithinAt ğ•œ f s x) :
    DifferentiableWithinAt ğ•œ (fun y => -f y) s x :=
  h.hasFDerivWithinAt.neg.differentiableWithinAt

@[simp]
theorem differentiableWithinAt_neg_iff :
    DifferentiableWithinAt ğ•œ (fun y => -f y) s x â†” DifferentiableWithinAt ğ•œ f s x :=
  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©

@[fun_prop]
theorem DifferentiableAt.neg (h : DifferentiableAt ğ•œ f x) : DifferentiableAt ğ•œ (fun y => -f y) x :=
  h.hasFDerivAt.neg.differentiableAt

@[simp]
theorem differentiableAt_neg_iff : DifferentiableAt ğ•œ (fun y => -f y) x â†” DifferentiableAt ğ•œ f x :=
  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©

@[fun_prop]
theorem DifferentiableOn.neg (h : DifferentiableOn ğ•œ f s) : DifferentiableOn ğ•œ (fun y => -f y) s :=
  fun x hx => (h x hx).neg

@[simp]
theorem differentiableOn_neg_iff : DifferentiableOn ğ•œ (fun y => -f y) s â†” DifferentiableOn ğ•œ f s :=
  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©

@[fun_prop]
theorem Differentiable.neg (h : Differentiable ğ•œ f) : Differentiable ğ•œ fun y => -f y := fun x =>
  (h x).neg

@[simp]
theorem differentiable_neg_iff : (Differentiable ğ•œ fun y => -f y) â†” Differentiable ğ•œ f :=
  âŸ¨fun h => by simpa only [neg_neg] using h.neg, fun h => h.negâŸ©

theorem fderivWithin_neg (hxs : UniqueDiffWithinAt ğ•œ s x) :
    fderivWithin ğ•œ (fun y => -f y) s x = -fderivWithin ğ•œ f s x := by
  classical
  by_cases h : DifferentiableWithinAt ğ•œ f s x
  Â· exact h.hasFDerivWithinAt.neg.fderivWithin hxs
  Â· rw [fderivWithin_zero_of_not_differentiableWithinAt h,
      fderivWithin_zero_of_not_differentiableWithinAt, neg_zero]
    simpa

/-- Version of `fderivWithin_neg` where the function is written `-f` instead of `fun y â†¦ - f y`. -/
theorem fderivWithin_neg' (hxs : UniqueDiffWithinAt ğ•œ s x) :
    fderivWithin ğ•œ (-f) s x = -fderivWithin ğ•œ f s x :=
  fderivWithin_neg hxs

@[simp]
theorem fderiv_neg : fderiv ğ•œ (fun y => -f y) x = -fderiv ğ•œ f x := by
  simp only [â† fderivWithin_univ, fderivWithin_neg uniqueDiffWithinAt_univ]

/-- Version of `fderiv_neg` where the function is written `-f` instead of `fun y â†¦ - f y`. -/
theorem fderiv_neg' : fderiv ğ•œ (-f) x = -fderiv ğ•œ f x :=
  fderiv_neg

end Neg

section Sub

/-! ### Derivative of the difference of two functions -/


@[fun_prop]
theorem HasStrictFDerivAt.sub (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x) :
    HasStrictFDerivAt (fun x => f x - g x) (f' - g') x := by
  simpa only [sub_eq_add_neg] using hf.add hg.neg

theorem HasFDerivAtFilter.sub (hf : HasFDerivAtFilter f f' x L) (hg : HasFDerivAtFilter g g' x L) :
    HasFDerivAtFilter (fun x => f x - g x) (f' - g') x L := by
  simpa only [sub_eq_add_neg] using hf.add hg.neg

@[fun_prop]
nonrec theorem HasFDerivWithinAt.sub (hf : HasFDerivWithinAt f f' s x)
    (hg : HasFDerivWithinAt g g' s x) : HasFDerivWithinAt (fun x => f x - g x) (f' - g') s x :=
  hf.sub hg

@[fun_prop]
nonrec theorem HasFDerivAt.sub (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) :
    HasFDerivAt (fun x => f x - g x) (f' - g') x :=
  hf.sub hg

@[fun_prop]
theorem DifferentiableWithinAt.sub (hf : DifferentiableWithinAt ğ•œ f s x)
    (hg : DifferentiableWithinAt ğ•œ g s x) : DifferentiableWithinAt ğ•œ (fun y => f y - g y) s x :=
  (hf.hasFDerivWithinAt.sub hg.hasFDerivWithinAt).differentiableWithinAt

@[simp, fun_prop]
theorem DifferentiableAt.sub (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :
    DifferentiableAt ğ•œ (fun y => f y - g y) x :=
  (hf.hasFDerivAt.sub hg.hasFDerivAt).differentiableAt

@[simp]
lemma DifferentiableAt.add_iff_left (hg : DifferentiableAt ğ•œ g x) :
    DifferentiableAt ğ•œ (fun y => f y + g y) x â†” DifferentiableAt ğ•œ f x := by
  refine âŸ¨fun h â†¦ ?_, fun hf â†¦ hf.add hgâŸ©
  simpa only [add_sub_cancel_right] using h.sub hg

@[simp]
lemma DifferentiableAt.add_iff_right (hg : DifferentiableAt ğ•œ f x) :
    DifferentiableAt ğ•œ (fun y => f y + g y) x â†” DifferentiableAt ğ•œ g x := by
  simp only [add_comm (f _), hg.add_iff_left]

@[simp]
lemma DifferentiableAt.sub_iff_left (hg : DifferentiableAt ğ•œ g x) :
    DifferentiableAt ğ•œ (fun y => f y - g y) x â†” DifferentiableAt ğ•œ f x := by
  simp only [sub_eq_add_neg, differentiableAt_neg_iff, hg, add_iff_left]

@[simp]
lemma DifferentiableAt.sub_iff_right (hg : DifferentiableAt ğ•œ f x) :
    DifferentiableAt ğ•œ (fun y => f y - g y) x â†” DifferentiableAt ğ•œ g x := by
  simp only [sub_eq_add_neg, hg, add_iff_right, differentiableAt_neg_iff]

@[fun_prop]
theorem DifferentiableOn.sub (hf : DifferentiableOn ğ•œ f s) (hg : DifferentiableOn ğ•œ g s) :
    DifferentiableOn ğ•œ (fun y => f y - g y) s := fun x hx => (hf x hx).sub (hg x hx)

@[simp]
lemma DifferentiableOn.add_iff_left (hg : DifferentiableOn ğ•œ g s) :
    DifferentiableOn ğ•œ (fun y => f y + g y) s â†” DifferentiableOn ğ•œ f s := by
  refine âŸ¨fun h â†¦ ?_, fun hf â†¦ hf.add hgâŸ©
  simpa only [add_sub_cancel_right] using h.sub hg

@[simp]
lemma DifferentiableOn.add_iff_right (hg : DifferentiableOn ğ•œ f s) :
    DifferentiableOn ğ•œ (fun y => f y + g y) s â†” DifferentiableOn ğ•œ g s := by
  simp only [add_comm (f _), hg.add_iff_left]

@[simp]
lemma DifferentiableOn.sub_iff_left (hg : DifferentiableOn ğ•œ g s) :
    DifferentiableOn ğ•œ (fun y => f y - g y) s â†” DifferentiableOn ğ•œ f s := by
  simp only [sub_eq_add_neg, differentiableOn_neg_iff, hg, add_iff_left]

@[simp]
lemma DifferentiableOn.sub_iff_right (hg : DifferentiableOn ğ•œ f s) :
    DifferentiableOn ğ•œ (fun y => f y - g y) s â†” DifferentiableOn ğ•œ g s := by
  simp only [sub_eq_add_neg, differentiableOn_neg_iff, hg, add_iff_right]

@[simp, fun_prop]
theorem Differentiable.sub (hf : Differentiable ğ•œ f) (hg : Differentiable ğ•œ g) :
    Differentiable ğ•œ fun y => f y - g y := fun x => (hf x).sub (hg x)

@[simp]
lemma Differentiable.add_iff_left (hg : Differentiable ğ•œ g) :
    Differentiable ğ•œ (fun y => f y + g y) â†” Differentiable ğ•œ f := by
  refine âŸ¨fun h â†¦ ?_, fun hf â†¦ hf.add hgâŸ©
  simpa only [add_sub_cancel_right] using h.sub hg

@[simp]
lemma Differentiable.add_iff_right (hg : Differentiable ğ•œ f) :
    Differentiable ğ•œ (fun y => f y + g y) â†” Differentiable ğ•œ g := by
  simp only [add_comm (f _), hg.add_iff_left]

@[simp]
lemma Differentiable.sub_iff_left (hg : Differentiable ğ•œ g) :
    Differentiable ğ•œ (fun y => f y - g y) â†” Differentiable ğ•œ f := by
  simp only [sub_eq_add_neg, differentiable_neg_iff, hg, add_iff_left]

@[simp]
lemma Differentiable.sub_iff_right (hg : Differentiable ğ•œ f) :
    Differentiable ğ•œ (fun y => f y - g y) â†” Differentiable ğ•œ g := by
  simp only [sub_eq_add_neg, differentiable_neg_iff, hg, add_iff_right]

theorem fderivWithin_sub (hxs : UniqueDiffWithinAt ğ•œ s x) (hf : DifferentiableWithinAt ğ•œ f s x)
    (hg : DifferentiableWithinAt ğ•œ g s x) :
    fderivWithin ğ•œ (fun y => f y - g y) s x = fderivWithin ğ•œ f s x - fderivWithin ğ•œ g s x :=
  (hf.hasFDerivWithinAt.sub hg.hasFDerivWithinAt).fderivWithin hxs

/-- Version of `fderivWithin_sub` where the function is written as `f - g` instead
of `fun y â†¦ f y - g y`. -/
theorem fderivWithin_sub' (hxs : UniqueDiffWithinAt ğ•œ s x) (hf : DifferentiableWithinAt ğ•œ f s x)
    (hg : DifferentiableWithinAt ğ•œ g s x) :
    fderivWithin ğ•œ (f - g) s x = fderivWithin ğ•œ f s x - fderivWithin ğ•œ g s x :=
  fderivWithin_sub hxs hf hg

theorem fderiv_sub (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :
    fderiv ğ•œ (fun y => f y - g y) x = fderiv ğ•œ f x - fderiv ğ•œ g x :=
  (hf.hasFDerivAt.sub hg.hasFDerivAt).fderiv

/-- Version of `fderiv_sub` where the function is written as `f - g` instead
of `fun y â†¦ f y - g y`. -/
theorem fderiv_sub' (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :
    fderiv ğ•œ (f - g) x = fderiv ğ•œ f x - fderiv ğ•œ g x :=
  fderiv_sub hf hg

@[simp]
theorem hasFDerivAtFilter_sub_const_iff (c : F) :
    HasFDerivAtFilter (f Â· - c) f' x L â†” HasFDerivAtFilter f f' x L := by
  simp only [sub_eq_add_neg, hasFDerivAtFilter_add_const_iff]

alias âŸ¨_, HasFDerivAtFilter.sub_constâŸ© := hasFDerivAtFilter_sub_const_iff

@[simp]
theorem hasStrictFDerivAt_sub_const_iff (c : F) :
    HasStrictFDerivAt (f Â· - c) f' x â†” HasStrictFDerivAt f f' x := by
  simp only [sub_eq_add_neg, hasStrictFDerivAt_add_const_iff]

@[fun_prop]
alias âŸ¨_, HasStrictFDerivAt.sub_constâŸ© := hasStrictFDerivAt_sub_const_iff

@[simp]
theorem hasFDerivWithinAt_sub_const_iff (c : F) :
    HasFDerivWithinAt (f Â· - c) f' s x â†” HasFDerivWithinAt f f' s x :=
  hasFDerivAtFilter_sub_const_iff c

@[fun_prop]
alias âŸ¨_, HasFDerivWithinAt.sub_constâŸ© := hasFDerivWithinAt_sub_const_iff

@[simp]
theorem hasFDerivAt_sub_const_iff (c : F) : HasFDerivAt (f Â· - c) f' x â†” HasFDerivAt f f' x :=
  hasFDerivAtFilter_sub_const_iff c

@[fun_prop]
alias âŸ¨_, HasFDerivAt.sub_constâŸ© := hasFDerivAt_sub_const_iff

@[fun_prop]
theorem hasStrictFDerivAt_sub_const {x : F} (c : F) : HasStrictFDerivAt (Â· - c) (id ğ•œ F) x :=
  (hasStrictFDerivAt_id x).sub_const c

@[fun_prop]
theorem hasFDerivAt_sub_const {x : F} (c : F) : HasFDerivAt (Â· - c) (id ğ•œ F) x :=
  (hasFDerivAt_id x).sub_const c

@[fun_prop]
theorem DifferentiableWithinAt.sub_const (hf : DifferentiableWithinAt ğ•œ f s x) (c : F) :
    DifferentiableWithinAt ğ•œ (fun y => f y - c) s x :=
  (hf.hasFDerivWithinAt.sub_const c).differentiableWithinAt

@[simp]
theorem differentiableWithinAt_sub_const_iff (c : F) :
    DifferentiableWithinAt ğ•œ (fun y => f y - c) s x â†” DifferentiableWithinAt ğ•œ f s x := by
  simp only [sub_eq_add_neg, differentiableWithinAt_add_const_iff]

@[fun_prop]
theorem DifferentiableAt.sub_const (hf : DifferentiableAt ğ•œ f x) (c : F) :
    DifferentiableAt ğ•œ (fun y => f y - c) x :=
  (hf.hasFDerivAt.sub_const c).differentiableAt

@[fun_prop]
theorem DifferentiableOn.sub_const (hf : DifferentiableOn ğ•œ f s) (c : F) :
    DifferentiableOn ğ•œ (fun y => f y - c) s := fun x hx => (hf x hx).sub_const c

@[fun_prop]
theorem Differentiable.sub_const (hf : Differentiable ğ•œ f) (c : F) :
    Differentiable ğ•œ fun y => f y - c := fun x => (hf x).sub_const c

theorem fderivWithin_sub_const (c : F) :
    fderivWithin ğ•œ (fun y => f y - c) s x = fderivWithin ğ•œ f s x := by
  simp only [sub_eq_add_neg, fderivWithin_add_const]

theorem fderiv_sub_const (c : F) : fderiv ğ•œ (fun y => f y - c) x = fderiv ğ•œ f x := by
  simp only [sub_eq_add_neg, fderiv_add_const]

theorem HasFDerivAtFilter.const_sub (hf : HasFDerivAtFilter f f' x L) (c : F) :
    HasFDerivAtFilter (fun x => c - f x) (-f') x L := by
  simpa only [sub_eq_add_neg] using hf.neg.const_add c

@[fun_prop]
nonrec theorem HasStrictFDerivAt.const_sub (hf : HasStrictFDerivAt f f' x) (c : F) :
    HasStrictFDerivAt (fun x => c - f x) (-f') x := by
  simpa only [sub_eq_add_neg] using hf.neg.const_add c

@[fun_prop]
nonrec theorem HasFDerivWithinAt.const_sub (hf : HasFDerivWithinAt f f' s x) (c : F) :
    HasFDerivWithinAt (fun x => c - f x) (-f') s x :=
  hf.const_sub c

@[fun_prop]
nonrec theorem HasFDerivAt.const_sub (hf : HasFDerivAt f f' x) (c : F) :
    HasFDerivAt (fun x => c - f x) (-f') x :=
  hf.const_sub c

@[fun_prop]
theorem DifferentiableWithinAt.const_sub (hf : DifferentiableWithinAt ğ•œ f s x) (c : F) :
    DifferentiableWithinAt ğ•œ (fun y => c - f y) s x :=
  (hf.hasFDerivWithinAt.const_sub c).differentiableWithinAt

@[simp]
theorem differentiableWithinAt_const_sub_iff (c : F) :
    DifferentiableWithinAt ğ•œ (fun y => c - f y) s x â†” DifferentiableWithinAt ğ•œ f s x := by
  simp [sub_eq_add_neg]

@[fun_prop]
theorem DifferentiableAt.const_sub (hf : DifferentiableAt ğ•œ f x) (c : F) :
    DifferentiableAt ğ•œ (fun y => c - f y) x :=
  (hf.hasFDerivAt.const_sub c).differentiableAt

@[fun_prop]
theorem DifferentiableOn.const_sub (hf : DifferentiableOn ğ•œ f s) (c : F) :
    DifferentiableOn ğ•œ (fun y => c - f y) s := fun x hx => (hf x hx).const_sub c

@[fun_prop]
theorem Differentiable.const_sub (hf : Differentiable ğ•œ f) (c : F) :
    Differentiable ğ•œ fun y => c - f y := fun x => (hf x).const_sub c

theorem fderivWithin_const_sub (hxs : UniqueDiffWithinAt ğ•œ s x) (c : F) :
    fderivWithin ğ•œ (fun y => c - f y) s x = -fderivWithin ğ•œ f s x := by
  simp only [sub_eq_add_neg, fderivWithin_const_add, fderivWithin_neg, hxs]

theorem fderiv_const_sub (c : F) : fderiv ğ•œ (fun y => c - f y) x = -fderiv ğ•œ f x := by
  simp only [â† fderivWithin_univ, fderivWithin_const_sub uniqueDiffWithinAt_univ]

end Sub

section CompAdd

/-! ### Derivative of the composition with a translation -/

open scoped Pointwise Topology

theorem hasFDerivWithinAt_comp_add_left (a : E) :
    HasFDerivWithinAt (fun x â†¦ f (a + x)) f' s x â†” HasFDerivWithinAt f f' (a +áµ¥ s) (a + x) := by
  have : map (a + Â·) (ğ“[s] x) = ğ“[a +áµ¥ s] (a + x) := by
    simp only [add_comm x a, nhdsWithin, Filter.map_inf (add_right_injective a)]
    simp [â† Set.image_vadd]
  simp [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleOTVS, â† this, Function.comp_def]

theorem differentiableWithinAt_comp_add_left (a : E) :
    DifferentiableWithinAt ğ•œ (fun x â†¦ f (a + x)) s x â†”
      DifferentiableWithinAt ğ•œ f (a +áµ¥ s) (a + x) := by
  simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_add_left]

theorem fderivWithin_comp_add_left (a : E) :
    fderivWithin ğ•œ (fun x â†¦ f (a + x)) s x = fderivWithin ğ•œ f (a +áµ¥ s) (a + x) := by
  classical
  simp only [fderivWithin, hasFDerivWithinAt_comp_add_left, differentiableWithinAt_comp_add_left]

theorem hasFDerivWithinAt_comp_add_right (a : E) :
    HasFDerivWithinAt (fun x â†¦ f (x + a)) f' s x â†” HasFDerivWithinAt f f' (a +áµ¥ s) (x + a) := by
  simpa only [add_comm a] using hasFDerivWithinAt_comp_add_left a

theorem differentiableWithinAt_comp_add_right (a : E) :
    DifferentiableWithinAt ğ•œ (fun x â†¦ f (x + a)) s x â†”
      DifferentiableWithinAt ğ•œ f (a +áµ¥ s) (x + a) := by
  simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_add_right]

theorem fderivWithin_comp_add_right (a : E) :
    fderivWithin ğ•œ (fun x â†¦ f (x + a)) s x = fderivWithin ğ•œ f (a +áµ¥ s) (x + a) := by
  simp only [add_comm _ a, fderivWithin_comp_add_left]

theorem hasFDerivAt_comp_add_right (a : E) :
    HasFDerivAt (fun x â†¦ f (x + a)) f' x â†” HasFDerivAt f f' (x + a) := by
  simp [â† hasFDerivWithinAt_univ, hasFDerivWithinAt_comp_add_right]

theorem differentiableAt_comp_add_right (a : E) :
    DifferentiableAt ğ•œ (fun x â†¦ f (x + a)) x â†” DifferentiableAt ğ•œ f (x + a) := by
  simp [DifferentiableAt, hasFDerivAt_comp_add_right]

theorem fderiv_comp_add_right (a : E) :
    fderiv ğ•œ (fun x â†¦ f (x + a)) x = fderiv ğ•œ f (x + a) := by
  simp [â† fderivWithin_univ, fderivWithin_comp_add_right]

theorem hasFDerivAt_comp_add_left (a : E) :
    HasFDerivAt (fun x â†¦ f (a + x)) f' x â†” HasFDerivAt f f' (a + x) := by
  simpa [add_comm a] using hasFDerivAt_comp_add_right a

theorem differentiableAt_comp_add_left (a : E) :
    DifferentiableAt ğ•œ (fun x â†¦ f (a + x)) x â†” DifferentiableAt ğ•œ f (a + x) := by
  simp [DifferentiableAt, hasFDerivAt_comp_add_left]

theorem fderiv_comp_add_left (a : E) :
    fderiv ğ•œ (fun x â†¦ f (a + x)) x = fderiv ğ•œ f (a + x) := by
  simpa [add_comm a] using fderiv_comp_add_right a

theorem hasFDerivWithinAt_comp_sub (a : E) :
    HasFDerivWithinAt (fun x â†¦ f (x - a)) f' s x â†” HasFDerivWithinAt f f' (-a +áµ¥ s) (x - a) := by
  simpa [sub_eq_add_neg] using hasFDerivWithinAt_comp_add_right (-a)

theorem differentiableWithinAt_comp_sub (a : E) :
    DifferentiableWithinAt ğ•œ (fun x â†¦ f (x - a)) s x â†”
      DifferentiableWithinAt ğ•œ f (-a +áµ¥ s) (x - a) := by
  simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_sub]

theorem fderivWithin_comp_sub (a : E) :
    fderivWithin ğ•œ (fun x â†¦ f (x - a)) s x = fderivWithin ğ•œ f (-a +áµ¥ s) (x - a) := by
  simpa [sub_eq_add_neg] using fderivWithin_comp_add_right (-a)

theorem hasFDerivAt_comp_sub (a : E) :
    HasFDerivAt (fun x â†¦ f (x - a)) f' x â†” HasFDerivAt f f' (x - a) := by
  simp [â† hasFDerivWithinAt_univ, hasFDerivWithinAt_comp_sub]

theorem differentiableAt_comp_sub (a : E) :
    DifferentiableAt ğ•œ (fun x â†¦ f (x - a)) x â†” DifferentiableAt ğ•œ f (x - a) := by
  simp [DifferentiableAt, hasFDerivAt_comp_sub]

theorem fderiv_comp_sub (a : E) :
    fderiv ğ•œ (fun x â†¦ f (x - a)) x = fderiv ğ•œ f (x - a) := by
  simp [â† fderivWithin_univ, fderivWithin_comp_sub]

end CompAdd

end

-- END Mathlib.Analysis.Calculus.FDeriv.Add --

import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Analysis.Calculus.FDeriv.Mul
import Mathlib.Analysis.Calculus.FDeriv.Add

/-!
# Derivative of `f x * g x`

In this file we prove formulas for `(f x * g x)'` and `(f x â€¢ g x)'`.

For a more detailed overview of one-dimensional derivatives in mathlib, see the module docstring of
`Analysis/Calculus/Deriv/Basic`.

## Keywords

derivative, multiplication
-/

universe u v w

noncomputable section

open scoped Topology Filter ENNReal

open Filter Asymptotics Set

open ContinuousLinearMap (smulRight smulRight_one_eq_iff)

variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {f : ğ•œ â†’ F}
variable {f' : F}
variable {x : ğ•œ}
variable {s : Set ğ•œ}
variable {L : Filter ğ•œ}

/-! ### Derivative of bilinear maps -/

namespace ContinuousLinearMap

variable {B : E â†’L[ğ•œ] F â†’L[ğ•œ] G} {u : ğ•œ â†’ E} {v : ğ•œ â†’ F} {u' : E} {v' : F}

theorem hasDerivWithinAt_of_bilinear
    (hu : HasDerivWithinAt u u' s x) (hv : HasDerivWithinAt v v' s x) :
    HasDerivWithinAt (fun x â†¦ B (u x) (v x)) (B (u x) v' + B u' (v x)) s x := by

