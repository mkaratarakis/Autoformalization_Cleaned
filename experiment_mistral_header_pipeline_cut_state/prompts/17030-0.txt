
1. **Informal Theorem**  
Chain Rule for Derivatives along Filters: \((hâ‚‚ \circ h)'(x) = hâ‚‚'(h(x)) \cdot h'(x)\) : For any normed fields \(\mathbb{ğ•œ}\) and \(\mathbb{ğ•œ}'\) with \(\mathbb{ğ•œ}'\) being a normed algebra over \(\mathbb{ğ•œ}\), and for any functions \( h : \mathbb{ğ•œ} \to \mathbb{ğ•œ}' \) and \( hâ‚‚ : \mathbb{ğ•œ}' \to \mathbb{ğ•œ}' \), if \( h \) has a derivative \( h' \) at \( x \) along the filter \( L \), and \( hâ‚‚ \) has a derivative \( hâ‚‚' \) at \( h(x) \) along the filter \( L' \), and \( h \) tends to \( h(x) \) along the filter \( L \) to \( L' \), then the composition \( hâ‚‚ \circ h \) has a derivative \( hâ‚‚' \cdot h' \) at \( x \) along the filter \( L \).

2. **Informal Proof**  
We start by noting that the multiplication in a commutative magma is commutative, so we can rewrite the goal to show that the derivative of the composition \( hâ‚‚ \circ h \) at \( x \) along the filter \( L \) is \( h' \cdot hâ‚‚' \) instead of \( hâ‚‚' \cdot h' \).

Next, we apply the chain rule for scalar composition of functions with derivatives along filters. Specifically, since \( h \) has a derivative \( h' \) at \( x \) along the filter \( L \), and \( hâ‚‚ \) has a derivative \( hâ‚‚' \) at \( h(x) \) along the filter \( L' \), and \( h \) tends to \( h(x) \) along the filter \( L \) to \( L' \), the composition \( hâ‚‚ \circ h \) has a derivative \( h' \cdot hâ‚‚' \) at \( x \) along the filter \( L \).

Thus, the theorem is proved. \(\blacksquare\)

3. **Formal Theorem**  
example (hhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' (h x) L')
    (hh : HasDerivAtFilter h h' x L) (hL : Tendsto h L L') :
    HasDerivAtFilter (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x L := by sorry

4. **Prefix**
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Analysis.Calculus.FDeriv.Comp
import Mathlib.Analysis.Calculus.FDeriv.RestrictScalars
import Mathlib.Analysis.Calculus.Deriv.Comp

open HasDerivAtFilter
open scoped Classical Topology Filter ENNReal
open Filter Asymptotics Set
open ContinuousLinearMap (smulRight smulRight_one_eq_iff)
variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {f fâ‚€ fâ‚ g : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}
variable {ğ•œ' : Type*} [NontriviallyNormedField ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] [NormedSpace ğ•œ' F]
  [IsScalarTower ğ•œ ğ•œ' F] {s' t' : Set ğ•œ'} {h : ğ•œ â†’ ğ•œ'} {hâ‚ : ğ•œ â†’ ğ•œ} {hâ‚‚ : ğ•œ' â†’ ğ•œ'} {h' hâ‚‚' : ğ•œ'}
  {hâ‚' : ğ•œ} {gâ‚ : ğ•œ' â†’ F} {gâ‚' : F} {L' : Filter ğ•œ'} {y : ğ•œ'} (x)

example (hhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' (h x) L')
    (hh : HasDerivAtFilter h h' x L) (hL : Tendsto h L L') :
    HasDerivAtFilter (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x L := by

5. **Header Information**  
-- BEGIN Mathlib.Analysis.Calculus.Deriv.Basic --
/-
Copyright (c) 2019 Gabriel Ebner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner, SÃ©bastien GouÃ«zel
-/
import Mathlib.Analysis.Calculus.FDeriv.Basic
import Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace

/-!

# One-dimensional derivatives

This file defines the derivative of a function `f : ğ•œ â†’ F` where `ğ•œ` is a
normed field and `F` is a normed space over this field. The derivative of
such a function `f` at a point `x` is given by an element `f' : F`.

The theory is developed analogously to the [FrÃ©chet
derivatives](./fderiv.html). We first introduce predicates defined in terms
of the corresponding predicates for FrÃ©chet derivatives:

 - `HasDerivAtFilter f f' x L` states that the function `f` has the
    derivative `f'` at the point `x` as `x` goes along the filter `L`.

 - `HasDerivWithinAt f f' s x` states that the function `f` has the
    derivative `f'` at the point `x` within the subset `s`.

 - `HasDerivAt f f' x` states that the function `f` has the derivative `f'`
    at the point `x`.

 - `HasStrictDerivAt f f' x` states that the function `f` has the derivative `f'`
    at the point `x` in the sense of strict differentiability, i.e.,
   `f y - f z = (y - z) â€¢ f' + o (y - z)` as `y, z â†’ x`.

For the last two notions we also define a functional version:

  - `derivWithin f s x` is a derivative of `f` at `x` within `s`. If the
    derivative does not exist, then `derivWithin f s x` equals zero.

  - `deriv f x` is a derivative of `f` at `x`. If the derivative does not
    exist, then `deriv f x` equals zero.

The theorems `fderivWithin_derivWithin` and `fderiv_deriv` show that the
one-dimensional derivatives coincide with the general FrÃ©chet derivatives.

We also show the existence and compute the derivatives of:
  - constants
  - the identity function
  - linear maps (in `Linear.lean`)
  - addition (in `Add.lean`)
  - sum of finitely many functions (in `Add.lean`)
  - negation (in `Add.lean`)
  - subtraction (in `Add.lean`)
  - star (in `Star.lean`)
  - multiplication of two functions in `ğ•œ â†’ ğ•œ` (in `Mul.lean`)
  - multiplication of a function in `ğ•œ â†’ ğ•œ` and of a function in `ğ•œ â†’ E` (in `Mul.lean`)
  - powers of a function (in `Pow.lean` and `ZPow.lean`)
  - inverse `x â†’ xâ»Â¹` (in `Inv.lean`)
  - division (in `Inv.lean`)
  - composition of a function in `ğ•œ â†’ F` with a function in `ğ•œ â†’ ğ•œ` (in `Comp.lean`)
  - composition of a function in `F â†’ E` with a function in `ğ•œ â†’ F` (in `Comp.lean`)
  - inverse function (assuming that it exists; the inverse function theorem is in `Inverse.lean`)
  - polynomials (in `Polynomial.lean`)

For most binary operations we also define `const_op` and `op_const` theorems for the cases when
the first or second argument is a constant. This makes writing chains of `HasDerivAt`'s easier,
and they more frequently lead to the desired result.

We set up the simplifier so that it can compute the derivative of simple functions. For instance,
```lean
example (x : â„) :
    deriv (fun x â†¦ cos (sin x) * exp x) x = (cos (sin x) - sin (sin x) * cos x) * exp x := by
  simp; ring
```

The relationship between the derivative of a function and its definition from a standard
undergraduate course as the limit of the slope `(f y - f x) / (y - x)` as `y` tends to `ğ“[â‰ ] x`
is developed in the file `Slope.lean`.

## Implementation notes

Most of the theorems are direct restatements of the corresponding theorems
for FrÃ©chet derivatives.

The strategy to construct simp lemmas that give the simplifier the possibility to compute
derivatives is the same as the one for differentiability statements, as explained in
`FDeriv/Basic.lean`. See the explanations there.
-/

universe u v w

noncomputable section

open scoped Topology ENNReal NNReal
open Filter Asymptotics Set

open ContinuousLinearMap (smulRight smulRight_one_eq_iff)

section TVS

variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [AddCommGroup F] [Module ğ•œ F] [TopologicalSpace F]

section
variable [ContinuousSMul ğ•œ F]
/-- `f` has the derivative `f'` at the point `x` as `x` goes along the filter `L`.

That is, `f x' = f x + (x' - x) â€¢ f' + o(x' - x)` where `x'` converges along the filter `L`.
-/
def HasDerivAtFilter (f : ğ•œ â†’ F) (f' : F) (x : ğ•œ) (L : Filter ğ•œ) :=
  HasFDerivAtFilter f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x L

/-- `f` has the derivative `f'` at the point `x` within the subset `s`.

That is, `f x' = f x + (x' - x) â€¢ f' + o(x' - x)` where `x'` converges to `x` inside `s`.
-/
def HasDerivWithinAt (f : ğ•œ â†’ F) (f' : F) (s : Set ğ•œ) (x : ğ•œ) :=
  HasDerivAtFilter f f' x (ğ“[s] x)

/-- `f` has the derivative `f'` at the point `x`.

That is, `f x' = f x + (x' - x) â€¢ f' + o(x' - x)` where `x'` converges to `x`.
-/
def HasDerivAt (f : ğ•œ â†’ F) (f' : F) (x : ğ•œ) :=
  HasDerivAtFilter f f' x (ğ“ x)

/-- `f` has the derivative `f'` at the point `x` in the sense of strict differentiability.

That is, `f y - f z = (y - z) â€¢ f' + o(y - z)` as `y, z â†’ x`. -/
def HasStrictDerivAt (f : ğ•œ â†’ F) (f' : F) (x : ğ•œ) :=
  HasStrictFDerivAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x

end
/-- Derivative of `f` at the point `x` within the set `s`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `âˆƒ f', HasDerivWithinAt f f' s x`), then
`f x' = f x + (x' - x) â€¢ derivWithin f s x + o(x' - x)` where `x'` converges to `x` inside `s`.
-/
def derivWithin (f : ğ•œ â†’ F) (s : Set ğ•œ) (x : ğ•œ) :=
  fderivWithin ğ•œ f s x 1

/-- Derivative of `f` at the point `x`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `âˆƒ f', HasDerivAt f f' x`), then
`f x' = f x + (x' - x) â€¢ deriv f x + o(x' - x)` where `x'` converges to `x`.
-/
def deriv (f : ğ•œ â†’ F) (x : ğ•œ) :=
  fderiv ğ•œ f x 1

variable {f fâ‚€ fâ‚ : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}

section
variable [ContinuousSMul ğ•œ F]
/-- Expressing `HasFDerivAtFilter f f' x L` in terms of `HasDerivAtFilter` -/
theorem hasFDerivAtFilter_iff_hasDerivAtFilter {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivAtFilter f f' x L â†” HasDerivAtFilter f (f' 1) x L := by simp [HasDerivAtFilter]

theorem HasFDerivAtFilter.hasDerivAtFilter {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivAtFilter f f' x L â†’ HasDerivAtFilter f (f' 1) x L :=
  hasFDerivAtFilter_iff_hasDerivAtFilter.mp

/-- Expressing `HasFDerivWithinAt f f' s x` in terms of `HasDerivWithinAt` -/
theorem hasFDerivWithinAt_iff_hasDerivWithinAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivWithinAt f f' s x â†” HasDerivWithinAt f (f' 1) s x :=
  hasFDerivAtFilter_iff_hasDerivAtFilter

/-- Expressing `HasDerivWithinAt f f' s x` in terms of `HasFDerivWithinAt` -/
theorem hasDerivWithinAt_iff_hasFDerivWithinAt {f' : F} :
    HasDerivWithinAt f f' s x â†” HasFDerivWithinAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') s x :=
  Iff.rfl

theorem HasFDerivWithinAt.hasDerivWithinAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasFDerivWithinAt f f' s x â†’ HasDerivWithinAt f (f' 1) s x :=
  hasFDerivWithinAt_iff_hasDerivWithinAt.mp

theorem HasDerivWithinAt.hasFDerivWithinAt {f' : F} :
    HasDerivWithinAt f f' s x â†’ HasFDerivWithinAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') s x :=
  hasDerivWithinAt_iff_hasFDerivWithinAt.mp

/-- Expressing `HasFDerivAt f f' x` in terms of `HasDerivAt` -/
theorem hasFDerivAt_iff_hasDerivAt {f' : ğ•œ â†’L[ğ•œ] F} : HasFDerivAt f f' x â†” HasDerivAt f (f' 1) x :=
  hasFDerivAtFilter_iff_hasDerivAtFilter

theorem HasFDerivAt.hasDerivAt {f' : ğ•œ â†’L[ğ•œ] F} : HasFDerivAt f f' x â†’ HasDerivAt f (f' 1) x :=
  hasFDerivAt_iff_hasDerivAt.mp

theorem hasStrictFDerivAt_iff_hasStrictDerivAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasStrictFDerivAt f f' x â†” HasStrictDerivAt f (f' 1) x := by
  simp [HasStrictDerivAt, HasStrictFDerivAt]

protected theorem HasStrictFDerivAt.hasStrictDerivAt {f' : ğ•œ â†’L[ğ•œ] F} :
    HasStrictFDerivAt f f' x â†’ HasStrictDerivAt f (f' 1) x :=
  hasStrictFDerivAt_iff_hasStrictDerivAt.mp

theorem hasStrictDerivAt_iff_hasStrictFDerivAt :
    HasStrictDerivAt f f' x â†” HasStrictFDerivAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x :=
  Iff.rfl

alias âŸ¨HasStrictDerivAt.hasStrictFDerivAt, _âŸ© := hasStrictDerivAt_iff_hasStrictFDerivAt

/-- Expressing `HasDerivAt f f' x` in terms of `HasFDerivAt` -/
theorem hasDerivAt_iff_hasFDerivAt {f' : F} :
    HasDerivAt f f' x â†” HasFDerivAt f (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') x :=
  Iff.rfl

alias âŸ¨HasDerivAt.hasFDerivAt, _âŸ© := hasDerivAt_iff_hasFDerivAt

end
theorem derivWithin_zero_of_not_differentiableWithinAt (h : Â¬DifferentiableWithinAt ğ•œ f s x) :
    derivWithin f s x = 0 := by
  unfold derivWithin
  rw [fderivWithin_zero_of_not_differentiableWithinAt h]
  simp

theorem differentiableWithinAt_of_derivWithin_ne_zero (h : derivWithin f s x â‰  0) :
    DifferentiableWithinAt ğ•œ f s x :=
  not_imp_comm.1 derivWithin_zero_of_not_differentiableWithinAt h

end TVS

variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]

variable {f fâ‚€ fâ‚ : ğ•œ â†’ F}
variable {f' fâ‚€' fâ‚' g' : F}
variable {x : ğ•œ}
variable {s t : Set ğ•œ}
variable {L Lâ‚ Lâ‚‚ : Filter ğ•œ}

theorem derivWithin_zero_of_isolated (h : ğ“[s \ {x}] x = âŠ¥) : derivWithin f s x = 0 := by
  rw [derivWithin, fderivWithin_zero_of_isolated h, ContinuousLinearMap.zero_apply]

theorem derivWithin_zero_of_nmem_closure (h : x âˆ‰ closure s) : derivWithin f s x = 0 := by
  rw [derivWithin, fderivWithin_zero_of_nmem_closure h, ContinuousLinearMap.zero_apply]

theorem deriv_zero_of_not_differentiableAt (h : Â¬DifferentiableAt ğ•œ f x) : deriv f x = 0 := by
  unfold deriv
  rw [fderiv_zero_of_not_differentiableAt h]
  simp

theorem differentiableAt_of_deriv_ne_zero (h : deriv f x â‰  0) : DifferentiableAt ğ•œ f x :=
  not_imp_comm.1 deriv_zero_of_not_differentiableAt h

theorem UniqueDiffWithinAt.eq_deriv (s : Set ğ•œ) (H : UniqueDiffWithinAt ğ•œ s x)
    (h : HasDerivWithinAt f f' s x) (hâ‚ : HasDerivWithinAt f fâ‚' s x) : f' = fâ‚' :=
  smulRight_one_eq_iff.mp <| UniqueDiffWithinAt.eq H h hâ‚

theorem hasDerivAtFilter_iff_isLittleO :
    HasDerivAtFilter f f' x L â†” (fun x' : ğ•œ => f x' - f x - (x' - x) â€¢ f') =o[L] fun x' => x' - x :=
  hasFDerivAtFilter_iff_isLittleO ..

theorem hasDerivAtFilter_iff_tendsto :
    HasDerivAtFilter f f' x L â†”
      Tendsto (fun x' : ğ•œ => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - (x' - x) â€¢ f'â€–) L (ğ“ 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem hasDerivWithinAt_iff_isLittleO :
    HasDerivWithinAt f f' s x â†”
      (fun x' : ğ•œ => f x' - f x - (x' - x) â€¢ f') =o[ğ“[s] x] fun x' => x' - x :=
  hasFDerivAtFilter_iff_isLittleO ..

theorem hasDerivWithinAt_iff_tendsto :
    HasDerivWithinAt f f' s x â†”
      Tendsto (fun x' => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - (x' - x) â€¢ f'â€–) (ğ“[s] x) (ğ“ 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem hasDerivAt_iff_isLittleO :
    HasDerivAt f f' x â†” (fun x' : ğ•œ => f x' - f x - (x' - x) â€¢ f') =o[ğ“ x] fun x' => x' - x :=
  hasFDerivAtFilter_iff_isLittleO ..

theorem hasDerivAt_iff_tendsto :
    HasDerivAt f f' x â†” Tendsto (fun x' => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - (x' - x) â€¢ f'â€–) (ğ“ x) (ğ“ 0) :=
  hasFDerivAtFilter_iff_tendsto

theorem HasDerivAtFilter.isBigO_sub (h : HasDerivAtFilter f f' x L) :
    (fun x' => f x' - f x) =O[L] fun x' => x' - x :=
  HasFDerivAtFilter.isBigO_sub h

nonrec theorem HasDerivAtFilter.isBigO_sub_rev (hf : HasDerivAtFilter f f' x L) (hf' : f' â‰  0) :
    (fun x' => x' - x) =O[L] fun x' => f x' - f x :=
  suffices AntilipschitzWith â€–f'â€–â‚Šâ»Â¹ (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') from hf.isBigO_sub_rev this
  AddMonoidHomClass.antilipschitz_of_bound (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) f') fun x => by
    simp [norm_smul, â† div_eq_inv_mul, mul_div_cancel_rightâ‚€ _ (mt norm_eq_zero.1 hf')]

theorem HasStrictDerivAt.hasDerivAt (h : HasStrictDerivAt f f' x) : HasDerivAt f f' x :=
  h.hasFDerivAt

theorem hasDerivWithinAt_congr_set' {s t : Set ğ•œ} (y : ğ•œ) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :
    HasDerivWithinAt f f' s x â†” HasDerivWithinAt f f' t x :=
  hasFDerivWithinAt_congr_set' y h

theorem hasDerivWithinAt_congr_set {s t : Set ğ•œ} (h : s =á¶ [ğ“ x] t) :
    HasDerivWithinAt f f' s x â†” HasDerivWithinAt f f' t x :=
  hasFDerivWithinAt_congr_set h

alias âŸ¨HasDerivWithinAt.congr_set, _âŸ© := hasDerivWithinAt_congr_set

@[simp]
theorem hasDerivWithinAt_diff_singleton :
    HasDerivWithinAt f f' (s \ {x}) x â†” HasDerivWithinAt f f' s x :=
  hasFDerivWithinAt_diff_singleton _

@[simp]
theorem hasDerivWithinAt_Ioi_iff_Ici [PartialOrder ğ•œ] :
    HasDerivWithinAt f f' (Ioi x) x â†” HasDerivWithinAt f f' (Ici x) x := by
  rw [â† Ici_diff_left, hasDerivWithinAt_diff_singleton]

alias âŸ¨HasDerivWithinAt.Ici_of_Ioi, HasDerivWithinAt.Ioi_of_IciâŸ© := hasDerivWithinAt_Ioi_iff_Ici

@[simp]
theorem hasDerivWithinAt_Iio_iff_Iic [PartialOrder ğ•œ] :
    HasDerivWithinAt f f' (Iio x) x â†” HasDerivWithinAt f f' (Iic x) x := by
  rw [â† Iic_diff_right, hasDerivWithinAt_diff_singleton]

alias âŸ¨HasDerivWithinAt.Iic_of_Iio, HasDerivWithinAt.Iio_of_IicâŸ© := hasDerivWithinAt_Iio_iff_Iic

theorem HasDerivWithinAt.Ioi_iff_Ioo [LinearOrder ğ•œ] [OrderClosedTopology ğ•œ] {x y : ğ•œ} (h : x < y) :
    HasDerivWithinAt f f' (Ioo x y) x â†” HasDerivWithinAt f f' (Ioi x) x :=
  hasFDerivWithinAt_inter <| Iio_mem_nhds h

alias âŸ¨HasDerivWithinAt.Ioi_of_Ioo, HasDerivWithinAt.Ioo_of_IoiâŸ© := HasDerivWithinAt.Ioi_iff_Ioo

theorem hasDerivAt_iff_isLittleO_nhds_zero :
    HasDerivAt f f' x â†” (fun h => f (x + h) - f x - h â€¢ f') =o[ğ“ 0] fun h => h :=
  hasFDerivAt_iff_isLittleO_nhds_zero

theorem HasDerivAtFilter.mono (h : HasDerivAtFilter f f' x Lâ‚‚) (hst : Lâ‚ â‰¤ Lâ‚‚) :
    HasDerivAtFilter f f' x Lâ‚ :=
  HasFDerivAtFilter.mono h hst

theorem HasDerivWithinAt.mono (h : HasDerivWithinAt f f' t x) (hst : s âŠ† t) :
    HasDerivWithinAt f f' s x :=
  HasFDerivWithinAt.mono h hst

theorem HasDerivWithinAt.mono_of_mem_nhdsWithin (h : HasDerivWithinAt f f' t x) (hst : t âˆˆ ğ“[s] x) :
    HasDerivWithinAt f f' s x :=
  HasFDerivWithinAt.mono_of_mem_nhdsWithin h hst

@[deprecated (since := "2024-10-31")]
alias HasDerivWithinAt.mono_of_mem := HasDerivWithinAt.mono_of_mem_nhdsWithin

theorem HasDerivAt.hasDerivAtFilter (h : HasDerivAt f f' x) (hL : L â‰¤ ğ“ x) :
    HasDerivAtFilter f f' x L :=
  HasFDerivAt.hasFDerivAtFilter h hL

theorem HasDerivAt.hasDerivWithinAt (h : HasDerivAt f f' x) : HasDerivWithinAt f f' s x :=
  HasFDerivAt.hasFDerivWithinAt h

theorem HasDerivWithinAt.differentiableWithinAt (h : HasDerivWithinAt f f' s x) :
    DifferentiableWithinAt ğ•œ f s x :=
  HasFDerivWithinAt.differentiableWithinAt h

theorem HasDerivAt.differentiableAt (h : HasDerivAt f f' x) : DifferentiableAt ğ•œ f x :=
  HasFDerivAt.differentiableAt h

@[simp]
theorem hasDerivWithinAt_univ : HasDerivWithinAt f f' univ x â†” HasDerivAt f f' x :=
  hasFDerivWithinAt_univ

theorem HasDerivAt.unique (hâ‚€ : HasDerivAt f fâ‚€' x) (hâ‚ : HasDerivAt f fâ‚' x) : fâ‚€' = fâ‚' :=
  smulRight_one_eq_iff.mp <| hâ‚€.hasFDerivAt.unique hâ‚

theorem hasDerivWithinAt_inter' (h : t âˆˆ ğ“[s] x) :
    HasDerivWithinAt f f' (s âˆ© t) x â†” HasDerivWithinAt f f' s x :=
  hasFDerivWithinAt_inter' h

theorem hasDerivWithinAt_inter (h : t âˆˆ ğ“ x) :
    HasDerivWithinAt f f' (s âˆ© t) x â†” HasDerivWithinAt f f' s x :=
  hasFDerivWithinAt_inter h

theorem HasDerivWithinAt.union (hs : HasDerivWithinAt f f' s x) (ht : HasDerivWithinAt f f' t x) :
    HasDerivWithinAt f f' (s âˆª t) x :=
  hs.hasFDerivWithinAt.union ht.hasFDerivWithinAt

theorem HasDerivWithinAt.hasDerivAt (h : HasDerivWithinAt f f' s x) (hs : s âˆˆ ğ“ x) :
    HasDerivAt f f' x :=
  HasFDerivWithinAt.hasFDerivAt h hs

theorem DifferentiableWithinAt.hasDerivWithinAt (h : DifferentiableWithinAt ğ•œ f s x) :
    HasDerivWithinAt f (derivWithin f s x) s x :=
  h.hasFDerivWithinAt.hasDerivWithinAt

theorem DifferentiableAt.hasDerivAt (h : DifferentiableAt ğ•œ f x) : HasDerivAt f (deriv f x) x :=
  h.hasFDerivAt.hasDerivAt

@[simp]
theorem hasDerivAt_deriv_iff : HasDerivAt f (deriv f x) x â†” DifferentiableAt ğ•œ f x :=
  âŸ¨fun h => h.differentiableAt, fun h => h.hasDerivAtâŸ©

@[simp]
theorem hasDerivWithinAt_derivWithin_iff :
    HasDerivWithinAt f (derivWithin f s x) s x â†” DifferentiableWithinAt ğ•œ f s x :=
  âŸ¨fun h => h.differentiableWithinAt, fun h => h.hasDerivWithinAtâŸ©

theorem DifferentiableOn.hasDerivAt (h : DifferentiableOn ğ•œ f s) (hs : s âˆˆ ğ“ x) :
    HasDerivAt f (deriv f x) x :=
  (h.hasFDerivAt hs).hasDerivAt

theorem HasDerivAt.deriv (h : HasDerivAt f f' x) : deriv f x = f' :=
  h.differentiableAt.hasDerivAt.unique h

theorem deriv_eq {f' : ğ•œ â†’ F} (h : âˆ€ x, HasDerivAt f (f' x) x) : deriv f = f' :=
  funext fun x => (h x).deriv

theorem HasDerivWithinAt.derivWithin (h : HasDerivWithinAt f f' s x)
    (hxs : UniqueDiffWithinAt ğ•œ s x) : derivWithin f s x = f' :=
  hxs.eq_deriv _ h.differentiableWithinAt.hasDerivWithinAt h

theorem fderivWithin_derivWithin : (fderivWithin ğ•œ f s x : ğ•œ â†’ F) 1 = derivWithin f s x :=
  rfl

theorem derivWithin_fderivWithin :
    smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (derivWithin f s x) = fderivWithin ğ•œ f s x := by simp [derivWithin]

theorem norm_derivWithin_eq_norm_fderivWithin : â€–derivWithin f s xâ€– = â€–fderivWithin ğ•œ f s xâ€– := by
  simp [â† derivWithin_fderivWithin]

theorem fderiv_deriv : (fderiv ğ•œ f x : ğ•œ â†’ F) 1 = deriv f x :=
  rfl

@[simp]
theorem fderiv_eq_smul_deriv (y : ğ•œ) : (fderiv ğ•œ f x : ğ•œ â†’ F) y = y â€¢ deriv f x := by
  rw [â† fderiv_deriv, â† ContinuousLinearMap.map_smul]
  simp only [smul_eq_mul, mul_one]

theorem deriv_fderiv : smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (deriv f x) = fderiv ğ•œ f x := by
  simp only [deriv, ContinuousLinearMap.smulRight_one_one]

lemma fderiv_eq_deriv_mul {f : ğ•œ â†’ ğ•œ} {x y : ğ•œ} : (fderiv ğ•œ f x : ğ•œ â†’ ğ•œ) y = (deriv f x) * y := by
  simp [mul_comm]

theorem norm_deriv_eq_norm_fderiv : â€–deriv f xâ€– = â€–fderiv ğ•œ f xâ€– := by
  simp [â† deriv_fderiv]

theorem DifferentiableAt.derivWithin (h : DifferentiableAt ğ•œ f x) (hxs : UniqueDiffWithinAt ğ•œ s x) :
    derivWithin f s x = deriv f x := by
  unfold _root_.derivWithin deriv
  rw [h.fderivWithin hxs]

theorem HasDerivWithinAt.deriv_eq_zero (hd : HasDerivWithinAt f 0 s x)
    (H : UniqueDiffWithinAt ğ•œ s x) : deriv f x = 0 :=
  (em' (DifferentiableAt ğ•œ f x)).elim deriv_zero_of_not_differentiableAt fun h =>
    H.eq_deriv _ h.hasDerivAt.hasDerivWithinAt hd

theorem derivWithin_of_mem_nhdsWithin (st : t âˆˆ ğ“[s] x) (ht : UniqueDiffWithinAt ğ•œ s x)
    (h : DifferentiableWithinAt ğ•œ f t x) : derivWithin f s x = derivWithin f t x :=
  ((DifferentiableWithinAt.hasDerivWithinAt h).mono_of_mem_nhdsWithin st).derivWithin ht

@[deprecated (since := "2024-10-31")] alias derivWithin_of_mem := derivWithin_of_mem_nhdsWithin

theorem derivWithin_subset (st : s âŠ† t) (ht : UniqueDiffWithinAt ğ•œ s x)
    (h : DifferentiableWithinAt ğ•œ f t x) : derivWithin f s x = derivWithin f t x :=
  ((DifferentiableWithinAt.hasDerivWithinAt h).mono st).derivWithin ht

theorem derivWithin_congr_set' (y : ğ•œ) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :
    derivWithin f s x = derivWithin f t x := by simp only [derivWithin, fderivWithin_congr_set' y h]

theorem derivWithin_congr_set (h : s =á¶ [ğ“ x] t) : derivWithin f s x = derivWithin f t x := by
  simp only [derivWithin, fderivWithin_congr_set h]

@[simp]
theorem derivWithin_univ : derivWithin f univ = deriv f := by
  ext
  unfold derivWithin deriv
  rw [fderivWithin_univ]

theorem derivWithin_inter (ht : t âˆˆ ğ“ x) : derivWithin f (s âˆ© t) x = derivWithin f s x := by
  unfold derivWithin
  rw [fderivWithin_inter ht]

theorem derivWithin_of_mem_nhds (h : s âˆˆ ğ“ x) : derivWithin f s x = deriv f x := by
  simp only [derivWithin, deriv, fderivWithin_of_mem_nhds h]

theorem derivWithin_of_isOpen (hs : IsOpen s) (hx : x âˆˆ s) : derivWithin f s x = deriv f x :=
  derivWithin_of_mem_nhds (hs.mem_nhds hx)

lemma deriv_eqOn {f' : ğ•œ â†’ F} (hs : IsOpen s) (hf' : âˆ€ x âˆˆ s, HasDerivWithinAt f (f' x) s x) :
    s.EqOn (deriv f) f' := fun x hx â†¦ by
  rw [â† derivWithin_of_isOpen hs hx, (hf' _ hx).derivWithin <| hs.uniqueDiffWithinAt hx]

theorem deriv_mem_iff {f : ğ•œ â†’ F} {s : Set F} {x : ğ•œ} :
    deriv f x âˆˆ s â†”
      DifferentiableAt ğ•œ f x âˆ§ deriv f x âˆˆ s âˆ¨ Â¬DifferentiableAt ğ•œ f x âˆ§ (0 : F) âˆˆ s := by
  by_cases hx : DifferentiableAt ğ•œ f x <;> simp [deriv_zero_of_not_differentiableAt, *]

theorem derivWithin_mem_iff {f : ğ•œ â†’ F} {t : Set ğ•œ} {s : Set F} {x : ğ•œ} :
    derivWithin f t x âˆˆ s â†”
      DifferentiableWithinAt ğ•œ f t x âˆ§ derivWithin f t x âˆˆ s âˆ¨
        Â¬DifferentiableWithinAt ğ•œ f t x âˆ§ (0 : F) âˆˆ s := by
  by_cases hx : DifferentiableWithinAt ğ•œ f t x <;>
    simp [derivWithin_zero_of_not_differentiableWithinAt, *]

theorem differentiableWithinAt_Ioi_iff_Ici [PartialOrder ğ•œ] :
    DifferentiableWithinAt ğ•œ f (Ioi x) x â†” DifferentiableWithinAt ğ•œ f (Ici x) x :=
  âŸ¨fun h => h.hasDerivWithinAt.Ici_of_Ioi.differentiableWithinAt, fun h =>
    h.hasDerivWithinAt.Ioi_of_Ici.differentiableWithinAtâŸ©

-- Golfed while splitting the file
theorem derivWithin_Ioi_eq_Ici {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] (f : â„ â†’ E)
    (x : â„) : derivWithin f (Ioi x) x = derivWithin f (Ici x) x := by
  by_cases H : DifferentiableWithinAt â„ f (Ioi x) x
  Â· have A := H.hasDerivWithinAt.Ici_of_Ioi
    have B := (differentiableWithinAt_Ioi_iff_Ici.1 H).hasDerivWithinAt
    simpa using (uniqueDiffOn_Ici x).eq left_mem_Ici A B
  Â· rw [derivWithin_zero_of_not_differentiableWithinAt H,
      derivWithin_zero_of_not_differentiableWithinAt]
    rwa [differentiableWithinAt_Ioi_iff_Ici] at H

section congr

/-! ### Congruence properties of derivatives -/

theorem Filter.EventuallyEq.hasDerivAtFilter_iff (hâ‚€ : fâ‚€ =á¶ [L] fâ‚) (hx : fâ‚€ x = fâ‚ x)
    (hâ‚ : fâ‚€' = fâ‚') : HasDerivAtFilter fâ‚€ fâ‚€' x L â†” HasDerivAtFilter fâ‚ fâ‚' x L :=
  hâ‚€.hasFDerivAtFilter_iff hx (by simp [hâ‚])

theorem HasDerivAtFilter.congr_of_eventuallyEq (h : HasDerivAtFilter f f' x L) (hL : fâ‚ =á¶ [L] f)
    (hx : fâ‚ x = f x) : HasDerivAtFilter fâ‚ f' x L := by rwa [hL.hasDerivAtFilter_iff hx rfl]

theorem HasDerivWithinAt.congr_mono (h : HasDerivWithinAt f f' s x) (ht : âˆ€ x âˆˆ t, fâ‚ x = f x)
    (hx : fâ‚ x = f x) (hâ‚ : t âŠ† s) : HasDerivWithinAt fâ‚ f' t x :=
  HasFDerivWithinAt.congr_mono h ht hx hâ‚

theorem HasDerivWithinAt.congr (h : HasDerivWithinAt f f' s x) (hs : âˆ€ x âˆˆ s, fâ‚ x = f x)
    (hx : fâ‚ x = f x) : HasDerivWithinAt fâ‚ f' s x :=
  h.congr_mono hs hx (Subset.refl _)

theorem HasDerivWithinAt.congr_of_mem (h : HasDerivWithinAt f f' s x) (hs : âˆ€ x âˆˆ s, fâ‚ x = f x)
    (hx : x âˆˆ s) : HasDerivWithinAt fâ‚ f' s x :=
  h.congr hs (hs _ hx)

theorem HasDerivWithinAt.congr_of_eventuallyEq (h : HasDerivWithinAt f f' s x)
    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) : HasDerivWithinAt fâ‚ f' s x :=
  HasDerivAtFilter.congr_of_eventuallyEq h hâ‚ hx

theorem Filter.EventuallyEq.hasDerivWithinAt_iff (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :
    HasDerivWithinAt fâ‚ f' s x â†” HasDerivWithinAt f f' s x :=
  âŸ¨fun h' â†¦ h'.congr_of_eventuallyEq hâ‚.symm hx.symm, fun h' â†¦ h'.congr_of_eventuallyEq hâ‚ hxâŸ©

theorem HasDerivWithinAt.congr_of_eventuallyEq_of_mem (h : HasDerivWithinAt f f' s x)
    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) : HasDerivWithinAt fâ‚ f' s x :=
  h.congr_of_eventuallyEq hâ‚ (hâ‚.eq_of_nhdsWithin hx)

theorem Filter.EventuallyEq.hasDerivWithinAt_iff_of_mem (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) :
    HasDerivWithinAt fâ‚ f' s x â†” HasDerivWithinAt f f' s x :=
  âŸ¨fun h' â†¦ h'.congr_of_eventuallyEq_of_mem hâ‚.symm hx,
  fun h' â†¦ h'.congr_of_eventuallyEq_of_mem hâ‚ hxâŸ©

theorem HasStrictDerivAt.congr_deriv (h : HasStrictDerivAt f f' x) (h' : f' = g') :
    HasStrictDerivAt f g' x :=
  h.congr_fderiv <| congr_arg _ h'

theorem HasDerivAt.congr_deriv (h : HasDerivAt f f' x) (h' : f' = g') : HasDerivAt f g' x :=
  HasFDerivAt.congr_fderiv h <| congr_arg _ h'

theorem HasDerivWithinAt.congr_deriv (h : HasDerivWithinAt f f' s x) (h' : f' = g') :
    HasDerivWithinAt f g' s x :=
  HasFDerivWithinAt.congr_fderiv h <| congr_arg _ h'

theorem HasDerivAt.congr_of_eventuallyEq (h : HasDerivAt f f' x) (hâ‚ : fâ‚ =á¶ [ğ“ x] f) :
    HasDerivAt fâ‚ f' x :=
  HasDerivAtFilter.congr_of_eventuallyEq h hâ‚ (mem_of_mem_nhds hâ‚ :)

theorem Filter.EventuallyEq.hasDerivAt_iff (h : fâ‚€ =á¶ [ğ“ x] fâ‚) :
    HasDerivAt fâ‚€ f' x â†” HasDerivAt fâ‚ f' x :=
  âŸ¨fun h' â†¦ h'.congr_of_eventuallyEq h.symm, fun h' â†¦ h'.congr_of_eventuallyEq hâŸ©

theorem Filter.EventuallyEq.derivWithin_eq (hs : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :
    derivWithin fâ‚ s x = derivWithin f s x := by
  unfold derivWithin
  rw [hs.fderivWithin_eq hx]

theorem derivWithin_congr (hs : EqOn fâ‚ f s) (hx : fâ‚ x = f x) :
    derivWithin fâ‚ s x = derivWithin f s x := by
  unfold derivWithin
  rw [fderivWithin_congr hs hx]

theorem Filter.EventuallyEq.deriv_eq (hL : fâ‚ =á¶ [ğ“ x] f) : deriv fâ‚ x = deriv f x := by
  unfold deriv
  rwa [Filter.EventuallyEq.fderiv_eq]

protected theorem Filter.EventuallyEq.deriv (h : fâ‚ =á¶ [ğ“ x] f) : deriv fâ‚ =á¶ [ğ“ x] deriv f :=
  h.eventuallyEq_nhds.mono fun _ h => h.deriv_eq

end congr

section id

/-! ### Derivative of the identity -/

variable (s x L)

theorem hasDerivAtFilter_id : HasDerivAtFilter id 1 x L :=
  (hasFDerivAtFilter_id x L).hasDerivAtFilter

theorem hasDerivWithinAt_id : HasDerivWithinAt id 1 s x :=
  hasDerivAtFilter_id _ _

theorem hasDerivAt_id : HasDerivAt id 1 x :=
  hasDerivAtFilter_id _ _

theorem hasDerivAt_id' : HasDerivAt (fun x : ğ•œ => x) 1 x :=
  hasDerivAtFilter_id _ _

theorem hasStrictDerivAt_id : HasStrictDerivAt id 1 x :=
  (hasStrictFDerivAt_id x).hasStrictDerivAt

theorem deriv_id : deriv id x = 1 :=
  HasDerivAt.deriv (hasDerivAt_id x)

@[simp]
theorem deriv_id' : deriv (@id ğ•œ) = fun _ => 1 :=
  funext deriv_id

/-- Variant with `fun x => x` rather than `id` -/
@[simp]
theorem deriv_id'' : (deriv fun x : ğ•œ => x) = fun _ => 1 :=
  deriv_id'

theorem derivWithin_id (hxs : UniqueDiffWithinAt ğ•œ s x) : derivWithin id s x = 1 :=
  (hasDerivWithinAt_id x s).derivWithin hxs

/-- Variant with `fun x => x` rather than `id` -/
theorem derivWithin_id' (hxs : UniqueDiffWithinAt ğ•œ s x) : derivWithin (fun x => x) s x = 1 :=
  derivWithin_id x s hxs

end id

section Const

/-! ### Derivative of constant functions

This include the constant functions `0`, `1`, `Nat.cast n`, `Int.cast z`, and other numerals.
-/

variable (c : F) (s x L)

theorem hasDerivAtFilter_const : HasDerivAtFilter (fun _ => c) 0 x L :=
  (hasFDerivAtFilter_const c x L).hasDerivAtFilter

theorem hasDerivAtFilter_zero : HasDerivAtFilter (0 : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_one [One F] : HasDerivAtFilter (1 : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_natCast [NatCast F] (n : â„•) : HasDerivAtFilter (n : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_intCast [IntCast F] (z : â„¤) : HasDerivAtFilter (z : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAtFilter_ofNat (n : â„•) [OfNat F n] : HasDerivAtFilter (ofNat(n) : ğ•œ â†’ F) 0 x L :=
  hasDerivAtFilter_const _ _ _

theorem hasStrictDerivAt_const : HasStrictDerivAt (fun _ => c) 0 x :=
  (hasStrictFDerivAt_const c x).hasStrictDerivAt

theorem hasStrictDerivAt_zero : HasStrictDerivAt (0 : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasStrictDerivAt_one [One F] : HasStrictDerivAt (1 : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasStrictDerivAt_natCast [NatCast F] (n : â„•) : HasStrictDerivAt (n : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasStrictDerivAt_intCast [IntCast F] (z : â„¤) : HasStrictDerivAt (z : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem HasStrictDerivAt_ofNat (n : â„•) [OfNat F n] : HasStrictDerivAt (ofNat(n) : ğ•œ â†’ F) 0 x :=
  hasStrictDerivAt_const _ _

theorem hasDerivWithinAt_const : HasDerivWithinAt (fun _ => c) 0 s x :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivWithinAt_zero : HasDerivWithinAt (0 : ğ•œ â†’ F) 0 s x :=
  hasDerivAtFilter_zero _ _

theorem hasDerivWithinAt_one [One F] : HasDerivWithinAt (1 : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivWithinAt_natCast [NatCast F] (n : â„•) : HasDerivWithinAt (n : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivWithinAt_intCast [IntCast F] (z : â„¤) : HasDerivWithinAt (z : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivWithinAt_ofNat (n : â„•) [OfNat F n] : HasDerivWithinAt (ofNat(n) : ğ•œ â†’ F) 0 s x :=
  hasDerivWithinAt_const _ _ _

theorem hasDerivAt_const : HasDerivAt (fun _ => c) 0 x :=
  hasDerivAtFilter_const _ _ _

theorem hasDerivAt_zero : HasDerivAt (0 : ğ•œ â†’ F) 0 x :=
  hasDerivAtFilter_zero _ _

theorem hasDerivAt_one [One F] : HasDerivAt (1 : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem hasDerivAt_natCast [NatCast F] (n : â„•) : HasDerivAt (n : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem hasDerivAt_intCast [IntCast F] (z : â„¤) : HasDerivAt (z : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem hasDerivAt_ofNat (n : â„•) [OfNat F n] : HasDerivAt (ofNat(n) : ğ•œ â†’ F) 0 x :=
  hasDerivAt_const _ _

theorem deriv_const : deriv (fun _ => c) x = 0 :=
  HasDerivAt.deriv (hasDerivAt_const x c)

@[simp]
theorem deriv_const' : (deriv fun _ : ğ•œ => c) = fun _ => 0 :=
  funext fun x => deriv_const x c

@[simp]
theorem deriv_zero : deriv (0 : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp]
theorem deriv_one [One F] : deriv (1 : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp]
theorem deriv_natCast [NatCast F] (n : â„•) : deriv (n : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp]
theorem deriv_intCast [IntCast F] (z : â„¤) : deriv (z : ğ•œ â†’ F) = 0 := funext fun _ => deriv_const _ _

@[simp low]
theorem deriv_ofNat (n : â„•) [OfNat F n] : deriv (ofNat(n) : ğ•œ â†’ F) = 0 :=
  funext fun _ => deriv_const _ _

@[simp]
theorem derivWithin_const : derivWithin (fun _ => c) s = 0 := by
  ext; simp [derivWithin]

@[simp]
theorem derivWithin_zero : derivWithin (0 : ğ•œ â†’ F) s = 0 := derivWithin_const _ _

@[simp]
theorem derivWithin_one [One F] : derivWithin (1 : ğ•œ â†’ F) s = 0 := derivWithin_const _ _

@[simp]
theorem derivWithin_natCast [NatCast F] (n : â„•) : derivWithin (n : ğ•œ â†’ F) s = 0 :=
  derivWithin_const _ _

@[simp]
theorem derivWithin_intCast [IntCast F] (z : â„¤) : derivWithin (z : ğ•œ â†’ F) s = 0 :=
  derivWithin_const _ _

@[simp low]
theorem derivWithin_ofNat (n : â„•) [OfNat F n] : derivWithin (ofNat(n) : ğ•œ â†’ F) s = 0 :=
  derivWithin_const _ _

end Const

section Continuous

/-! ### Continuity of a function admitting a derivative -/

nonrec theorem HasDerivAtFilter.tendsto_nhds (hL : L â‰¤ ğ“ x) (h : HasDerivAtFilter f f' x L) :
    Tendsto f L (ğ“ (f x)) :=
  h.tendsto_nhds hL

theorem HasDerivWithinAt.continuousWithinAt (h : HasDerivWithinAt f f' s x) :
    ContinuousWithinAt f s x :=
  HasDerivAtFilter.tendsto_nhds inf_le_left h

theorem HasDerivAt.continuousAt (h : HasDerivAt f f' x) : ContinuousAt f x :=
  HasDerivAtFilter.tendsto_nhds le_rfl h

protected theorem HasDerivAt.continuousOn {f f' : ğ•œ â†’ F} (hderiv : âˆ€ x âˆˆ s, HasDerivAt f (f' x) x) :
    ContinuousOn f s := fun x hx => (hderiv x hx).continuousAt.continuousWithinAt

end Continuous

section MeanValue

/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. This version
only assumes that `â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–` in a neighborhood of `x`. -/
theorem HasDerivAt.le_of_lip' {f : ğ•œ â†’ F} {f' : F} {xâ‚€ : ğ•œ} (hf : HasDerivAt f f' xâ‚€)
    {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  x in ğ“ xâ‚€, â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–) :
    â€–f'â€– â‰¤ C := by
  simpa using HasFDerivAt.le_of_lip' hf.hasFDerivAt hCâ‚€ hlip

/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. -/
theorem HasDerivAt.le_of_lipschitzOn {f : ğ•œ â†’ F} {f' : F} {xâ‚€ : ğ•œ} (hf : HasDerivAt f f' xâ‚€)
    {s : Set ğ•œ} (hs : s âˆˆ ğ“ xâ‚€) {C : â„â‰¥0} (hlip : LipschitzOnWith C f s) : â€–f'â€– â‰¤ C := by
  simpa using HasFDerivAt.le_of_lipschitzOn hf.hasFDerivAt hs hlip

/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz
then its derivative at `xâ‚€` has norm bounded by `C`. -/
theorem HasDerivAt.le_of_lipschitz {f : ğ•œ â†’ F} {f' : F} {xâ‚€ : ğ•œ} (hf : HasDerivAt f f' xâ‚€)
    {C : â„â‰¥0} (hlip : LipschitzWith C f) : â€–f'â€– â‰¤ C := by
  simpa using HasFDerivAt.le_of_lipschitz hf.hasFDerivAt hlip

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. This version
only assumes that `â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–` in a neighborhood of `x`. -/
theorem norm_deriv_le_of_lip' {f : ğ•œ â†’ F} {xâ‚€ : ğ•œ}
    {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  x in ğ“ xâ‚€, â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–) :
    â€–deriv f xâ‚€â€– â‰¤ C := by
  simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lip' ğ•œ hCâ‚€ hlip

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz
on a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`.
Version using `deriv`. -/
theorem norm_deriv_le_of_lipschitzOn {f : ğ•œ â†’ F} {xâ‚€ : ğ•œ} {s : Set ğ•œ} (hs : s âˆˆ ğ“ xâ‚€)
    {C : â„â‰¥0} (hlip : LipschitzOnWith C f s) : â€–deriv f xâ‚€â€– â‰¤ C := by
  simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lipschitzOn ğ•œ hs hlip

/-- Converse to the mean value inequality: if `f` is `C`-lipschitz then
its derivative at `xâ‚€` has norm bounded by `C`.
Version using `deriv`. -/
theorem norm_deriv_le_of_lipschitz {f : ğ•œ â†’ F} {xâ‚€ : ğ•œ}
    {C : â„â‰¥0} (hlip : LipschitzWith C f) : â€–deriv f xâ‚€â€– â‰¤ C := by
  simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lipschitz ğ•œ hlip

end MeanValue

-- END Mathlib.Analysis.Calculus.Deriv.Basic --

-- BEGIN Mathlib.Analysis.Calculus.FDeriv.Comp --
/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, SÃ©bastien GouÃ«zel, Yury Kudryashov
-/
import Mathlib.Analysis.Calculus.FDeriv.Basic

/-!
# The derivative of a composition (chain rule)

For detailed documentation of the FrÃ©chet derivative,
see the module docstring of `Analysis/Calculus/FDeriv/Basic.lean`.

This file contains the usual formulas (and existence assertions) for the derivative of
composition of functions (the chain rule).
-/


open Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal

noncomputable section

section

variable {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]
variable {G' : Type*} [NormedAddCommGroup G'] [NormedSpace ğ•œ G']
variable {f g : E â†’ F} {f' g' : E â†’L[ğ•œ] F} {x : E} {s : Set E} {L : Filter E}

section Composition

/-!
### Derivative of the composition of two functions

For composition lemmas, we put `x` explicit to help the elaborator, as otherwise Lean tends to
get confused since there are too many possibilities for composition. -/


variable (x)

theorem HasFDerivAtFilter.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G} {L' : Filter F}
    (hg : HasFDerivAtFilter g g' (f x) L') (hf : HasFDerivAtFilter f f' x L) (hL : Tendsto f L L') :
    HasFDerivAtFilter (g âˆ˜ f) (g'.comp f') x L := by
  let eqâ‚ := (g'.isBigO_comp _ _).trans_isLittleO hf.isLittleO
  let eqâ‚‚ := (hg.isLittleO.comp_tendsto hL).trans_isBigO hf.isBigO_sub
  refine .of_isLittleO <| eqâ‚‚.triangle <| eqâ‚.congr_left fun x' => ?_
  simp

/- A readable version of the previous theorem, a general form of the chain rule. -/
example {g : F â†’ G} {g' : F â†’L[ğ•œ] G} (hg : HasFDerivAtFilter g g' (f x) (L.map f))
    (hf : HasFDerivAtFilter f f' x L) : HasFDerivAtFilter (g âˆ˜ f) (g'.comp f') x L := by
  have :=
    calc
      (fun x' => g (f x') - g (f x) - g' (f x' - f x)) =o[L] fun x' => f x' - f x :=
        hg.isLittleO.comp_tendsto le_rfl
      _ =O[L] fun x' => x' - x := hf.isBigO_sub
  refine .of_isLittleO <| this.triangle ?_
  calc
    (fun x' : E => g' (f x' - f x) - g'.comp f' (x' - x))
    _ =á¶ [L] fun x' => g' (f x' - f x - f' (x' - x)) := Eventually.of_forall fun x' => by simp
    _ =O[L] fun x' => f x' - f x - f' (x' - x) := g'.isBigO_comp _ _
    _ =o[L] fun x' => x' - x := hf.isLittleO

@[fun_prop]
theorem HasFDerivWithinAt.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G} {t : Set F}
    (hg : HasFDerivWithinAt g g' t (f x)) (hf : HasFDerivWithinAt f f' s x) (hst : MapsTo f s t) :
    HasFDerivWithinAt (g âˆ˜ f) (g'.comp f') s x :=
  HasFDerivAtFilter.comp x hg hf <| hf.continuousWithinAt.tendsto_nhdsWithin hst

@[fun_prop]
theorem HasFDerivAt.comp_hasFDerivWithinAt {g : F â†’ G} {g' : F â†’L[ğ•œ] G}
    (hg : HasFDerivAt g g' (f x)) (hf : HasFDerivWithinAt f f' s x) :
    HasFDerivWithinAt (g âˆ˜ f) (g'.comp f') s x :=
  hg.comp x hf hf.continuousWithinAt

@[fun_prop]
theorem HasFDerivWithinAt.comp_of_tendsto {g : F â†’ G} {g' : F â†’L[ğ•œ] G} {t : Set F}
    (hg : HasFDerivWithinAt g g' t (f x)) (hf : HasFDerivWithinAt f f' s x)
    (hst : Tendsto f (ğ“[s] x) (ğ“[t] f x)) : HasFDerivWithinAt (g âˆ˜ f) (g'.comp f') s x :=
  HasFDerivAtFilter.comp x hg hf hst

@[deprecated (since := "2024-10-18")]
alias HasFDerivWithinAt.comp_of_mem := HasFDerivWithinAt.comp_of_tendsto

/-- The chain rule. -/
@[fun_prop]
theorem HasFDerivAt.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G} (hg : HasFDerivAt g g' (f x))
    (hf : HasFDerivAt f f' x) : HasFDerivAt (g âˆ˜ f) (g'.comp f') x :=
  HasFDerivAtFilter.comp x hg hf hf.continuousAt

@[fun_prop]
theorem DifferentiableWithinAt.comp {g : F â†’ G} {t : Set F}
    (hg : DifferentiableWithinAt ğ•œ g t (f x)) (hf : DifferentiableWithinAt ğ•œ f s x)
    (h : MapsTo f s t) : DifferentiableWithinAt ğ•œ (g âˆ˜ f) s x :=
  (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h).differentiableWithinAt

@[fun_prop]
theorem DifferentiableWithinAt.comp' {g : F â†’ G} {t : Set F}
    (hg : DifferentiableWithinAt ğ•œ g t (f x)) (hf : DifferentiableWithinAt ğ•œ f s x) :
    DifferentiableWithinAt ğ•œ (g âˆ˜ f) (s âˆ© f â»Â¹' t) x :=
  hg.comp x (hf.mono inter_subset_left) inter_subset_right

@[fun_prop]
theorem DifferentiableAt.comp {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x))
    (hf : DifferentiableAt ğ•œ f x) : DifferentiableAt ğ•œ (g âˆ˜ f) x :=
  (hg.hasFDerivAt.comp x hf.hasFDerivAt).differentiableAt

@[fun_prop]
theorem DifferentiableAt.comp_differentiableWithinAt {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x))
    (hf : DifferentiableWithinAt ğ•œ f s x) : DifferentiableWithinAt ğ•œ (g âˆ˜ f) s x :=
  hg.differentiableWithinAt.comp x hf (mapsTo_univ _ _)

theorem fderivWithin_comp {g : F â†’ G} {t : Set F} (hg : DifferentiableWithinAt ğ•œ g t (f x))
    (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t) (hxs : UniqueDiffWithinAt ğ•œ s x) :
    fderivWithin ğ•œ (g âˆ˜ f) s x = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) :=
  (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h).fderivWithin hxs

@[deprecated (since := "2024-10-31")] alias fderivWithin.comp := fderivWithin_comp

theorem fderivWithin_comp_of_eq {g : F â†’ G} {t : Set F} {y : F}
    (hg : DifferentiableWithinAt ğ•œ g t y) (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t)
    (hxs : UniqueDiffWithinAt ğ•œ s x) (hy : f x = y) :
    fderivWithin ğ•œ (g âˆ˜ f) s x = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) := by
  subst hy; exact fderivWithin_comp _ hg hf h hxs

/-- A variant for the derivative of a composition, written without `âˆ˜`. -/
theorem fderivWithin_comp' {g : F â†’ G} {t : Set F} (hg : DifferentiableWithinAt ğ•œ g t (f x))
    (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t) (hxs : UniqueDiffWithinAt ğ•œ s x) :
    fderivWithin ğ•œ (fun y â†¦ g (f y)) s x
      = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) :=
  fderivWithin_comp _ hg hf h hxs

/-- A variant for the derivative of a composition, written without `âˆ˜`. -/
theorem fderivWithin_comp_of_eq' {g : F â†’ G} {t : Set F} {y : F}
    (hg : DifferentiableWithinAt ğ•œ g t y) (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t)
    (hxs : UniqueDiffWithinAt ğ•œ s x) (hy : f x = y) :
    fderivWithin ğ•œ (fun y â†¦ g (f y)) s x
      = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) := by
  subst hy; exact fderivWithin_comp _ hg hf h hxs

/-- A version of `fderivWithin_comp` that is useful to rewrite the composition of two derivatives
  into a single derivative. This version always applies, but creates a new side-goal `f x = y`. -/
theorem fderivWithin_fderivWithin {g : F â†’ G} {f : E â†’ F} {x : E} {y : F} {s : Set E} {t : Set F}
    (hg : DifferentiableWithinAt ğ•œ g t y) (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t)
    (hxs : UniqueDiffWithinAt ğ•œ s x) (hy : f x = y) (v : E) :
    fderivWithin ğ•œ g t y (fderivWithin ğ•œ f s x v) = fderivWithin ğ•œ (g âˆ˜ f) s x v := by
  subst y
  rw [fderivWithin_comp x hg hf h hxs, coe_comp', Function.comp_apply]

/-- Ternary version of `fderivWithin_comp`, with equality assumptions of basepoints added, in
  order to apply more easily as a rewrite from right-to-left. -/
theorem fderivWithin_compâ‚ƒ {g' : G â†’ G'} {g : F â†’ G} {t : Set F} {u : Set G} {y : F} {y' : G}
    (hg' : DifferentiableWithinAt ğ•œ g' u y') (hg : DifferentiableWithinAt ğ•œ g t y)
    (hf : DifferentiableWithinAt ğ•œ f s x) (h2g : MapsTo g t u) (h2f : MapsTo f s t) (h3g : g y = y')
    (h3f : f x = y) (hxs : UniqueDiffWithinAt ğ•œ s x) :
    fderivWithin ğ•œ (g' âˆ˜ g âˆ˜ f) s x =
      (fderivWithin ğ•œ g' u y').comp ((fderivWithin ğ•œ g t y).comp (fderivWithin ğ•œ f s x)) := by
  substs h3g h3f
  exact (hg'.hasFDerivWithinAt.comp x (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h2f) <|
    h2g.comp h2f).fderivWithin hxs

@[deprecated (since := "2024-10-31")] alias fderivWithin.compâ‚ƒ := fderivWithin_compâ‚ƒ

theorem fderiv_comp {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x)) (hf : DifferentiableAt ğ•œ f x) :
    fderiv ğ•œ (g âˆ˜ f) x = (fderiv ğ•œ g (f x)).comp (fderiv ğ•œ f x) :=
  (hg.hasFDerivAt.comp x hf.hasFDerivAt).fderiv

@[deprecated (since := "2024-10-31")] alias fderiv.comp := fderiv_comp

/-- A variant for the derivative of a composition, written without `âˆ˜`. -/
theorem fderiv_comp' {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x)) (hf : DifferentiableAt ğ•œ f x) :
    fderiv ğ•œ (fun y â†¦ g (f y)) x = (fderiv ğ•œ g (f x)).comp (fderiv ğ•œ f x) :=
  fderiv_comp x hg hf

theorem fderiv_comp_fderivWithin {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x))
    (hf : DifferentiableWithinAt ğ•œ f s x) (hxs : UniqueDiffWithinAt ğ•œ s x) :
    fderivWithin ğ•œ (g âˆ˜ f) s x = (fderiv ğ•œ g (f x)).comp (fderivWithin ğ•œ f s x) :=
  (hg.hasFDerivAt.comp_hasFDerivWithinAt x hf.hasFDerivWithinAt).fderivWithin hxs

@[deprecated (since := "2024-10-31")] alias fderiv.comp_fderivWithin := fderiv_comp_fderivWithin

@[fun_prop]
theorem DifferentiableOn.comp {g : F â†’ G} {t : Set F} (hg : DifferentiableOn ğ•œ g t)
    (hf : DifferentiableOn ğ•œ f s) (st : MapsTo f s t) : DifferentiableOn ğ•œ (g âˆ˜ f) s :=
  fun x hx => DifferentiableWithinAt.comp x (hg (f x) (st hx)) (hf x hx) st

@[fun_prop]
theorem Differentiable.comp {g : F â†’ G} (hg : Differentiable ğ•œ g) (hf : Differentiable ğ•œ f) :
    Differentiable ğ•œ (g âˆ˜ f) :=
  fun x => DifferentiableAt.comp x (hg (f x)) (hf x)

@[fun_prop]
theorem Differentiable.comp_differentiableOn {g : F â†’ G} (hg : Differentiable ğ•œ g)
    (hf : DifferentiableOn ğ•œ f s) : DifferentiableOn ğ•œ (g âˆ˜ f) s :=
  hg.differentiableOn.comp hf (mapsTo_univ _ _)

/-- The chain rule for derivatives in the sense of strict differentiability. -/
@[fun_prop]
protected theorem HasStrictFDerivAt.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G}
    (hg : HasStrictFDerivAt g g' (f x)) (hf : HasStrictFDerivAt f f' x) :
    HasStrictFDerivAt (fun x => g (f x)) (g'.comp f') x :=
  .of_isLittleO <|
    ((hg.isLittleO.comp_tendsto (hf.continuousAt.prodMap' hf.continuousAt)).trans_isBigO
        hf.isBigO_sub).triangle <| by
      simpa only [g'.map_sub, f'.coe_comp'] using (g'.isBigO_comp _ _).trans_isLittleO hf.isLittleO

@[fun_prop]
protected theorem Differentiable.iterate {f : E â†’ E} (hf : Differentiable ğ•œ f) (n : â„•) :
    Differentiable ğ•œ f^[n] :=
  Nat.recOn n differentiable_id fun _ ihn => ihn.comp hf

@[fun_prop]
protected theorem DifferentiableOn.iterate {f : E â†’ E} (hf : DifferentiableOn ğ•œ f s)
    (hs : MapsTo f s s) (n : â„•) : DifferentiableOn ğ•œ f^[n] s :=
  Nat.recOn n differentiableOn_id fun _ ihn => ihn.comp hf hs

variable {x}

protected theorem HasFDerivAtFilter.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E}
    (hf : HasFDerivAtFilter f f' x L) (hL : Tendsto f L L) (hx : f x = x) (n : â„•) :
    HasFDerivAtFilter f^[n] (f' ^ n) x L := by
  induction n with
  | zero => exact hasFDerivAtFilter_id x L
  | succ n ihn =>
    rw [Function.iterate_succ, pow_succ]
    rw [â† hx] at ihn
    exact ihn.comp x hf hL

@[fun_prop]
protected theorem HasFDerivAt.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E} (hf : HasFDerivAt f f' x)
    (hx : f x = x) (n : â„•) : HasFDerivAt f^[n] (f' ^ n) x := by
  refine HasFDerivAtFilter.iterate hf ?_ hx n
  convert hf.continuousAt.tendsto
  exact hx.symm

@[fun_prop]
protected theorem HasFDerivWithinAt.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E}
    (hf : HasFDerivWithinAt f f' s x) (hx : f x = x) (hs : MapsTo f s s) (n : â„•) :
    HasFDerivWithinAt f^[n] (f' ^ n) s x := by
  refine HasFDerivAtFilter.iterate hf ?_ hx n
  rw [nhdsWithin]
  convert tendsto_inf.2 âŸ¨hf.continuousWithinAt, _âŸ©
  exacts [hx.symm, (tendsto_principal_principal.2 hs).mono_left inf_le_right]

@[fun_prop]
protected theorem HasStrictFDerivAt.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E}
    (hf : HasStrictFDerivAt f f' x) (hx : f x = x) (n : â„•) :
    HasStrictFDerivAt f^[n] (f' ^ n) x := by
  induction n with
  | zero => exact hasStrictFDerivAt_id x
  | succ n ihn =>
    rw [Function.iterate_succ, pow_succ]
    rw [â† hx] at ihn
    exact ihn.comp x hf

@[fun_prop]
protected theorem DifferentiableAt.iterate {f : E â†’ E} (hf : DifferentiableAt ğ•œ f x) (hx : f x = x)
    (n : â„•) : DifferentiableAt ğ•œ f^[n] x :=
  (hf.hasFDerivAt.iterate hx n).differentiableAt

@[fun_prop]
protected theorem DifferentiableWithinAt.iterate {f : E â†’ E} (hf : DifferentiableWithinAt ğ•œ f s x)
    (hx : f x = x) (hs : MapsTo f s s) (n : â„•) : DifferentiableWithinAt ğ•œ f^[n] s x :=
  (hf.hasFDerivWithinAt.iterate hx hs n).differentiableWithinAt

end Composition

end

-- END Mathlib.Analysis.Calculus.FDeriv.Comp --

-- BEGIN Mathlib.Analysis.Calculus.FDeriv.RestrictScalars --
/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, SÃ©bastien GouÃ«zel, Yury Kudryashov
-/
import Mathlib.Analysis.Calculus.FDeriv.Basic

/-!
# The derivative of the scalar restriction of a linear map

For detailed documentation of the FrÃ©chet derivative,
see the module docstring of `Analysis/Calculus/FDeriv/Basic.lean`.

This file contains the usual formulas (and existence assertions) for the derivative of
the scalar restriction of a linear map.
-/


open Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal

noncomputable section

section RestrictScalars

/-!
### Restricting from `â„‚` to `â„`, or generally from `ğ•œ'` to `ğ•œ`

If a function is differentiable over `â„‚`, then it is differentiable over `â„`. In this paragraph,
we give variants of this statement, in the general situation where `â„‚` and `â„` are replaced
respectively by `ğ•œ'` and `ğ•œ` where `ğ•œ'` is a normed algebra over `ğ•œ`.
-/


variable (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]
variable {ğ•œ' : Type*} [NontriviallyNormedField ğ•œ'] [NormedAlgebra ğ•œ ğ•œ']
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E] [NormedSpace ğ•œ' E]
variable [IsScalarTower ğ•œ ğ•œ' E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F] [NormedSpace ğ•œ' F]
variable [IsScalarTower ğ•œ ğ•œ' F]
variable {f : E â†’ F} {f' : E â†’L[ğ•œ'] F} {s : Set E} {x : E}

@[fun_prop]
theorem HasStrictFDerivAt.restrictScalars (h : HasStrictFDerivAt f f' x) :
    HasStrictFDerivAt f (f'.restrictScalars ğ•œ) x :=
  .of_isLittleO h.isLittleO

theorem HasFDerivAtFilter.restrictScalars {L} (h : HasFDerivAtFilter f f' x L) :
    HasFDerivAtFilter f (f'.restrictScalars ğ•œ) x L :=
  .of_isLittleO h.isLittleO

@[fun_prop]
theorem HasFDerivAt.restrictScalars (h : HasFDerivAt f f' x) :
    HasFDerivAt f (f'.restrictScalars ğ•œ) x :=
  .of_isLittleO h.isLittleO

@[fun_prop]
theorem HasFDerivWithinAt.restrictScalars (h : HasFDerivWithinAt f f' s x) :
    HasFDerivWithinAt f (f'.restrictScalars ğ•œ) s x :=
  .of_isLittleO h.isLittleO

@[fun_prop]
theorem DifferentiableAt.restrictScalars (h : DifferentiableAt ğ•œ' f x) : DifferentiableAt ğ•œ f x :=
  (h.hasFDerivAt.restrictScalars ğ•œ).differentiableAt

@[fun_prop]
theorem DifferentiableWithinAt.restrictScalars (h : DifferentiableWithinAt ğ•œ' f s x) :
    DifferentiableWithinAt ğ•œ f s x :=
  (h.hasFDerivWithinAt.restrictScalars ğ•œ).differentiableWithinAt

@[fun_prop]
theorem DifferentiableOn.restrictScalars (h : DifferentiableOn ğ•œ' f s) : DifferentiableOn ğ•œ f s :=
  fun x hx => (h x hx).restrictScalars ğ•œ

@[fun_prop]
theorem Differentiable.restrictScalars (h : Differentiable ğ•œ' f) : Differentiable ğ•œ f := fun x =>
  (h x).restrictScalars ğ•œ

@[fun_prop]
theorem HasFDerivWithinAt.of_restrictScalars {g' : E â†’L[ğ•œ] F} (h : HasFDerivWithinAt f g' s x)
    (H : f'.restrictScalars ğ•œ = g') : HasFDerivWithinAt f f' s x := by
  rw [â† H] at h
  exact .of_isLittleO h.isLittleO

@[fun_prop]
theorem hasFDerivAt_of_restrictScalars {g' : E â†’L[ğ•œ] F} (h : HasFDerivAt f g' x)
    (H : f'.restrictScalars ğ•œ = g') : HasFDerivAt f f' x := by
  rw [â† H] at h
  exact .of_isLittleO h.isLittleO

theorem DifferentiableAt.fderiv_restrictScalars (h : DifferentiableAt ğ•œ' f x) :
    fderiv ğ•œ f x = (fderiv ğ•œ' f x).restrictScalars ğ•œ :=
  (h.hasFDerivAt.restrictScalars ğ•œ).fderiv

theorem differentiableWithinAt_iff_restrictScalars (hf : DifferentiableWithinAt ğ•œ f s x)
    (hs : UniqueDiffWithinAt ğ•œ s x) : DifferentiableWithinAt ğ•œ' f s x â†”
      âˆƒ g' : E â†’L[ğ•œ'] F, g'.restrictScalars ğ•œ = fderivWithin ğ•œ f s x := by
  constructor
  Â· rintro âŸ¨g', hg'âŸ©
    exact âŸ¨g', hs.eq (hg'.restrictScalars ğ•œ) hf.hasFDerivWithinAtâŸ©
  Â· rintro âŸ¨f', hf'âŸ©
    exact âŸ¨f', hf.hasFDerivWithinAt.of_restrictScalars ğ•œ hf'âŸ©

theorem differentiableAt_iff_restrictScalars (hf : DifferentiableAt ğ•œ f x) :
    DifferentiableAt ğ•œ' f x â†” âˆƒ g' : E â†’L[ğ•œ'] F, g'.restrictScalars ğ•œ = fderiv ğ•œ f x := by
  rw [â† differentiableWithinAt_univ, â† fderivWithin_univ]
  exact
    differentiableWithinAt_iff_restrictScalars ğ•œ hf.differentiableWithinAt uniqueDiffWithinAt_univ

end RestrictScalars

-- END Mathlib.Analysis.Calculus.FDeriv.RestrictScalars --

import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Analysis.Calculus.FDeriv.Comp
import Mathlib.Analysis.Calculus.FDeriv.RestrictScalars

/-!
# One-dimensional derivatives of compositions of functions

In this file we prove the chain rule for the following cases:

* `HasDerivAt.comp` etc: `f : ğ•œ' â†’ ğ•œ'` composed with `g : ğ•œ â†’ ğ•œ'`;
* `HasDerivAt.scomp` etc: `f : ğ•œ' â†’ E` composed with `g : ğ•œ â†’ ğ•œ'`;
* `HasFDerivAt.comp_hasDerivAt` etc: `f : E â†’ F` composed with `g : ğ•œ â†’ E`;

Here `ğ•œ` is the base normed field, `E` and `F` are normed spaces over `ğ•œ` and `ğ•œ'` is an algebra
over `ğ•œ` (e.g., `ğ•œ'=ğ•œ` or `ğ•œ=â„`, `ğ•œ'=â„‚`).

We also give versions with the `of_eq` suffix, which require an equality proof instead
of definitional equality of the different points used in the composition. These versions are
often more flexible to use.

For a more detailed overview of one-dimensional derivatives in mathlib, see the module docstring of
`analysis/calculus/deriv/basic`.

## Keywords

derivative, chain rule
-/


universe u v w

open scoped Topology Filter ENNReal

open Filter Asymptotics Set

open ContinuousLinearMap (smulRight smulRight_one_eq_iff)

variable {ğ•œ : Type u} [NontriviallyNormedField ğ•œ]
variable {F : Type v} [NormedAddCommGroup F] [NormedSpace ğ•œ F]
variable {E : Type w} [NormedAddCommGroup E] [NormedSpace ğ•œ E]
variable {f : ğ•œ â†’ F}
variable {f' : F}
variable {x : ğ•œ}
variable {s : Set ğ•œ}
variable {L : Filter ğ•œ}

section Composition

/-!
### Derivative of the composition of a vector function and a scalar function

We use `scomp` in lemmas on composition of vector valued and scalar valued functions, and `comp`
in lemmas on composition of scalar valued functions, in analogy for `smul` and `mul` (and also
because the `comp` version with the shorter name will show up much more often in applications).
The formula for the derivative involves `smul` in `scomp` lemmas, which can be reduced to
usual multiplication in `comp` lemmas.
-/


/- For composition lemmas, we put x explicit to help the elaborator, as otherwise Lean tends to
get confused since there are too many possibilities for composition -/
variable {ğ•œ' : Type*} [NontriviallyNormedField ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] [NormedSpace ğ•œ' F]
  [IsScalarTower ğ•œ ğ•œ' F] {s' t' : Set ğ•œ'} {h : ğ•œ â†’ ğ•œ'} {hâ‚‚ : ğ•œ' â†’ ğ•œ'} {h' hâ‚‚' : ğ•œ'}
  {gâ‚ : ğ•œ' â†’ F} {gâ‚' : F} {L' : Filter ğ•œ'} {y : ğ•œ'} (x)

theorem HasDerivAtFilter.scomp (hg : HasDerivAtFilter gâ‚ gâ‚' (h x) L')
    (hh : HasDerivAtFilter h h' x L) (hL : Tendsto h L L') :
    HasDerivAtFilter (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x L := by

