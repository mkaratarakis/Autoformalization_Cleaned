
1. **Informal Theorem**  
Lift of Continuum Cardinality is Equal to Continuum: \( \mathfrak{c}^{\max(v, u_1)} = \mathfrak{c} \) : The cardinality of the continuum, denoted by \( \mathfrak{c} \), remains unchanged when lifted to a higher universe. Specifically, for any universe \( v \) and \( u_1 \), the lift of \( \mathfrak{c} \) from universe \( v \) to universe \( \max(v, u_1) \) is equal to \( \mathfrak{c} \) itself, i.e., \( \mathfrak{c}^{\max(v, u_1)} = \mathfrak{c} \).

2. **Informal Proof**  
We begin by expressing the continuum cardinality \( \mathfrak{c} \) as \( 2^{\aleph_0} \). Using the property that lifting the exponentiation of 2 to any cardinal \( a \) results in the exponentiation of 2 to the lifted cardinal \( a \), we have:

\[
\text{Cardinal.lift}(2^{\aleph_0}) = 2^{\text{Cardinal.lift}(\aleph_0)}
\]

Next, we use the fact that lifting \( \aleph_0 \) to any universe level results in \( \aleph_0 \) itself:

\[
\text{Cardinal.lift}(\aleph_0) = \aleph_0
\]

Thus, we get:

\[
2^{\text{Cardinal.lift}(\aleph_0)} = 2^{\aleph_0}
\]

Finally, we recognize that \( 2^{\aleph_0} \) is equal to \( \mathfrak{c} \):

\[
2^{\aleph_0} = \mathfrak{c}
\]

Therefore, we have:

\[
\text{Cardinal.lift}(\mathfrak{c}) = \mathfrak{c}
\]

This completes the proof that the lift of the continuum cardinality to any higher universe is equal to the continuum cardinality itself.

3. **Formal Theorem**  
example : lift.{v} ùî† = ùî† := by sorry

4. **Prefix**
import Mathlib.SetTheory.Cardinal.Ordinal
import Mathlib.SetTheory.Cardinal.Continuum

open Cardinal
open Cardinal

example : lift.{v} ùî† = ùî† := by

5. **Header Information**  
-- BEGIN Mathlib.SetTheory.Cardinal.Ordinal --
/-
Copyright (c) 2024 Violeta Hern√°ndez Palacios. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Violeta Hern√°ndez Palacios
-/
import Mathlib.SetTheory.Cardinal.Arithmetic
import Mathlib.SetTheory.Ordinal.Principal

/-!
# Ordinal arithmetic with cardinals

This file collects results about the cardinality of different ordinal operations.
-/

universe u v
open Cardinal Ordinal Set

/-! ### Cardinal operations with ordinal indices -/

namespace Cardinal

/-- Bounds the cardinal of an ordinal-indexed union of sets. -/
lemma mk_iUnion_Ordinal_lift_le_of_le {Œ≤ : Type v} {o : Ordinal.{u}} {c : Cardinal.{v}}
    (ho : lift.{v} o.card ‚â§ lift.{u} c) (hc : ‚Ñµ‚ÇÄ ‚â§ c) (A : Ordinal ‚Üí Set Œ≤)
    (hA : ‚àÄ j < o, #(A j) ‚â§ c) : #(‚ãÉ j < o, A j) ‚â§ c := by
  simp_rw [‚Üê mem_Iio, biUnion_eq_iUnion, iUnion, iSup, ‚Üê o.enumIsoToType.symm.surjective.range_comp]
  rw [‚Üê lift_le.{u}]
  apply ((mk_iUnion_le_lift _).trans _).trans_eq (mul_eq_self (aleph0_le_lift.2 hc))
  rw [mk_toType]
  refine mul_le_mul' ho (ciSup_le' ?_)
  intro i
  simpa using hA _ (o.enumIsoToType.symm i).2

lemma mk_iUnion_Ordinal_le_of_le {Œ≤ : Type*} {o : Ordinal} {c : Cardinal}
    (ho : o.card ‚â§ c) (hc : ‚Ñµ‚ÇÄ ‚â§ c) (A : Ordinal ‚Üí Set Œ≤)
    (hA : ‚àÄ j < o, #(A j) ‚â§ c) : #(‚ãÉ j < o, A j) ‚â§ c := by
  apply mk_iUnion_Ordinal_lift_le_of_le _ hc A hA
  rwa [Cardinal.lift_le]

end Cardinal

@[deprecated mk_iUnion_Ordinal_le_of_le (since := "2024-11-02")]
alias Ordinal.Cardinal.mk_iUnion_Ordinal_le_of_le := mk_iUnion_Ordinal_le_of_le

/-! ### Cardinality of ordinals -/

namespace Ordinal

theorem lift_card_iSup_le_sum_card {Œπ : Type u} [Small.{v} Œπ] (f : Œπ ‚Üí Ordinal.{v}) :
    Cardinal.lift.{u} (‚®Ü i, f i).card ‚â§ Cardinal.sum fun i ‚Ü¶ (f i).card := by
  simp_rw [‚Üê mk_toType]
  rw [‚Üê mk_sigma, ‚Üê Cardinal.lift_id'.{v} #(Œ£ _, _), ‚Üê Cardinal.lift_umax.{v, u}]
  apply lift_mk_le_lift_mk_of_surjective (f := enumIsoToType _ ‚àò (‚ü®(enumIsoToType _).symm ¬∑.2,
    (mem_Iio.mp ((enumIsoToType _).symm _).2).trans_le (Ordinal.le_iSup _ _)‚ü©))
  rw [EquivLike.comp_surjective]
  rintro ‚ü®x, hx‚ü©
  obtain ‚ü®i, hi‚ü© := Ordinal.lt_iSup_iff.mp hx
  exact ‚ü®‚ü®i, enumIsoToType _ ‚ü®x, hi‚ü©‚ü©, by simp‚ü©

theorem card_iSup_le_sum_card {Œπ : Type u} (f : Œπ ‚Üí Ordinal.{max u v}) :
    (‚®Ü i, f i).card ‚â§ Cardinal.sum (fun i ‚Ü¶ (f i).card) := by
  have := lift_card_iSup_le_sum_card f
  rwa [Cardinal.lift_id'] at this

theorem card_iSup_Iio_le_sum_card {o : Ordinal.{u}} (f : Iio o ‚Üí Ordinal.{max u v}) :
    (‚®Ü a : Iio o, f a).card ‚â§ Cardinal.sum fun i ‚Ü¶ (f ((enumIsoToType o).symm i)).card := by
  apply le_of_eq_of_le (congr_arg _ _).symm (card_iSup_le_sum_card _)
  simpa using (enumIsoToType o).symm.iSup_comp (g := fun x ‚Ü¶ f x)

theorem card_iSup_Iio_le_card_mul_iSup {o : Ordinal.{u}} (f : Iio o ‚Üí Ordinal.{max u v}) :
    (‚®Ü a : Iio o, f a).card ‚â§ Cardinal.lift.{v} o.card * ‚®Ü a : Iio o, (f a).card := by
  apply (card_iSup_Iio_le_sum_card f).trans
  convert ‚Üê sum_le_iSup_lift _
  ¬∑ exact mk_toType o
  ¬∑ exact (enumIsoToType o).symm.iSup_comp (g := fun x ‚Ü¶ (f x).card)

theorem card_opow_le_of_omega0_le_left {a : Ordinal} (ha : œâ ‚â§ a) (b : Ordinal) :
    (a ^ b).card ‚â§ max a.card b.card := by
  refine limitRecOn b ?_ ?_ ?_
  ¬∑ simpa using one_lt_omega0.le.trans ha
  ¬∑ intro b IH
    rw [opow_succ, card_mul, card_succ, Cardinal.mul_eq_max_of_aleph0_le_right, max_comm]
    ¬∑ apply (max_le_max_left _ IH).trans
      rw [‚Üê max_assoc, max_self]
      exact max_le_max_left _ le_self_add
    ¬∑ rw [ne_eq, card_eq_zero, opow_eq_zero]
      rintro ‚ü®rfl, -‚ü©
      cases omega0_pos.not_le ha
    ¬∑ rwa [aleph0_le_card]
  ¬∑ intro b hb IH
    rw [(isNormal_opow (one_lt_omega0.trans_le ha)).apply_of_isLimit hb]
    apply (card_iSup_Iio_le_card_mul_iSup _).trans
    rw [Cardinal.lift_id, Cardinal.mul_eq_max_of_aleph0_le_right, max_comm]
    ¬∑ apply max_le _ (le_max_right _ _)
      apply ciSup_le'
      intro c
      exact (IH c.1 c.2).trans (max_le_max_left _ (card_le_card c.2.le))
    ¬∑ simpa using hb.pos.ne'
    ¬∑ refine le_ciSup_of_le ?_ ‚ü®1, one_lt_omega0.trans_le <| omega0_le_of_isLimit hb‚ü© ?_
      ¬∑ exact Cardinal.bddAbove_of_small _
      ¬∑ simpa

theorem card_opow_le_of_omega0_le_right (a : Ordinal) {b : Ordinal} (hb : œâ ‚â§ b) :
    (a ^ b).card ‚â§ max a.card b.card := by
  obtain ‚ü®n, rfl‚ü© | ha := eq_nat_or_omega0_le a
  ¬∑ apply (card_le_card <| opow_le_opow_left b (nat_lt_omega0 n).le).trans
    apply (card_opow_le_of_omega0_le_left le_rfl _).trans
    simp [hb]
  ¬∑ exact card_opow_le_of_omega0_le_left ha b

theorem card_opow_le (a b : Ordinal) : (a ^ b).card ‚â§ max ‚Ñµ‚ÇÄ (max a.card b.card) := by
  obtain ‚ü®n, rfl‚ü© | ha := eq_nat_or_omega0_le a
  ¬∑ obtain ‚ü®m, rfl‚ü© | hb := eq_nat_or_omega0_le b
    ¬∑ rw [‚Üê natCast_opow, card_nat]
      exact le_max_of_le_left (nat_lt_aleph0 _).le
    ¬∑ exact (card_opow_le_of_omega0_le_right _ hb).trans (le_max_right _ _)
  ¬∑ exact (card_opow_le_of_omega0_le_left ha _).trans (le_max_right _ _)

theorem card_opow_eq_of_omega0_le_left {a b : Ordinal} (ha : œâ ‚â§ a) (hb : 0 < b) :
    (a ^ b).card = max a.card b.card := by
  apply (card_opow_le_of_omega0_le_left ha b).antisymm (max_le _ _) <;> apply card_le_card
  ¬∑ exact left_le_opow a hb
  ¬∑ exact right_le_opow b (one_lt_omega0.trans_le ha)

theorem card_opow_eq_of_omega0_le_right {a b : Ordinal} (ha : 1 < a) (hb : œâ ‚â§ b) :
    (a ^ b).card = max a.card b.card := by
  apply (card_opow_le_of_omega0_le_right a hb).antisymm (max_le _ _) <;> apply card_le_card
  ¬∑ exact left_le_opow a (omega0_pos.trans_le hb)
  ¬∑ exact right_le_opow b ha

theorem card_omega0_opow {a : Ordinal} (h : a ‚â† 0) : card (œâ ^ a) = max ‚Ñµ‚ÇÄ a.card := by
  rw [card_opow_eq_of_omega0_le_left le_rfl h.bot_lt, card_omega0]

theorem card_opow_omega0 {a : Ordinal} (h : 1 < a) : card (a ^ œâ) = max ‚Ñµ‚ÇÄ a.card := by
  rw [card_opow_eq_of_omega0_le_right h le_rfl, card_omega0, max_comm]

theorem principal_opow_omega (o : Ordinal) : Principal (¬∑ ^ ¬∑) (œâ_ o) := by
  obtain rfl | ho := Ordinal.eq_zero_or_pos o
  ¬∑ rw [omega_zero]
    exact principal_opow_omega0
  ¬∑ intro a b ha hb
    rw [lt_omega_iff_card_lt] at ha hb ‚ä¢
    apply (card_opow_le a b).trans_lt (max_lt _ (max_lt ha hb))
    rwa [‚Üê aleph_zero, aleph_lt_aleph]

theorem IsInitial.principal_opow {o : Ordinal} (h : IsInitial o) (ho : œâ ‚â§ o) :
    Principal (¬∑ ^ ¬∑) o := by
  obtain ‚ü®a, rfl‚ü© := mem_range_omega_iff.2 ‚ü®ho, h‚ü©
  exact principal_opow_omega a

theorem principal_opow_ord {c : Cardinal} (hc : ‚Ñµ‚ÇÄ ‚â§ c) : Principal (¬∑ ^ ¬∑) c.ord := by
  apply (isInitial_ord c).principal_opow
  rwa [omega0_le_ord]

/-! ### Initial ordinals are principal -/

theorem principal_add_ord {c : Cardinal} (hc : ‚Ñµ‚ÇÄ ‚â§ c) : Principal (¬∑ + ¬∑) c.ord := by
  intro a b ha hb
  rw [lt_ord, card_add] at *
  exact add_lt_of_lt hc ha hb

theorem IsInitial.principal_add {o : Ordinal} (h : IsInitial o) (ho : œâ ‚â§ o) :
    Principal (¬∑ + ¬∑) o := by
  rw [‚Üê h.ord_card]
  apply principal_add_ord
  rwa [aleph0_le_card]

theorem principal_add_omega (o : Ordinal) : Principal (¬∑ + ¬∑) (œâ_ o) :=
  (isInitial_omega o).principal_add (omega0_le_omega o)

theorem principal_mul_ord {c : Cardinal} (hc : ‚Ñµ‚ÇÄ ‚â§ c) : Principal (¬∑ * ¬∑) c.ord := by
  intro a b ha hb
  rw [lt_ord, card_mul] at *
  exact mul_lt_of_lt hc ha hb

theorem IsInitial.principal_mul {o : Ordinal} (h : IsInitial o) (ho : œâ ‚â§ o) :
    Principal (¬∑ * ¬∑) o := by
  rw [‚Üê h.ord_card]
  apply principal_mul_ord
  rwa [aleph0_le_card]

theorem principal_mul_omega (o : Ordinal) : Principal (¬∑ * ¬∑) (œâ_ o) :=
  (isInitial_omega o).principal_mul (omega0_le_omega o)

@[deprecated principal_add_omega (since := "2024-11-08")]
theorem _root_.Cardinal.principal_add_aleph (o : Ordinal) : Principal (¬∑ + ¬∑) (‚Ñµ_ o).ord :=
  principal_add_ord <| aleph0_le_aleph o

end Ordinal

-- END Mathlib.SetTheory.Cardinal.Ordinal --

import Mathlib.SetTheory.Cardinal.Arithmetic

/-!
# Cardinality of continuum

In this file we define `Cardinal.continuum` (notation: `ùî†`, localized in `Cardinal`) to be `2 ^ ‚Ñµ‚ÇÄ`.
We also prove some `simp` lemmas about cardinal arithmetic involving `ùî†`.

## Notation

- `ùî†` : notation for `Cardinal.continuum` in locale `Cardinal`.
-/


namespace Cardinal

universe u v

open Cardinal

/-- Cardinality of the continuum. -/
def continuum : Cardinal.{u} :=
  2 ^ ‚Ñµ‚ÇÄ

@[inherit_doc] scoped notation "ùî†" => Cardinal.continuum

@[simp]
theorem two_power_aleph0 : 2 ^ ‚Ñµ‚ÇÄ = ùî† :=
  rfl

@[simp]
theorem lift_continuum : lift.{v} ùî† = ùî† := by

